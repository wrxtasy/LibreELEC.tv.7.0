From e113f101ad974d44d0515f39307025da2ec97386 Mon Sep 17 00:00:00 2001
From: Jamie Coldhill <wrxtasy@amnet.net.au>
Date: Sun, 2 Oct 2016 21:04:29 +0800
Subject: [PATCH] Update: deinterlace again

---
 drivers/amlogic/deinterlace/Makefile         |   13 +-
 drivers/amlogic/deinterlace/deinterlace.h    |  156 +-
 drivers/amlogic/deinterlace/deinterlace_hw.c | 1115 +++++--
 drivers/amlogic/deinterlace/deinterlace_pd.c |   12 +-
 drivers/amlogic/deinterlace/detect3d.c       |   77 +-
 drivers/amlogic/deinterlace/detect3d.h       |    6 +-
 drivers/amlogic/deinterlace/dnr.c            |   49 +-
 drivers/amlogic/deinterlace/film_fw1.c       | 1367 ++++++++
 drivers/amlogic/deinterlace/film_vof_soft.h  |  180 ++
 drivers/amlogic/deinterlace/flm_mod_xx.c     |  520 +++
 drivers/amlogic/deinterlace/register.h       | 4466 +++++++++++++++++++++-----
 drivers/amlogic/deinterlace/tffbff_check.c   |  210 ++
 drivers/amlogic/deinterlace/vof_soft_top.c   |  640 ++++
 13 files changed, 7581 insertions(+), 1230 deletions(-)
 create mode 100644 drivers/amlogic/deinterlace/film_fw1.c
 create mode 100644 drivers/amlogic/deinterlace/film_vof_soft.h
 create mode 100644 drivers/amlogic/deinterlace/flm_mod_xx.c
 create mode 100644 drivers/amlogic/deinterlace/tffbff_check.c
 create mode 100644 drivers/amlogic/deinterlace/vof_soft_top.c

diff --git a/drivers/amlogic/deinterlace/Makefile b/drivers/amlogic/deinterlace/Makefile
index 48aa555..437540c 100644
--- a/drivers/amlogic/deinterlace/Makefile
+++ b/drivers/amlogic/deinterlace/Makefile
@@ -1,11 +1,12 @@
 #
 # Makefile for the Post Process Manager device
 #
-
-di-objs = deinterlace.o \
-    deinterlace_hw.o \
-    deinterlace_pd.o \
-	dnr.o			 \
-
+ifeq ($(TARGET_BUILD_VARIANT),userdebug)
+ccflags-y := -D DEBUG_SUPPORT
+else
+ccflags-y := -DDEBUG
+endif
 obj-$(CONFIG_DEINTERLACE) += di.o
+di-objs = deinterlace.o deinterlace_hw.o deinterlace_pd.o dnr.o vof_soft_top.o film_fw1.o flm_mod_xx.o detect3d.o tffbff_check.o
+
 
diff --git a/drivers/amlogic/deinterlace/deinterlace.h b/drivers/amlogic/deinterlace/deinterlace.h
index 58ecad0..554cf27 100644
--- a/drivers/amlogic/deinterlace/deinterlace.h
+++ b/drivers/amlogic/deinterlace/deinterlace.h
@@ -3,12 +3,28 @@
 #include <linux/cdev.h>
 #include <linux/amlogic/amports/vframe.h>
 #include <linux/amlogic/amports/video.h>
+#include <linux/atomic.h>
+
 /* di hardware version m8m2*/
 #define NEW_DI_V1 0x00000002 /* from m6tvc */
 #define NEW_DI_V2 0x00000004 /* from m6tvd */
 #define NEW_DI_V3 0x00000008 /* from gx */
 #define NEW_DI_V4 0x00000010 /* dnr added */
 
+/*trigger_pre_di_process param*/
+#define TRIGGER_PRE_BY_PUT		'p'
+#define TRIGGER_PRE_BY_DE_IRQ		'i'
+#define TRIGGER_PRE_BY_UNREG		'u'
+/*di_timer_handle*/
+#define TRIGGER_PRE_BY_TIMER		't'
+#define TRIGGER_PRE_BY_FORCE_UNREG	'f'
+#define TRIGGER_PRE_BY_VFRAME_READY	'r'
+#define TRIGGER_PRE_BY_PROVERDER_UNREG	'n'
+#define TRIGGER_PRE_BY_DEBUG_DISABLE	'd'
+#define TRIGGER_PRE_BY_TIMERC		'T'
+#define TRIGGER_PRE_BY_PROVERDER_REG	'R'
+
+
 /*vframe define*/
 #define vframe_t struct vframe_s
 
@@ -19,7 +35,7 @@
 /* #if MESON_CPU_TYPE >= MESON_CPU_TYPE_MESON6 */
 #define NEW_KEEP_LAST_FRAME
 /* #endif */
-#undef DET3D
+#define	DET3D
 #undef SUPPORT_MPEG_TO_VDIN /* for all ic after m6c@20140731 */
 
 #ifndef CONFIG_VSYNC_RDMA
@@ -31,11 +47,15 @@
 #endif
 #endif
 
+#include "film_vof_soft.h"
+
 /************************************
 *	 di hardware level interface
 *************************************/
 #define MAX_WIN_NUM			5
-
+/* if post size < 80, filter of ei can't work */
+#define MIN_POST_WIDTH  80
+#define MIN_BLEND_WIDTH  27
 struct pulldown_detect_info_s {
 	unsigned field_diff;
 /* total pixels difference between current field and previous field */
@@ -109,11 +129,6 @@ enum pulldown_mode_e {
 };
 #define pulldown_mode_t enum pulldown_mode_e
 struct di_buf_s {
-#ifdef D2D3_SUPPORT
-	unsigned long dp_buf_adr;
-	unsigned int dp_buf_size;
-	unsigned int reverse_flag;
-#endif
 #ifdef USE_LIST
 	struct list_head list;
 #endif
@@ -141,7 +156,7 @@ struct di_buf_s {
 	int cnt_canvas_idx;
 #endif
 #ifdef NEW_DI_V3
-	unsigned int mcinfo_adr;
+	unsigned long mcinfo_adr;
 	int mcinfo_canvas_idx;
 	unsigned long mcvec_adr;
 	int mcvec_canvas_idx;
@@ -151,6 +166,21 @@ struct di_buf_s {
 	unsigned int regs[26];/* reg 0x2fb0~0x2fc9 */
 	} curr_field_mcinfo;
 #endif
+	/* blend window */
+	unsigned short reg0_s;
+	unsigned short reg0_e;
+	unsigned short reg0_bmode;
+	unsigned short reg1_s;
+	unsigned short reg1_e;
+	unsigned short reg1_bmode;
+	unsigned short reg2_s;
+	unsigned short reg2_e;
+	unsigned short reg2_bmode;
+	unsigned short reg3_s;
+	unsigned short reg3_e;
+	unsigned short reg3_bmode;
+	/* tff bff check result bit[1:0]*/
+	unsigned int privated;
 	unsigned int canvas_config_flag;
 	/* 0,configed; 1,config type 1 (prog);
 	2, config type 2 (interlace) */
@@ -168,8 +198,11 @@ struct di_buf_s {
 	struct di_buf_s *di_buf_dup_p[5];
 	/* 0~4: n-2, n-1, n, n+1, n+2;	n is the field to display*/
 	struct di_buf_s *di_wr_linked_buf;
+	/* debug for di-vf-get/put
+	1: after get
+	0: after put*/
+	atomic_t di_cnt;
 };
-#define di_buf_t struct di_buf_s
 extern uint di_mtn_1_ctrl1;
 #ifdef DET3D
 extern bool det3d_en;
@@ -186,7 +219,12 @@ extern void di_hw_init(void);
 
 extern void di_hw_uninit(void);
 
+extern void enable_di_pre_mif(int enable);
+
 extern int di_vscale_skip_count;
+
+extern unsigned int di_force_bit_mode;
+
 /*
 di hardware internal
 */
@@ -203,7 +241,7 @@ di hardware internal
 #define MAX_CANVAS_HEIGHT				1088
 #endif
 
-struct DI_MIF_TYPE {
+struct DI_MIF_s {
 	unsigned short	luma_x_start0;
 	unsigned short	luma_x_end0;
 	unsigned short	luma_y_start0;
@@ -214,8 +252,10 @@ struct DI_MIF_TYPE {
 	unsigned short	chroma_y_end0;
 	unsigned		set_separate_en:2;
 	unsigned		src_field_mode:1;
+	unsigned		src_prog:1;
 	unsigned		video_mode:1;
 	unsigned		output_field_num:1;
+	unsigned		bit_mode:2;
 	/*
 	unsigned		burst_size_y:2; set 3 as default
 	unsigned		burst_size_cb:2;set 1 as default
@@ -225,24 +265,23 @@ struct DI_MIF_TYPE {
 	unsigned		canvas0_addr1:8;
 	unsigned		canvas0_addr2:8;
 };
-#define DI_MIF_t struct DI_MIF_TYPE
-struct DI_SIM_MIF_TYPE {
+struct DI_SIM_MIF_s {
 	unsigned short	start_x;
 	unsigned short	end_x;
 	unsigned short	start_y;
 	unsigned short	end_y;
 	unsigned short	canvas_num;
+	unsigned short	bit_mode;
 };
-#define DI_SIM_MIF_t struct DI_SIM_MIF_TYPE
-struct DI_MC_MIF_TYPE {
+struct DI_MC_MIF_s {
 	unsigned short start_x;
 	unsigned short start_y;
 	unsigned short size_x;
 	unsigned short size_y;
 	unsigned short canvas_num;
 	unsigned short blend_mode;
+	unsigned short vecrd_offset;
 };
-#define DI_MC_MIF_t struct DI_MC_MIF_TYPE
 void disable_deinterlace(void);
 
 void disable_pre_deinterlace(void);
@@ -258,15 +297,15 @@ void enable_film_mode_check(unsigned int width, unsigned int height,
 		enum vframe_source_type_e);
 
 void enable_di_pre_aml(
-	DI_MIF_t		*di_inp_mif,
-	DI_MIF_t		*di_mem_mif,
-	DI_MIF_t		*di_chan2_mif,
-	DI_SIM_MIF_t	*di_nrwr_mif,
-	DI_SIM_MIF_t	*di_mtnwr_mif,
+	struct DI_MIF_s		*di_inp_mif,
+	struct DI_MIF_s		*di_mem_mif,
+	struct DI_MIF_s		*di_chan2_mif,
+	struct DI_SIM_MIF_s	*di_nrwr_mif,
+	struct DI_SIM_MIF_s	*di_mtnwr_mif,
 #ifdef NEW_DI_V1
-	DI_SIM_MIF_t    *di_contp2rd_mif,
-	DI_SIM_MIF_t    *di_contprd_mif,
-	DI_SIM_MIF_t    *di_contwr_mif,
+	struct DI_SIM_MIF_s    *di_contp2rd_mif,
+	struct DI_SIM_MIF_s    *di_contprd_mif,
+	struct DI_SIM_MIF_s    *di_contwr_mif,
 #endif
 	int nr_en, int mtn_en, int pd32_check_en, int pd22_check_en,
 	int hist_check_en, int pre_field_num, int pre_vdin_link,
@@ -274,11 +313,15 @@ void enable_di_pre_aml(
 	);
 void enable_afbc_input(struct vframe_s *vf);
 #ifdef NEW_DI_V3
-void enable_mc_di_pre(DI_MC_MIF_t *di_mcinford_mif,
-	DI_MC_MIF_t *di_mcinfowr_mif, DI_MC_MIF_t *di_mcvecwr_mif, int urgent);
-void enable_mc_di_post(DI_MC_MIF_t *di_mcvecrd_mif, int urgent, bool reverse);
+void enable_mc_di_pre(struct DI_MC_MIF_s *di_mcinford_mif,
+	struct DI_MC_MIF_s *di_mcinfowr_mif,
+	struct DI_MC_MIF_s *di_mcvecwr_mif, int urgent);
+void enable_mc_di_post(struct DI_MC_MIF_s *di_mcvecrd_mif,
+	int urgent, bool reverse);
 #endif
 
+void read_new_pulldown_info(struct FlmModReg_t *pFMRegp);
+
 void enable_region_blend(
 	int reg0_en, int reg0_start_x, int reg0_end_x, int reg0_start_y,
 	int reg0_end_y, int reg0_mode, int reg1_en, int reg1_start_x,
@@ -300,13 +343,14 @@ void initial_di_pre_aml(int hsize_pre, int vsize_pre, int hold_line);
 void initial_di_post_2(int hsize_post, int vsize_post, int hold_line);
 
 void enable_di_post_2(
-	DI_MIF_t		*di_buf0_mif,
-	DI_MIF_t		*di_buf1_mif,
-	DI_SIM_MIF_t	*di_diwr_mif,
+	struct DI_MIF_s		*di_buf0_mif,
+	struct DI_MIF_s		*di_buf1_mif,
+	struct DI_MIF_s		*di_buf2_mif,
+	struct DI_SIM_MIF_s	*di_diwr_mif,
 	#ifndef NEW_DI_V2
-	DI_SIM_MIF_t	*di_mtncrd_mif,
+	struct DI_SIM_MIF_s	*di_mtncrd_mif,
 	#endif
-	DI_SIM_MIF_t	*di_mtnprd_mif,
+	struct DI_SIM_MIF_s	*di_mtnprd_mif,
 	int ei_en, int blend_en, int blend_mtn_en, int blend_mode,
 	int di_vpp_en, int di_ddr_en,
 	int post_field_num, int hold_line , int urgent
@@ -316,16 +360,15 @@ void enable_di_post_2(
 );
 
 void di_post_switch_buffer(
-	DI_MIF_t		*di_buf0_mif,
-	DI_MIF_t		*di_buf1_mif,
-	DI_SIM_MIF_t	*di_diwr_mif,
+	struct DI_MIF_s		*di_buf0_mif,
+	struct DI_MIF_s		*di_buf1_mif,
+	struct DI_MIF_s		*di_buf2_mif,
+	struct DI_SIM_MIF_s	*di_diwr_mif,
 	#ifndef NEW_DI_V2
-	DI_SIM_MIF_t	*di_mtncrd_mif,
-	#endif
-	DI_SIM_MIF_t	*di_mtnprd_mif,
-	#ifdef MCDI_SUPPORT
-	DI_MC_MIF_t		*di_mcvecrd_mif,
+	struct DI_SIM_MIF_s	*di_mtncrd_mif,
 	#endif
+	struct DI_SIM_MIF_s	*di_mtnprd_mif,
+	struct DI_MC_MIF_s		*di_mcvecrd_mif,
 	int ei_en, int blend_en, int blend_mtn_en, int blend_mode,
 	int di_vpp_en, int di_ddr_en,
 	int post_field_num, int hold_line, int urgent
@@ -343,6 +386,7 @@ void read_mtn_info(unsigned long *mtn_info, unsigned long*);
 /* for video reverse */
 void di_post_read_reverse(bool reverse);
 void di_post_read_reverse_irq(bool reverse);
+extern void recycle_keep_buffer(void);
 
 #undef DI_DEBUG
 
@@ -356,6 +400,14 @@ void di_post_read_reverse_irq(bool reverse);
 
 extern unsigned int di_log_flag;
 extern unsigned int di_debug_flag;
+extern bool mcpre_en;
+extern bool dnr_reg_update;
+extern int mpeg2vdin_flag;
+extern int di_vscale_skip_count_real;
+extern unsigned int pulldown_enable;
+
+extern bool post_wr_en;
+extern unsigned int post_wr_surpport;
 
 int di_print(const char *fmt, ...);
 
@@ -385,8 +437,23 @@ struct reg_cfg_ {
 int get_current_vscale_skip_count(struct vframe_s *vf);
 
 void di_set_power_control(unsigned char type, unsigned char enable);
+void diwr_set_power_control(unsigned char enable);
 
 unsigned char di_get_power_control(unsigned char type);
+void config_di_bit_mode(vframe_t *vframe, unsigned int bypass_flag);
+void combing_pd22_window_config(unsigned int width, unsigned int height);
+int tff_bff_check(int height, int width);
+void tbff_init(void);
+#ifdef CONFIG_AM_ATVDEMOD
+extern int aml_atvdemod_get_snr_ex(void);
+#endif
+
+void DI_Wr(unsigned int addr, unsigned int val);
+void DI_Wr_reg_bits(unsigned int adr, unsigned int val,
+		unsigned int start, unsigned int len);
+void DI_VSYNC_WR_MPEG_REG(unsigned int addr, unsigned int val);
+void DI_VSYNC_WR_MPEG_REG_BITS(unsigned int addr, unsigned int val,
+	unsigned int start, unsigned int len);
 
 #define DI_COUNT   1
 
@@ -404,6 +471,17 @@ struct di_dev_s {
 	unsigned int	   buf_num_avail;
 	unsigned int	   hw_version;
 	int							rdma_handle;
+	/* is surpport nr10bit */
+	unsigned int	   nr10bit_surpport;
+	/* is DI surpport post wr to mem for OMX */
+	unsigned int       post_wr_surpport;
 };
 #define di_dev_t struct di_dev_s
+
+#define di_pr_info(fmt, args ...)   pr_info("DI: " fmt, ## args)
+
+#define pr_dbg(fmt, args ...)       pr_debug("DI: " fmt, ## args)
+
+#define pr_error(fmt, args ...)     pr_err("DI: " fmt, ## args)
+
 #endif
diff --git a/drivers/amlogic/deinterlace/deinterlace_hw.c b/drivers/amlogic/deinterlace/deinterlace_hw.c
index 3c69630..8731a11 100644
--- a/drivers/amlogic/deinterlace/deinterlace_hw.c
+++ b/drivers/amlogic/deinterlace/deinterlace_hw.c
@@ -16,6 +16,8 @@
 #include "detect3d.h"
 #endif
 
+#include "film_vof_soft.h"
+
 #ifndef DI_CHAN2_CANVAS
 #define DI_CHAN2_CANVAS DI_CHAN2_CANVAS0
 #endif
@@ -29,14 +31,13 @@
 #define DI_CHAN2_LUMA_RPT_PAT DI_CHAN2_LUMA0_RPT_PAT
 #endif
 
-uint di_mtn_1_ctrl1;
+uint di_mtn_1_ctrl1 = 0xa0202015;
 uint mtn_ctrl1;
 
 static bool cue_enable;
 
 pd_detect_threshold_t win_pd_th[MAX_WIN_NUM];
 pd_win_prop_t pd_win_prop[MAX_WIN_NUM];
-extern int mpeg2vdin_flag;
 
 static bool frame_dynamic;
 MODULE_PARM_DESC(frame_dynamic, "\n frame_dynamic\n");
@@ -52,20 +53,43 @@ module_param(frame_dynamic_level, int, 0664);
 
 MODULE_PARM_DESC(cue_enable, "\n cue_enable\n");
 module_param(cue_enable, bool, 0664);
-#ifdef MCDI_SUPPORT
+
 static unsigned short mcen_mode = 1;
-MODULE_PARM_DESC(mcen_mode, "\n blend mc enable\n");
+MODULE_PARM_DESC(mcen_mode, "\n mcen mode\n");
 module_param(mcen_mode, ushort, 0664);
-#endif
+static unsigned short mcuv_en = 1;
+MODULE_PARM_DESC(mcuv_en, "\n blend mcuv enable\n");
+module_param(mcuv_en, ushort, 0664);
+static unsigned short mcdebug_mode;
+MODULE_PARM_DESC(mcdebug_mode, "\n mcdi mcdebugmode\n");
+module_param(mcdebug_mode, ushort, 0664);
+
+static unsigned short debug_blend_mode_ctrl = 0xff;
+MODULE_PARM_DESC(debug_blend_mode_ctrl, "\n debug blend mode ctrl\n");
+module_param(debug_blend_mode_ctrl, ushort, 0664);
+/*
+ * 0: use vframe->bitdepth,
+ * 8: froce to 8 bit mode.
+ * 10: froce to 10 bit mode and enable nr 10 bit.
+ */
+unsigned int di_force_bit_mode = 10;
+module_param(di_force_bit_mode, uint, 0664);
+MODULE_PARM_DESC(di_force_bit_mode, "force DI bit mode to 8 or 10 bit");
+
+static unsigned short mc_pre_flag = 2;
+MODULE_PARM_DESC(mc_pre_flag, "\n mc per/forward flag\n");
+module_param(mc_pre_flag, ushort, 0664);
 
 #ifdef DET3D
 static unsigned int det3d_cfg;
+module_param(det3d_cfg, uint, 0664);
+MODULE_PARM_DESC(det3d_cfg, "det3d_cfg");
 #endif
 
 static int vdin_en;
 
 static void set_di_inp_fmt_more(
-		int hfmt_en,
+		unsigned int repeat_l0_en,
 		int hz_yc_ratio,	/* 2bit */
 		int hz_ini_phase,	/* 4bit */
 		int vfmt_en,
@@ -76,7 +100,7 @@ static void set_di_inp_fmt_more(
 		int hz_rpt		/* 1bit */
 	);
 
-static void set_di_inp_mif(DI_MIF_t  *mif, int urgent, int hold_line);
+static void set_di_inp_mif(struct DI_MIF_s  *mif, int urgent, int hold_line);
 
 static void set_di_mem_fmt_more(
 		int hfmt_en,
@@ -90,7 +114,19 @@ static void set_di_mem_fmt_more(
 		int hz_rpt	/* 1bit */
 	);
 
-static void set_di_mem_mif(DI_MIF_t *mif, int urgent, int hold_line);
+static void set_di_mem_mif(struct DI_MIF_s *mif, int urgent, int hold_line);
+
+static void set_di_if0_fmt_more(
+		int hfmt_en,
+		int hz_yc_ratio,		/* 2bit */
+		int hz_ini_phase,		/* 4bit */
+		int vfmt_en,
+		int vt_yc_ratio,		/* 2bit */
+		int vt_ini_phase,		/* 4bit */
+		int y_length,
+		int c_length,
+		int hz_rpt				  /* 1bit */
+	);
 
 static void set_di_if1_fmt_more(
 		int hfmt_en,
@@ -104,74 +140,92 @@ static void set_di_if1_fmt_more(
 		int hz_rpt		/* 1bit */
 	);
 
-static void set_di_if1_mif(DI_MIF_t *mif, int urgent, int hold_line);
+static void set_di_if1_mif(struct DI_MIF_s *mif, int urgent, int hold_line);
 
-static void set_di_chan2_mif(DI_MIF_t *mif, int urgent, int hold_line);
+static void set_di_chan2_mif(struct DI_MIF_s *mif, int urgent, int hold_line);
 
-static void set_di_if0_mif(DI_MIF_t *mif, int urgent, int hold_line);
+static void set_di_if0_mif(struct DI_MIF_s *mif, int urgent, int hold_line);
 
 static void di_nr_init(void);
 #if (defined NEW_DI_V2 && !defined NEW_DI_TV)
 static void ma_di_init(void)
 {
 	/* 420->422 chrome difference is large motion is large,flick */
-	Wr(DI_MTN_1_CTRL4, 0x01800880);
-	Wr(DI_MTN_1_CTRL7, 0x0a800480);
+	DI_Wr(DI_MTN_1_CTRL4, 0x01800880);
+	DI_Wr(DI_MTN_1_CTRL7, 0x0a800480);
 	/* ei setting */
-	Wr(DI_EI_CTRL0, 0x00ff0100);
-	Wr(DI_EI_CTRL1, 0x5a0a0f2d);
-	Wr(DI_EI_CTRL2, 0x050a0a5d);
-	Wr(DI_EI_CTRL3, 0x80000013);
+	DI_Wr(DI_EI_CTRL0, 0x00ff0100);
+	DI_Wr(DI_EI_CTRL1, 0x5a0a0f2d);
+	DI_Wr(DI_EI_CTRL2, 0x050a0a5d);
+	DI_Wr(DI_EI_CTRL3, 0x80000013);
 	/* mtn setting */
-	Wr(DI_MTN_1_CTRL1, 0xa0202015);
+	DI_Wr(DI_MTN_1_CTRL1, 0xa0202015);
 	#if 0
 	/* no use from g9tv */
-	Wr(DI_MTN_CTRL, 0xe228c440);
-	Wr(DI_BLEND_CTRL1, 0xc4402840);
-	Wr(DI_BLEND_CTRL2, 0x430);
+	DI_Wr(DI_MTN_CTRL, 0xe228c440);
+	DI_Wr(DI_BLEND_CTRL1, 0xc4402840);
+	DI_Wr(DI_BLEND_CTRL2, 0x430);
 	#endif
 }
 #endif
-#ifdef MCDI_SUPPORT
+
 static void mc_di_param_init(void)
 {
-	Wr(MCDI_CHK_EDGE_GAIN_OFFST, 0x4f6124);
-	Wr(MCDI_LMV_RT, 0x7455);
-	Wr(MCDI_LMV_GAINTHD, 0x6014d409);
-	Wr(MCDI_REL_DET_LPF_MSK_22_30, 0x0a010001);
-	Wr(MCDI_REL_DET_LPF_MSK_31_34, 0x01010101);
+	DI_Wr(MCDI_CHK_EDGE_GAIN_OFFST, 0x4f6124);
+	DI_Wr(MCDI_LMV_RT, 0x7455);
+	DI_Wr(MCDI_LMV_GAINTHD, 0x6014d409);
+	DI_Wr(MCDI_REL_DET_LPF_MSK_22_30, 0x0a010001);
+	DI_Wr(MCDI_REL_DET_LPF_MSK_31_34, 0x01010101);
 }
-#endif
+
+static void init_field_mode(void)
+{
+	DI_Wr(DIPD_COMB_CTRL0, 0x02400210);
+	DI_Wr(DIPD_COMB_CTRL1, 0x88080808);
+	DI_Wr(DIPD_COMB_CTRL2, 0x41041008);
+	DI_Wr(DIPD_COMB_CTRL3, 0x00008053);
+	DI_Wr(DIPD_COMB_CTRL4, 0x20070002);
+	DI_Wr(DIPD_COMB_CTRL5, 0x04040804);
+}
+
 void di_hw_init(void)
 {
 #ifdef NEW_DI_V1
-	unsigned short fifo_size = 0xc0;
+	unsigned short fifo_size_vpp = 0xc0;
+	unsigned short fifo_size_di = 0xc0;
 #endif
 
 #ifdef NEW_DI_V1
 	/* enable old DI mode for m6tv */
-	Wr(DI_CLKG_CTRL, 0x1); /* di no clock gate */
+	if (is_meson_gxtvbb_cpu() || is_meson_gxl_cpu() || is_meson_gxm_cpu())
+		DI_Wr(DI_CLKG_CTRL, 0xffff0001);
+	else
+		DI_Wr(DI_CLKG_CTRL, 0x1); /* di no clock gate */
 
-	/* fifo size setting from 0x1be60 to 0x1bf20 */
-	Wr(VD1_IF0_LUMA_FIFO_SIZE,	fifo_size);
-	/* 1a63 is vd1_if0_luma_fifo_size */
-	Wr(VD2_IF0_LUMA_FIFO_SIZE,	fifo_size);
+	if (is_meson_txl_cpu()) {
+		/* vpp fifo max size on txl :128*3=384[0x180] */
+		/* di fifo max size on txl :96*3=288[0x120] */
+		fifo_size_vpp = 0x180;
+		fifo_size_di = 0x120;
+	}
+	DI_Wr(VD1_IF0_LUMA_FIFO_SIZE, fifo_size_vpp);
+	DI_Wr(VD2_IF0_LUMA_FIFO_SIZE, fifo_size_vpp);
 	/* 1a83 is vd2_if0_luma_fifo_size */
-	Wr(DI_INP_LUMA_FIFO_SIZE,	fifo_size);
+	DI_Wr(DI_INP_LUMA_FIFO_SIZE,	fifo_size_di);
 	/* 17d8 is DI_INP_luma_fifo_size */
-	Wr(DI_MEM_LUMA_FIFO_SIZE,	fifo_size);
+	DI_Wr(DI_MEM_LUMA_FIFO_SIZE,	fifo_size_di);
 	/* 17e5 is DI_MEM_luma_fifo_size */
-	Wr(DI_IF1_LUMA_FIFO_SIZE,	fifo_size);
+	DI_Wr(DI_IF1_LUMA_FIFO_SIZE,	fifo_size_di);
 	/* 17f2 is  DI_IF1_luma_fifo_size */
-	Wr(DI_CHAN2_LUMA_FIFO_SIZE, fifo_size);
+	DI_Wr(DI_CHAN2_LUMA_FIFO_SIZE, fifo_size_di);
 	/* 17b3 is DI_chan2_luma_fifo_size */
 #endif
-	Wr(DI_PRE_HOLD, (0 << 31) | (31 << 16) | 31);
+	DI_Wr(DI_PRE_HOLD, (1 << 31) | (31 << 16) | 31);
 
 #if 0
 	/* need not set DI_CLKG_CTRL, hardware default
 	value of this register is already 0 */
-	/* Wr_reg_bits(DI_CLKG_CTRL, 0x0, 0, 2);
+	/* DI_Wr_reg_bits(DI_CLKG_CTRL, 0x0, 0, 2);
 	// bit 0: 1, no clock; bit 1: 0, auto clock gate */
 #endif
 	/* nr default setting */
@@ -179,30 +233,49 @@ void di_hw_init(void)
 #if (defined NEW_DI_V2 && !defined NEW_DI_TV)
 	ma_di_init();
 #endif
-#ifdef MCDI_SUPPORT
-	mc_di_param_init();
-#endif
-	Wr(DI_CLKG_CTRL, 0x2); /* di clock gate all */
+
+	if (pulldown_enable)
+		init_field_mode();
+
+	if (mcpre_en)
+		mc_di_param_init();
+
+	DI_Wr(DI_CLKG_CTRL, 0x2); /* di clock gate all */
 }
 
 void di_hw_uninit(void)
 {
 }
 
+/* config di pre bit mode */
+static void pre_bit_mode_config(unsigned char inp,
+	unsigned char mem, unsigned char chan2, unsigned char nrwr)
+{
+	if (!cpu_after_eq(MESON_CPU_MAJOR_ID_GXTVBB))
+		return;
+
+	RDMA_WR_BITS(DI_INP_GEN_REG3, inp&0x3, 8, 2);
+	RDMA_WR_BITS(DI_MEM_GEN_REG3, mem&0x3, 8, 2);
+	RDMA_WR_BITS(DI_CHAN2_GEN_REG3, chan2&0x3, 8, 2);
+	RDMA_WR_BITS(DI_NRWR_Y, nrwr&0x1, 14, 1);
+	if (cpu_after_eq(MESON_CPU_MAJOR_ID_TXL) && ((nrwr&0x3) == 0x3))
+		RDMA_WR_BITS(DI_NRWR_CTRL, 0x3, 22, 2);
+}
+
 unsigned int nr2_en = 0x1;
 module_param(nr2_en, uint, 0644);
 MODULE_PARM_DESC(nr2_en, "\n nr2_en\n");
 
 void enable_di_pre_aml(
-	DI_MIF_t		   *di_inp_mif,
-	DI_MIF_t		   *di_mem_mif,
-	DI_MIF_t		   *di_chan2_mif,
-	DI_SIM_MIF_t    *di_nrwr_mif,
-	DI_SIM_MIF_t    *di_mtnwr_mif,
+	struct DI_MIF_s		   *di_inp_mif,
+	struct DI_MIF_s		   *di_mem_mif,
+	struct DI_MIF_s		   *di_chan2_mif,
+	struct DI_SIM_MIF_s    *di_nrwr_mif,
+	struct DI_SIM_MIF_s    *di_mtnwr_mif,
 #ifdef NEW_DI_V1
-	DI_SIM_MIF_t    *di_contp2rd_mif,
-	DI_SIM_MIF_t    *di_contprd_mif,
-	DI_SIM_MIF_t    *di_contwr_mif,
+	struct DI_SIM_MIF_s    *di_contp2rd_mif,
+	struct DI_SIM_MIF_s    *di_contprd_mif,
+	struct DI_SIM_MIF_s    *di_contwr_mif,
 #endif
 	int nr_en, int mtn_en, int pd32_check_en, int pd22_check_en,
 	int hist_check_en, int pre_field_num, int pre_vdin_link,
@@ -236,18 +309,21 @@ void enable_di_pre_aml(
 	if (nr_en) {
 		RDMA_WR(DI_NRWR_X, (di_nrwr_mif->start_x << 16)|
 			(di_nrwr_mif->end_x));
-		RDMA_WR(DI_NRWR_Y, (di_nrwr_mif->start_y << 16)|
-						3 << 30|/*nrwr_words_lim*/
-					(di_nrwr_mif->end_y));
+		RDMA_WR_BITS(DI_NRWR_Y, di_nrwr_mif->start_y, 16, 13);
+		RDMA_WR_BITS(DI_NRWR_Y, di_nrwr_mif->end_y, 0, 13);
+		RDMA_WR_BITS(DI_NRWR_Y, 3, 30, 2);
 		RDMA_WR(DI_NRWR_CTRL, di_nrwr_mif->canvas_num|
 			(urgent<<16)|
 			2<<26 |/*burst_lim 1->2 2->4*/
 			1<<30); /* urgent bit 16 */
-
 	}
 
+	pre_bit_mode_config(di_inp_mif->bit_mode,
+				di_mem_mif->bit_mode,
+				di_chan2_mif->bit_mode,
+				di_nrwr_mif->bit_mode);
 	/* motion wr mif. */
-	if (mtn_en)	{
+	if (mtn_en) {
 #ifdef NEW_DI_V1
 		RDMA_WR(DI_CONTWR_X, (di_contwr_mif->start_x << 16)|
 			(di_contwr_mif->end_x));
@@ -282,21 +358,21 @@ void enable_di_pre_aml(
 	nr_h = (di_nrwr_mif->end_y - di_nrwr_mif->start_y + 1);
 	RDMA_WR(NR2_FRM_SIZE, (nr_h<<16)|nr_w);
 	/*gate for nr*/
-	#ifdef NEW_DI_TV
-	RDMA_WR_BITS(NR2_SW_EN, nr2_en, 4, 1);
-	#else
-	/*only process sd,avoid affecting sharp*/
-	if ((nr_h<<1) >= 720 || nr_w >= 1280)
-		RDMA_WR_BITS(NR2_SW_EN, 0, 4, 1);
-	else
+	if (cpu_after_eq(MESON_CPU_MAJOR_ID_GXTVBB))
 		RDMA_WR_BITS(NR2_SW_EN, nr2_en, 4, 1);
-	#endif
+	else {
+		/*only process sd,avoid affecting sharp*/
+		if ((nr_h<<1) >= 720 || nr_w >= 1280)
+			RDMA_WR_BITS(NR2_SW_EN, 0, 4, 1);
+		else
+			RDMA_WR_BITS(NR2_SW_EN, nr2_en, 4, 1);
+	}
 	/*enable noise meter*/
 	RDMA_WR_BITS(NR2_SW_EN, 1, 17, 1);
 #endif
-	/* reset pre */
-	RDMA_WR(DI_PRE_CTRL, Rd(DI_PRE_CTRL) | 1 << 31);
-	/* frame reset for the pre modules. */
+
+	/* frame + soft reset for the pre modules. */
+	RDMA_WR(DI_PRE_CTRL, Rd(DI_PRE_CTRL) | 3 << 30);
 
 	RDMA_WR(DI_PRE_CTRL, nr_en |			/* NR enable */
 					(mtn_en << 1) |	/* MTN_EN */
@@ -332,7 +408,7 @@ void enable_di_pre_aml(
 		det3d_cfg = 1;
 	} else if ((!det3d_en) && det3d_cfg) {
 		det3d_enable(0);
-	det3d_cfg = 0;
+		det3d_cfg = 0;
 	}
 #endif
 }
@@ -389,20 +465,23 @@ void enable_afbc_input(struct vframe_s *vf)
 		/* disable inp memory */
 		RDMA_WR_BITS(DI_INP_GEN_REG, 0, 0, 1);
 		/* afbc to di enable */
-		RDMA_WR_BITS(VIU_MISC_CTRL0, 1, 19, 1);
+		if (Rd_reg_bits(VIU_MISC_CTRL0, 19, 1) != 1)
+			RDMA_WR_BITS(VIU_MISC_CTRL0, 1, 19, 1);
 		/* DI inp(current data) switch to AFBC */
 		RDMA_WR_BITS(VIUB_MISC_CTRL0, 1, 16, 1);
 	} else {
 		RDMA_WR(AFBC_ENABLE, 0);
 		/* afbc to vpp(replace vd1) enable */
-		RDMA_WR_BITS(VIU_MISC_CTRL0, 0, 19, 1);
+		if (Rd_reg_bits(VIU_MISC_CTRL0, 19, 1) != 0)
+			RDMA_WR_BITS(VIU_MISC_CTRL0, 0, 19, 1);
 		/* DI inp(current data) switch to memory */
 		RDMA_WR_BITS(VIUB_MISC_CTRL0, 0, 16, 1);
 	}
 }
-#ifdef MCDI_SUPPORT
-void enable_mc_di_pre(DI_MC_MIF_t *di_mcinford_mif,
-DI_MC_MIF_t *di_mcinfowr_mif, DI_MC_MIF_t *di_mcvecwr_mif, int urgent)
+
+void enable_mc_di_pre(struct DI_MC_MIF_s *di_mcinford_mif,
+	struct DI_MC_MIF_s *di_mcinfowr_mif,
+	struct DI_MC_MIF_s *di_mcvecwr_mif, int urgent)
 {
 	RDMA_WR(MCDI_MCVECWR_X, di_mcvecwr_mif->size_x);
 	RDMA_WR(MCDI_MCVECWR_Y, di_mcvecwr_mif->size_y);
@@ -418,7 +497,7 @@ DI_MC_MIF_t *di_mcinfowr_mif, DI_MC_MIF_t *di_mcvecwr_mif, int urgent)
 	RDMA_WR(MCDI_MCINFORD_CANVAS_SIZE,
 		(di_mcinford_mif->size_x<<16)+di_mcinford_mif->size_y);
 
-	/* Wr(MCDI_MOTINEN,1<<1);	//enable motin refinement */
+	/* DI_Wr(MCDI_MOTINEN,1<<1);	//enable motin refinement */
 
 	RDMA_WR(MCDI_MCVECWR_CTRL, di_mcvecwr_mif->canvas_num |
 			(0<<14) |	 /* sync latch en */
@@ -437,30 +516,40 @@ DI_MC_MIF_t *di_mcinfowr_mif, DI_MC_MIF_t *di_mcvecwr_mif, int urgent)
 			(0x42<<16));
 }
 
-void enable_mc_di_post(DI_MC_MIF_t *di_mcvecrd_mif, int urgent, bool reverse)
+void enable_mc_di_post(struct DI_MC_MIF_s *di_mcvecrd_mif,
+	int urgent, bool reverse)
 {
-	VSYNC_WR_MPEG_REG(MCDI_MCVECRD_X, (reverse?1:0)<<30 |
+	DI_VSYNC_WR_MPEG_REG(MCDI_MCVECRD_X, (reverse?1:0)<<30 |
 			di_mcvecrd_mif->start_x<<16 |
 			(di_mcvecrd_mif->size_x+di_mcvecrd_mif->start_x));
-	VSYNC_WR_MPEG_REG(MCDI_MCVECRD_Y, (reverse?1:0)<<30 |
+	DI_VSYNC_WR_MPEG_REG(MCDI_MCVECRD_Y, (reverse?1:0)<<30 |
 						di_mcvecrd_mif->start_y<<16 |
 			(di_mcvecrd_mif->size_y+di_mcvecrd_mif->start_y));
-	VSYNC_WR_MPEG_REG(MCDI_MCVECRD_CANVAS_SIZE,
+	DI_VSYNC_WR_MPEG_REG(MCDI_MCVECRD_CANVAS_SIZE,
 			(di_mcvecrd_mif->size_x<<16)+di_mcvecrd_mif->size_y);
-	VSYNC_WR_MPEG_REG(MCDI_MCVECRD_CTRL, di_mcvecrd_mif->canvas_num |
+	DI_VSYNC_WR_MPEG_REG(MCDI_MCVECRD_CTRL, di_mcvecrd_mif->canvas_num |
 						(urgent<<8)|/* urgent */
 						(1<<9)|/* canvas enable */
 						(0 << 10) |
 						(0x31<<16));
+	DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, di_mcvecrd_mif->vecrd_offset,
+		12, 3);
+
 	if (di_mcvecrd_mif->blend_mode == 3)
-		VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, mcen_mode, 0, 2);
+		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, mcen_mode, 0, 2);
 	else
-		VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 0, 0, 2);
+		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 0, 0, 2);
+	if (is_meson_txl_cpu()) {
+		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, mcuv_en, 10, 1);
+		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 1, 11, 3);
+	} else
+		DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, mcuv_en, 9, 1);
+	DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, mcdebug_mode, 2, 3);
 }
 
-#endif
 
-static void set_di_inp_fmt_more(int hfmt_en,
+
+static void set_di_inp_fmt_more(unsigned int repeat_l0_en,
 				int hz_yc_ratio,		/* 2bit */
 				int hz_ini_phase,		/* 4bit */
 				int vfmt_en,
@@ -471,7 +560,7 @@ static void set_di_inp_fmt_more(int hfmt_en,
 				int hz_rpt	/* 1bit */
 		)
 {
-	int repeat_l0_en = 1, nrpt_phase0_en = 0;
+	int hfmt_en = 1, nrpt_phase0_en = 0;
 	int vt_phase_step = (16 >> vt_yc_ratio);
 
 	RDMA_WR(DI_INP_FMT_CTRL, (hz_rpt << 28)	|/* hz rpt pixel */
@@ -492,11 +581,11 @@ static void set_di_inp_fmt_more(int hfmt_en,
 					);
 }
 
-static void set_di_inp_mif(DI_MIF_t *mif, int urgent, int hold_line)
+static void set_di_inp_mif(struct DI_MIF_s *mif, int urgent, int hold_line)
 {
 	unsigned int bytes_per_pixel;
 	unsigned int demux_mode;
-	unsigned int chro_rpt_lastl_ctrl;
+	unsigned int chro_rpt_lastl_ctrl, vfmt_rpt_first = 0;
 	unsigned int luma0_rpt_loop_start;
 	unsigned int luma0_rpt_loop_end;
 	unsigned int luma0_rpt_loop_pat;
@@ -509,15 +598,17 @@ static void set_di_inp_mif(DI_MIF_t *mif, int urgent, int hold_line)
 		chro_rpt_lastl_ctrl = 1;
 		luma0_rpt_loop_start = 1;
 		luma0_rpt_loop_end = 1;
-		chroma0_rpt_loop_start = 1;
-		chroma0_rpt_loop_end = 1;
+		chroma0_rpt_loop_start = mif->src_prog?0:1;
+		chroma0_rpt_loop_end = mif->src_prog?0:1;
 		luma0_rpt_loop_pat = 0x80;
-		chroma0_rpt_loop_pat = 0x80;
+		chroma0_rpt_loop_pat = mif->src_prog?0:0x80;
 
-		if (mif->output_field_num == 0)
-			vt_ini_phase = 0xe;
-		else
-			vt_ini_phase = 0xa;
+		if (mif->output_field_num == 0) {
+			vt_ini_phase = 0xc;
+			vfmt_rpt_first = 1;
+		} else {
+			vt_ini_phase = 0x4;
+		}
 	} else if (mif->set_separate_en != 0 && mif->src_field_mode == 0) {
 		chro_rpt_lastl_ctrl = 1;
 		luma0_rpt_loop_start = 0;
@@ -566,7 +657,7 @@ static void set_di_inp_mif(DI_MIF_t *mif, int urgent, int hold_line)
 				(3 << 8)	|/*burst_size_y*/
 				(chro_rpt_lastl_ctrl << 6)	|
 				((mif->set_separate_en != 0) << 1) |
-				(1 << 0)/* cntl_enable */
+				(0 << 0)/* cntl_enable */
 	  );
 	if (mif->set_separate_en == 2) {
 		/* Enable NV12 Display */
@@ -621,11 +712,11 @@ static void set_di_inp_mif(DI_MIF_t *mif, int urgent, int hold_line)
 	RDMA_WR(DI_INP_DUMMY_PIXEL, 0x00808000);
 	if ((mif->set_separate_en != 0)) {/* 4:2:0 block mode.*/
 		set_di_inp_fmt_more(
-						1,/* hfmt_en */
+						vfmt_rpt_first,/* hfmt_en */
 						1,/* hz_yc_ratio */
 						0,/* hz_ini_phase */
 						1,/* vfmt_en */
-						1,/* vt_yc_ratio */
+		mif->src_prog?0:1,/* vt_yc_ratio */
 						vt_ini_phase,/* vt_ini_phase */
 		mif->luma_x_end0 - mif->luma_x_start0 + 1,
 						/* y_length */
@@ -634,7 +725,7 @@ static void set_di_inp_mif(DI_MIF_t *mif, int urgent, int hold_line)
 						0);	/* hz repeat. */
 	} else {
 		set_di_inp_fmt_more(
-						1,	/* hfmt_en */
+						vfmt_rpt_first,	/* hfmt_en */
 						1,	/* hz_yc_ratio */
 						0,	/* hz_ini_phase */
 						0,	/* vfmt_en */
@@ -711,7 +802,7 @@ static void set_di_chan2_fmt_more(int hfmt_en,
 }
 #endif
 
-static void set_di_mem_mif(DI_MIF_t *mif, int urgent, int hold_line)
+static void set_di_mem_mif(struct DI_MIF_s *mif, int urgent, int hold_line)
 {
 	unsigned int bytes_per_pixel;
 	unsigned int demux_mode;
@@ -779,9 +870,14 @@ static void set_di_mem_mif(DI_MIF_t *mif, int urgent, int hold_line)
 				(3 << 8)	|/*burst_size_y*/
 				(chro_rpt_lastl_ctrl << 6)	|
 				((mif->set_separate_en != 0) << 1)|
-				(1 << 0)	/* cntl_enable */
+				(0 << 0)	/* cntl_enable */
 	  );
-
+	if (mif->set_separate_en == 2) {
+		/* Enable NV12 Display */
+		RDMA_WR_BITS(DI_MEM_GEN_REG2, 1, 0, 1);
+	} else {
+		RDMA_WR_BITS(DI_MEM_GEN_REG2, 0, 0, 1);
+	}
 	/* ---------------------- */
 	/* Canvas */
 	/* ---------------------- */
@@ -849,6 +945,39 @@ static void set_di_mem_mif(DI_MIF_t *mif, int urgent, int hold_line)
 	}
 }
 
+static void set_di_if0_fmt_more(int hfmt_en,
+				int hz_yc_ratio,		/* 2bit */
+				int hz_ini_phase,		/* 4bit */
+				int vfmt_en,
+				int vt_yc_ratio,		/* 2bit */
+				int vt_ini_phase,		/* 4bit */
+				int y_length,
+				int c_length,
+				int hz_rpt		        /* 1bit */
+				)
+{
+	int vt_phase_step = (16 >> vt_yc_ratio);
+
+	DI_VSYNC_WR_MPEG_REG(VIU_VD1_FMT_CTRL,
+(hz_rpt << 28)	|		    /* hz rpt pixel */
+(hz_ini_phase << 24)	|		    /* hz ini phase */
+(0 << 23)		|		    /* repeat p0 enable */
+(hz_yc_ratio << 21)	|		    /* hz yc ratio */
+(hfmt_en << 20)	|		    /* hz enable */
+(1 << 17)		|		    /* nrpt_phase0 enable */
+(0 << 16)		|		    /* repeat l0 enable */
+(0 << 12)		|		    /* skip line num */
+(vt_ini_phase << 8)	|		    /* vt ini phase */
+(vt_phase_step << 1)	|		    /* vt phase step (3.4) */
+(vfmt_en << 0)		            /* vt enable */
+					);
+
+	DI_VSYNC_WR_MPEG_REG(VIU_VD1_FMT_W,
+		(y_length << 16) |		/* hz format width */
+		(c_length << 0)			/* vt format width */
+					);
+}
+
 static void set_di_if1_fmt_more(int hfmt_en,
 				int hz_yc_ratio,/* 2bit */
 				int hz_ini_phase,/* 4bit */
@@ -862,7 +991,7 @@ static void set_di_if1_fmt_more(int hfmt_en,
 {
 	int vt_phase_step = (16 >> vt_yc_ratio);
 
-	VSYNC_WR_MPEG_REG(DI_IF1_FMT_CTRL,
+	DI_VSYNC_WR_MPEG_REG(DI_IF1_FMT_CTRL,
 	(hz_rpt << 28)|/* hz rpt pixel */
 	(hz_ini_phase << 24)|/* hz ini phase */
 	(0 << 23)|/* repeat p0 enable */
@@ -876,14 +1005,43 @@ static void set_di_if1_fmt_more(int hfmt_en,
 	(vfmt_en << 0) /* vt enable */
 					);
 
-	VSYNC_WR_MPEG_REG(DI_IF1_FMT_W, (y_length << 16) |
+	DI_VSYNC_WR_MPEG_REG(DI_IF1_FMT_W, (y_length << 16) |
+							 (c_length << 0));
+}
+static void set_di_if2_fmt_more(int hfmt_en,
+				int hz_yc_ratio,/* 2bit */
+				int hz_ini_phase,/* 4bit */
+				int vfmt_en,
+				int vt_yc_ratio,/* 2bit */
+				int vt_ini_phase,/* 4bit */
+				int y_length,
+				int c_length,
+				int hz_rpt	/* 1bit */
+				)
+{
+	int vt_phase_step = (16 >> vt_yc_ratio);
+
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_FMT_CTRL,
+	(hz_rpt << 28)|/* hz rpt pixel */
+	(hz_ini_phase << 24)|/* hz ini phase */
+	(0 << 23)|/* repeat p0 enable */
+	(hz_yc_ratio << 21)|/* hz yc ratio */
+	(hfmt_en << 20)|/* hz enable */
+	(1 << 17)|/* nrpt_phase0 enable */
+	(0 << 16)|/* repeat l0 enable */
+	(0 << 12)|/* skip line num */
+	(vt_ini_phase << 8)|/* vt ini phase */
+	(vt_phase_step << 1)|/* vt phase step (3.4) */
+	(vfmt_en << 0) /* vt enable */
+					);
+
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_FMT_W, (y_length << 16) |
 							 (c_length << 0));
 }
 
-extern int di_vscale_skip_count_real;
 static const u32 vpat[] = {0, 0x8, 0x9, 0xa, 0xb, 0xc, 0xd, 0xe, 0xf};
 
-static void set_di_if1_mif(DI_MIF_t *mif, int urgent, int hold_line)
+static void set_di_if2_mif(struct DI_MIF_s *mif, int urgent, int hold_line)
 {
 	unsigned int bytes_per_pixel, demux_mode;
 	unsigned int pat, loop = 0, chro_rpt_lastl_ctrl = 0;
@@ -909,7 +1067,7 @@ static void set_di_if1_mif(DI_MIF_t *mif, int urgent, int hold_line)
 	/* General register */
 	/* ---------------------- */
 
-	VSYNC_WR_MPEG_REG(DI_IF1_GEN_REG, (0 << 29) | /* reset on go field */
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_GEN_REG, (0 << 29) | /* reset on go field */
 			(urgent << 28)	|/* urgent */
 			(urgent << 27)	|/* luma urgent */
 			(1 << 25)|/* no dummy data. */
@@ -924,39 +1082,142 @@ static void set_di_if1_mif(DI_MIF_t *mif, int urgent, int hold_line)
 			((mif->set_separate_en != 0) << 1)|
 			(1 << 0)/* cntl_enable */
 		);
+	/* post bit mode config, if0 config in video.c
+	DI_VSYNC_WR_MPEG_REG_BITS(DI_IF2_GEN_REG3, mif->bit_mode, 8, 2);
+	*/
+	/* ---------------------- */
+	/* Canvas */
+	/* ---------------------- */
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_CANVAS0, (mif->canvas0_addr2 << 16) |
+		(mif->canvas0_addr1 << 8) | (mif->canvas0_addr0 << 0));
+
+	/* ---------------------- */
+	/* Picture 0 X/Y start,end */
+	/* ---------------------- */
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_LUMA_X0, (mif->luma_x_end0 << 16) |
+		(mif->luma_x_start0 << 0));
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_LUMA_Y0, (mif->luma_y_end0 << 16) |
+		(mif->luma_y_start0 << 0));
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_CHROMA_X0, (mif->chroma_x_end0 << 16) |
+		(mif->chroma_x_start0 << 0));
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_CHROMA_Y0, (mif->chroma_y_end0 << 16) |
+		(mif->chroma_y_start0 << 0));
+
+	/* ---------------------- */
+	/* Repeat or skip */
+	/* ---------------------- */
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_RPT_LOOP, (loop << 24) |
+							   (loop << 16) |
+							   (loop << 8) |
+							   (loop << 0)
+					 );
+
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_LUMA0_RPT_PAT, pat);
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_CHROMA0_RPT_PAT, pat);
+
+	/* Dummy pixel value */
+	DI_VSYNC_WR_MPEG_REG(DI_IF2_DUMMY_PIXEL, 0x00808000);
+	if (mif->set_separate_en != 0) { /* 4:2:0 block mode. */
+		set_di_if2_fmt_more(1, /* hfmt_en */
+		1,/* hz_yc_ratio */
+		0,/* hz_ini_phase */
+		1,	/* vfmt_en */
+		1, /* vt_yc_ratio */
+		0, /* vt_ini_phase */
+		mif->luma_x_end0 - mif->luma_x_start0 + 1,
+		mif->chroma_x_end0 - mif->chroma_x_start0 + 1,
+							 0); /* hz repeat. */
+	} else {
+		set_di_if2_fmt_more(1,	/* hfmt_en */
+		1, /* hz_yc_ratio */
+		0, /* hz_ini_phase */
+		0,	/* vfmt_en */
+		0,	/* vt_yc_ratio */
+		0, /* vt_ini_phase */
+			mif->luma_x_end0 - mif->luma_x_start0 + 1,
+			((mif->luma_x_end0 >> 1) - (mif->luma_x_start0>>1) + 1),
+							 0); /* hz repeat */
+	}
+}
+
+static void set_di_if1_mif(struct DI_MIF_s *mif, int urgent, int hold_line)
+{
+	unsigned int bytes_per_pixel, demux_mode;
+	unsigned int pat, loop = 0, chro_rpt_lastl_ctrl = 0;
+
+	if (mif->set_separate_en == 1) {
+		pat = vpat[(di_vscale_skip_count_real<<1)+1];
+		/*top*/
+		if (mif->src_field_mode == 0) {
+			chro_rpt_lastl_ctrl = 1;
+			loop = 0x11;
+			pat <<= 4;
+		}
+	} else {
+		loop = 0;
+		pat = vpat[di_vscale_skip_count_real];
+	}
+
+	bytes_per_pixel = mif->set_separate_en ? 0 : (mif->video_mode ? 2 : 1);
+	demux_mode = mif->video_mode;
+
+
+	/* ---------------------- */
+	/* General register */
+	/* ---------------------- */
 
+	DI_VSYNC_WR_MPEG_REG(DI_IF1_GEN_REG, (0 << 29) | /* reset on go field */
+			(urgent << 28)	|/* urgent */
+			(urgent << 27)	|/* luma urgent */
+			(1 << 25)|/* no dummy data. */
+			(hold_line << 19)|/* hold lines */
+			(1 << 18)|/* push dummy pixel */
+			(demux_mode << 16)|/* demux_mode */
+			(bytes_per_pixel << 14)|
+			(1 << 12)|/*burst_size_cr*/
+			(1 << 10)|/*burst_size_cb*/
+			(3 << 8)|/*burst_size_y*/
+			(chro_rpt_lastl_ctrl << 6)|
+			((mif->set_separate_en != 0) << 1)|
+			(1 << 0)/* cntl_enable */
+		);
+	#if 0
+	/* post bit mode config, if0 config in video.c */
+	if (is_meson_gxtvbb_cpu() || is_meson_gxl_cpu() || is_meson_gxm_cpu())
+		DI_VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG3, mif->bit_mode, 8, 2);
+	#endif
 	/* ---------------------- */
 	/* Canvas */
 	/* ---------------------- */
-	VSYNC_WR_MPEG_REG(DI_IF1_CANVAS0, (mif->canvas0_addr2 << 16) |
+	DI_VSYNC_WR_MPEG_REG(DI_IF1_CANVAS0, (mif->canvas0_addr2 << 16) |
 (mif->canvas0_addr1 << 8) | (mif->canvas0_addr0 << 0));
 
 	/* ---------------------- */
 	/* Picture 0 X/Y start,end */
 	/* ---------------------- */
-	VSYNC_WR_MPEG_REG(DI_IF1_LUMA_X0, (mif->luma_x_end0 << 16) |
+	DI_VSYNC_WR_MPEG_REG(DI_IF1_LUMA_X0, (mif->luma_x_end0 << 16) |
 (mif->luma_x_start0 << 0));
-	VSYNC_WR_MPEG_REG(DI_IF1_LUMA_Y0, (mif->luma_y_end0 << 16) |
+	DI_VSYNC_WR_MPEG_REG(DI_IF1_LUMA_Y0, (mif->luma_y_end0 << 16) |
 (mif->luma_y_start0 << 0));
-	VSYNC_WR_MPEG_REG(DI_IF1_CHROMA_X0, (mif->chroma_x_end0 << 16) |
+	DI_VSYNC_WR_MPEG_REG(DI_IF1_CHROMA_X0, (mif->chroma_x_end0 << 16) |
 (mif->chroma_x_start0 << 0));
-	VSYNC_WR_MPEG_REG(DI_IF1_CHROMA_Y0, (mif->chroma_y_end0 << 16) |
+	DI_VSYNC_WR_MPEG_REG(DI_IF1_CHROMA_Y0, (mif->chroma_y_end0 << 16) |
 (mif->chroma_y_start0 << 0));
 
 	/* ---------------------- */
 	/* Repeat or skip */
 	/* ---------------------- */
-	VSYNC_WR_MPEG_REG(DI_IF1_RPT_LOOP, (loop << 24) |
+	DI_VSYNC_WR_MPEG_REG(DI_IF1_RPT_LOOP, (loop << 24) |
 							   (loop << 16) |
 							   (loop << 8) |
 							   (loop << 0)
 					 );
 
-	VSYNC_WR_MPEG_REG(DI_IF1_LUMA0_RPT_PAT, pat);
-	VSYNC_WR_MPEG_REG(DI_IF1_CHROMA0_RPT_PAT, pat);
+	DI_VSYNC_WR_MPEG_REG(DI_IF1_LUMA0_RPT_PAT, pat);
+	DI_VSYNC_WR_MPEG_REG(DI_IF1_CHROMA0_RPT_PAT, pat);
 
 	/* Dummy pixel value */
-	VSYNC_WR_MPEG_REG(DI_IF1_DUMMY_PIXEL, 0x00808000);
+	DI_VSYNC_WR_MPEG_REG(DI_IF1_DUMMY_PIXEL, 0x00808000);
 	if (mif->set_separate_en != 0) { /* 4:2:0 block mode. */
 		set_di_if1_fmt_more(1, /* hfmt_en */
 		1,/* hz_yc_ratio */
@@ -980,7 +1241,7 @@ static void set_di_if1_mif(DI_MIF_t *mif, int urgent, int hold_line)
 	}
 }
 
-static void set_di_chan2_mif(DI_MIF_t *mif, int urgent, int hold_line)
+static void set_di_chan2_mif(struct DI_MIF_s *mif, int urgent, int hold_line)
 {
 	unsigned int bytes_per_pixel;
 	unsigned int demux_mode;
@@ -1018,12 +1279,16 @@ static void set_di_chan2_mif(DI_MIF_t *mif, int urgent, int hold_line)
 				(1 << 10)	|/*burst_size_cb*/
 				(3 << 8) |/*burst_size_y*/
 ((hold_line == 0 ? 1 : 0) << 7) |
-(0 << 6)|(0 << 1)|(1 << 0));
-
-
+(0 << 6)|(0 << 1)|(0 << 0));
 	/* ---------------------- */
 	/* Canvas */
 	/* ---------------------- */
+	if (mif->set_separate_en == 2) {
+		/* Enable NV12 Display */
+		RDMA_WR_BITS(DI_CHAN2_GEN_REG2, 1, 0, 1);
+	} else {
+		RDMA_WR_BITS(DI_CHAN2_GEN_REG2, 0, 0, 1);
+	}
 	RDMA_WR(DI_CHAN2_CANVAS, (0 << 16) | /* cntl_canvas0_addr2 */
 (0 << 8)|(mif->canvas0_addr0 << 0));
 
@@ -1083,9 +1348,10 @@ static void set_di_chan2_mif(DI_MIF_t *mif, int urgent, int hold_line)
 
 }
 
-static void set_di_if0_mif(DI_MIF_t *mif, int urgent, int hold_line)
+static void set_di_if0_mif(struct DI_MIF_s *mif, int urgent, int hold_line)
 {
 	unsigned int pat, loop = 0;
+	unsigned bytes_per_pixel, demux_mode;
 
 	if (mif->set_separate_en == 1) {
 		pat = vpat[(di_vscale_skip_count_real<<1)+1];
@@ -1096,41 +1362,90 @@ static void set_di_if0_mif(DI_MIF_t *mif, int urgent, int hold_line)
 	} else {
 		loop = 0;
 	pat = vpat[di_vscale_skip_count_real];
+
+	if ((post_wr_en && post_wr_surpport)) {
+		bytes_per_pixel =
+			mif->set_separate_en ? 0 : (mif->video_mode ? 2 : 1);
+		demux_mode = mif->video_mode;
+		DI_VSYNC_WR_MPEG_REG(VD1_IF0_GEN_REG,
+(0 << 29) | /* reset on go field */
+(urgent << 28)		|	/* urgent */
+(urgent << 27)		|	/* luma urgent */
+(1 << 25)		|	/* no dummy data. */
+(hold_line << 19)	|	/* hold lines */
+(1 << 18)		|	/* push dummy pixel */
+(demux_mode << 16)	|	/* demux_mode */
+(bytes_per_pixel << 14)	|
+(1 << 12)	|
+(1 << 10)	|
+(3 << 8)	|
+(0 << 6)	|
+((mif->set_separate_en != 0) << 1)	|
+(1 << 0)			/* cntl_enable */
+		);
+	}
 	/* ---------------------- */
 	/* Canvas */
 	/* ---------------------- */
-	VSYNC_WR_MPEG_REG(VD1_IF0_CANVAS0, (mif->canvas0_addr2 << 16)|
+	DI_VSYNC_WR_MPEG_REG(VD1_IF0_CANVAS0, (mif->canvas0_addr2 << 16)|
 (mif->canvas0_addr1 << 8)|(mif->canvas0_addr0 << 0));
 
 	/* ---------------------- */
 	/* Picture 0 X/Y start,end */
 	/* ---------------------- */
-	VSYNC_WR_MPEG_REG(VD1_IF0_LUMA_X0, (mif->luma_x_end0 << 16) |
+	DI_VSYNC_WR_MPEG_REG(VD1_IF0_LUMA_X0, (mif->luma_x_end0 << 16) |
 (mif->luma_x_start0 << 0));
-	VSYNC_WR_MPEG_REG(VD1_IF0_LUMA_Y0, (mif->luma_y_end0 << 16) |
+	DI_VSYNC_WR_MPEG_REG(VD1_IF0_LUMA_Y0, (mif->luma_y_end0 << 16) |
 (mif->luma_y_start0 << 0));
-	VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA_X0, (mif->chroma_x_end0 << 16) |
+	DI_VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA_X0, (mif->chroma_x_end0 << 16) |
 (mif->chroma_x_start0 << 0));
-	VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA_Y0, (mif->chroma_y_end0 << 16) |
+	DI_VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA_Y0, (mif->chroma_y_end0 << 16) |
 (mif->chroma_y_start0 << 0));
 
 	}
 	/* ---------------------- */
 	/* Repeat or skip */
 	/* ---------------------- */
-	VSYNC_WR_MPEG_REG(VD1_IF0_RPT_LOOP,
+	DI_VSYNC_WR_MPEG_REG(VD1_IF0_RPT_LOOP,
 				   (loop << 24) |
 				   (loop << 16)   |
 				   (loop << 8) |
 				   (loop << 0));
-	VSYNC_WR_MPEG_REG(VD1_IF0_LUMA0_RPT_PAT,   pat);
-	VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA0_RPT_PAT, pat);
+	DI_VSYNC_WR_MPEG_REG(VD1_IF0_LUMA0_RPT_PAT,   pat);
+	DI_VSYNC_WR_MPEG_REG(VD1_IF0_CHROMA0_RPT_PAT, pat);
+
+	if ((post_wr_en && post_wr_surpport)) {
+		/* 4:2:0 block mode. */
+		if (mif->set_separate_en != 0) {
+			set_di_if0_fmt_more(
+			1, /* hfmt_en */
+			1,	/* hz_yc_ratio */
+			0,	/* hz_ini_phase */
+			1,	/* vfmt_en */
+			1, /* vt_yc_ratio */
+			0, /* vt_ini_phase */
+mif->luma_x_end0 - mif->luma_x_start0 + 1, /* y_length */
+mif->chroma_x_end0 - mif->chroma_x_start0 + 1, /* c length */
+			0); /* hz repeat. */
+		} else {
+			set_di_if0_fmt_more(
+	1,	/* hfmt_en */
+	1,	/* hz_yc_ratio */
+	0,  /* hz_ini_phase */
+	0,	/* vfmt_en */
+	0,	/* vt_yc_ratio */
+	0,  /* vt_ini_phase */
+	mif->luma_x_end0 - mif->luma_x_start0 + 1, /* y_length */
+	((mif->luma_x_end0>>1) - (mif->luma_x_start0>>1) + 1), /* c length */
+	0); /* hz repeat */
+		}
+	}
 }
 
 void initial_di_pre_aml(int hsize_pre, int vsize_pre, int hold_line)
 {
-	Wr(DI_PRE_SIZE, (hsize_pre - 1) | ((vsize_pre - 1) << 16));
-	Wr(DI_PRE_CTRL, 0 |	/* NR enable */
+	DI_Wr(DI_PRE_SIZE, (hsize_pre - 1) | ((vsize_pre - 1) << 16));
+	DI_Wr(DI_PRE_CTRL, 0 |	/* NR enable */
 (0 << 1) |	/* MTN_EN */
 (1 << 2) |	/* check 3:2 pulldown */
 (0 << 3) |	/* check 2:2 pulldown */
@@ -1149,23 +1464,47 @@ void initial_di_pre_aml(int hsize_pre, int vsize_pre, int hold_line)
 			);
 #ifdef SUPPORT_MPEG_TO_VDIN
 	if (mpeg2vdin_flag)
-		Wr_reg_bits(DI_PRE_CTRL, 1, 13, 1);
+		DI_Wr_reg_bits(DI_PRE_CTRL, 1, 13, 1);
 #endif
-	Wr(DI_MC_22LVL0, (Rd(DI_MC_22LVL0) & 0xffff0000) | 256);
-	Wr(DI_MC_32LVL0, (Rd(DI_MC_32LVL0) & 0xffffff00) | 16);
+	DI_Wr(DI_MC_22LVL0, (Rd(DI_MC_22LVL0) & 0xffff0000) | 256);
+	DI_Wr(DI_MC_32LVL0, (Rd(DI_MC_32LVL0) & 0xffffff00) | 16);
 }
 
 void initial_di_post_2(int hsize_post, int vsize_post, int hold_line)
 {
-	VSYNC_WR_MPEG_REG(DI_POST_SIZE,
+	DI_VSYNC_WR_MPEG_REG(DI_POST_SIZE,
 (hsize_post - 1) | ((vsize_post - 1) << 16));
+
+#if 0
 	/* di demo */
-	VSYNC_WR_MPEG_REG(DI_BLEND_REG0_X, ((hsize_post-1)>>1));
-	VSYNC_WR_MPEG_REG(DI_BLEND_REG0_Y, (vsize_post-1));
-	VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, Rd(DI_BLEND_CTRL)|
+	DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG0_X, ((hsize_post-1)>>1));
+	DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG0_Y, (vsize_post-1));
+	DI_VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, Rd(DI_BLEND_CTRL)|
 (0x2 << 20) |	/* top mode. EI only */
 25); /* KDEINT */
-	VSYNC_WR_MPEG_REG(DI_POST_CTRL, (0 << 0) |
+#endif
+	/* if post size < MIN_POST_WIDTH, force old ei */
+	if (hsize_post < MIN_POST_WIDTH)
+		DI_VSYNC_WR_MPEG_REG_BITS(DI_EI_CTRL3, 0, 31, 1);
+	else
+		DI_VSYNC_WR_MPEG_REG_BITS(DI_EI_CTRL3, 1, 31, 1);
+
+	if (pulldown_enable) {
+		/* DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG0_Y, (vsize_post>>2)-1 ); */
+		DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG0_Y, (vsize_post-1));
+		DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG1_Y,
+			((vsize_post>>2)<<16) | (2*(vsize_post>>2)-1));
+		DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG2_Y,
+			((2*(vsize_post>>2))<<16) | (3*(vsize_post>>2)-1));
+		DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG3_Y,
+			((3*(vsize_post>>2))<<16) | (vsize_post-1));
+		DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG0_X, (hsize_post-1));
+		DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG1_X, (hsize_post-1));
+		DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG2_X, (hsize_post-1));
+		DI_VSYNC_WR_MPEG_REG(DI_BLEND_REG3_X, (hsize_post-1));
+	}
+
+	DI_VSYNC_WR_MPEG_REG(DI_POST_CTRL, (0 << 0) |
 					  (0 << 1)	|
 					  (0 << 2)	|
 					  (0 << 3)	|
@@ -1182,19 +1521,26 @@ void initial_di_post_2(int hsize_post, int vsize_post, int hold_line)
 					  (0 << 29) |
 					  (0x3 << 30)
 		);
-	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB)
+	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
 		/* enable ma,disable if0 to vpp */
-		VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0, 5, 16, 3);
+		if (Rd_reg_bits(VIU_MISC_CTRL0, 16, 3) != 5)
+			DI_VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0, 5, 16, 3);
+		if (post_wr_en)
+			DI_VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0, 1, 28, 1);
+	}
 }
 
+static unsigned int pldn_ctrl_rflsh = 1;
+module_param(pldn_ctrl_rflsh, uint, 0644);
+MODULE_PARM_DESC(pldn_ctrl_rflsh, "/n post blend reflesh./n");
+
 void di_post_switch_buffer(
-	DI_MIF_t		   *di_buf0_mif,
-	DI_MIF_t		   *di_buf1_mif,
-	DI_SIM_MIF_t    *di_diwr_mif,
-	DI_SIM_MIF_t    *di_mtnprd_mif,
-#ifdef MCDI_SUPPORT
-	DI_MC_MIF_t	   *di_mcvecrd_mif,
-#endif
+	struct DI_MIF_s		   *di_buf0_mif,
+	struct DI_MIF_s		   *di_buf1_mif,
+	struct DI_MIF_s		   *di_buf2_mif,
+	struct DI_SIM_MIF_s    *di_diwr_mif,
+	struct DI_SIM_MIF_s    *di_mtnprd_mif,
+	struct DI_MC_MIF_s	   *di_mcvecrd_mif,
 	int ei_en, int blend_en, int blend_mtn_en, int blend_mode,
 	int di_vpp_en, int di_ddr_en,
 	int post_field_num, int hold_line, int urgent
@@ -1209,62 +1555,99 @@ void di_post_switch_buffer(
 		set_di_if0_mif(di_buf0_mif, urgent, hold_line);
 
 	if (!ei_only && (di_ddr_en || di_vpp_en)) {
-		VSYNC_WR_MPEG_REG(DI_IF1_CANVAS0,
-(di_buf1_mif->canvas0_addr2 << 16) |
-(di_buf1_mif->canvas0_addr1 << 8) | (di_buf1_mif->canvas0_addr0 << 0));
+		DI_VSYNC_WR_MPEG_REG(DI_IF1_CANVAS0,
+			(di_buf1_mif->canvas0_addr2 << 16) |
+			(di_buf1_mif->canvas0_addr1 << 8) |
+			(di_buf1_mif->canvas0_addr0 << 0));
+		if (is_meson_txl_cpu())
+			DI_VSYNC_WR_MPEG_REG(DI_IF2_CANVAS0,
+				(di_buf2_mif->canvas0_addr2 << 16) |
+				(di_buf2_mif->canvas0_addr1 << 8) |
+				(di_buf2_mif->canvas0_addr0 << 0));
+	#if 0
+	/* post bit mode config, if0 config in video.c */
+		if (is_meson_gxtvbb_cpu() || is_meson_gxl_cpu() ||
+			is_meson_gxm_cpu())
+			DI_VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG3,
+						di_buf1_mif->bit_mode, 8, 2);
+		if (is_meson_txl_cpu())
+			DI_VSYNC_WR_MPEG_REG_BITS(DI_IF2_GEN_REG3,
+				di_buf2_mif->bit_mode, 8, 2);
+	#endif
 	}
 
 	/* motion for current display field. */
 	if (blend_mtn_en) {
-		VSYNC_WR_MPEG_REG(DI_MTNRD_CTRL,
+		DI_VSYNC_WR_MPEG_REG(DI_MTNRD_CTRL,
 (di_mtnprd_mif->canvas_num << 8) | (urgent << 16)
 	 ); /* current field mtn canvas index. */
 
 	}
 
 	if (di_ddr_en) {
-		VSYNC_WR_MPEG_REG(DI_DIWR_CTRL, di_diwr_mif->canvas_num |
-			(urgent << 16)); /* urgent. */
+		if ((post_wr_en && post_wr_surpport)) {
+			DI_VSYNC_WR_MPEG_REG(DI_DIWR_CTRL,
+				di_diwr_mif->canvas_num);
+			DI_VSYNC_WR_MPEG_REG_BITS(DI_DIWR_CTRL, urgent, 16, 1);
+			DI_VSYNC_WR_MPEG_REG_BITS(DI_DIWR_CTRL,
+				di_ddr_en, 30, 1);
+		} else {
+			DI_VSYNC_WR_MPEG_REG(DI_DIWR_CTRL,
+			di_diwr_mif->canvas_num | (urgent << 16)); /* urgent. */
+		}
 	}
-
-	VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, Rd(DI_BLEND_CTRL)|
+	if ((pldn_ctrl_rflsh == 1) && pulldown_enable) {
+		DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL, blend_en, 31, 1);
+		DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL, 7, 22, 3);
+		DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL, blend_mode, 20, 2);
+		if (debug_blend_mode_ctrl != 0xff)
+			DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL,
+				debug_blend_mode_ctrl&0x3, 20, 2);
+	} else
+		DI_VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, Rd(DI_BLEND_CTRL)|
 			(blend_en<<31) | (blend_mode<<20) | 0x1c0001f);
-#ifdef MCDI_SUPPORT
-	VSYNC_WR_MPEG_REG(MCDI_MCVECRD_CTRL,
-(Rd(MCDI_MCVECRD_CTRL) & 0xffffff00) |
-(1<<9) |	  /* canvas enable */
-di_mcvecrd_mif->canvas_num |  /* canvas index. */
-(urgent << 8));
-		if (di_mcvecrd_mif->blend_mode == 3)
-			VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, mcen_mode, 0, 2);
-		else
-			VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 0, 0, 2);
-#endif
-	VSYNC_WR_MPEG_REG(DI_POST_CTRL,
-((ei_en|blend_en) << 0) |	/* line buffer 0 enable */
-((blend_mode == 1?1:0) << 1)  |
-(ei_en << 2) |			/* ei  enable */
-(blend_mtn_en << 3) |	/* mtn line buffer enable */
-(blend_mtn_en  << 4) |/* mtnp read mif enable */
-(blend_en << 5) |
-(1 << 6) |		/* di mux output enable */
-(di_ddr_en << 7) |/* di write to SDRAM enable.*/
-(di_vpp_en << 8) |/* di to VPP enable. */
-(0 << 9) |		/* mif0 to VPP enable. */
-(0 << 10) |		/* post drop first. */
-(0 << 11) |
-(di_vpp_en << 12) | /* post viu link */
-(hold_line << 16) | /* post hold line number */
-(post_field_num << 29) |	/* post field number. */
-(0x1 << 30)	/* post soft rst  post frame rst. */
-		);
+
+	if (mcpre_en) {
+		DI_VSYNC_WR_MPEG_REG(MCDI_MCVECRD_CTRL,
+	(Rd(MCDI_MCVECRD_CTRL) & 0xffffff00) |
+	(1<<9) |	  /* canvas enable */
+	di_mcvecrd_mif->canvas_num |  /* canvas index. */
+	(urgent << 8));
+			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
+				di_mcvecrd_mif->vecrd_offset, 12, 3);
+			if (di_mcvecrd_mif->blend_mode == 3)
+				DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
+					mcen_mode, 0, 2);
+			else
+				DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
+					0, 0, 2);
+	}
+	DI_VSYNC_WR_MPEG_REG(DI_POST_CTRL,
+		((ei_en|blend_en) << 0) | /* line buf 0 enable */
+		((blend_mode == 1?1:0) << 1)  |
+		(ei_en << 2) |			/* ei  enable */
+		(blend_mtn_en << 3) |	/* mtn line buffer enable */
+		(blend_mtn_en  << 4) |/* mtnp read mif enable */
+		(blend_en << 5) |
+		(1 << 6) |		/* di mux output enable */
+		(di_ddr_en << 7) |/* di write to SDRAM enable.*/
+		(di_vpp_en << 8) |/* di to VPP enable. */
+		(0 << 9) |		/* mif0 to VPP enable. */
+		(0 << 10) |		/* post drop first. */
+		(0 << 11) |
+		(di_vpp_en << 12) | /* post viu link */
+		(hold_line << 16) | /* post hold line number */
+		(post_field_num << 29) |	/* post field number. */
+		(0x3 << 30)	/* post soft rst  post frame rst. */
+	);
 }
 
 void enable_di_post_2(
-	DI_MIF_t		   *di_buf0_mif,
-	DI_MIF_t		   *di_buf1_mif,
-	DI_SIM_MIF_t    *di_diwr_mif,
-	DI_SIM_MIF_t    *di_mtnprd_mif,
+	struct DI_MIF_s		   *di_buf0_mif,
+	struct DI_MIF_s		   *di_buf1_mif,
+	struct DI_MIF_s		   *di_buf2_mif,
+	struct DI_SIM_MIF_s    *di_diwr_mif,
+	struct DI_SIM_MIF_s    *di_mtnprd_mif,
 	int ei_en, int blend_en, int blend_mtn_en, int blend_mode,
 	int di_vpp_en, int di_ddr_en, int post_field_num,
 	int hold_line, int urgent
@@ -1279,37 +1662,56 @@ void enable_di_post_2(
 	if (ei_en || di_vpp_en || di_ddr_en)
 		set_di_if0_mif(di_buf0_mif, di_vpp_en, hold_line);
 
-	if (!ei_only && (di_ddr_en || di_vpp_en))
+	/* if (!ei_only && (di_ddr_en || di_vpp_en)) */
 		set_di_if1_mif(di_buf1_mif, di_vpp_en, hold_line);
+		if (is_meson_txl_cpu())
+			set_di_if2_mif(di_buf2_mif, di_vpp_en, hold_line);
 
 	/* printk("%s: ei_only %d,buf1_en %d,ei_en %d,di_vpp_en %d,
 di_ddr_en %d,blend_mtn_en %d,blend_mode %d.\n",
 __func__,ei_only,buf1_en,ei_en,di_vpp_en,di_ddr_en,
 blend_mtn_en,blend_mode); */
 	/* motion for current display field. */
-		VSYNC_WR_MPEG_REG(DI_MTNPRD_X,
+		DI_VSYNC_WR_MPEG_REG(DI_MTNPRD_X,
 (di_mtnprd_mif->start_x << 16) | (di_mtnprd_mif->end_x));
-		VSYNC_WR_MPEG_REG(DI_MTNPRD_Y,
+		DI_VSYNC_WR_MPEG_REG(DI_MTNPRD_Y,
 (di_mtnprd_mif->start_y << 16) | (di_mtnprd_mif->end_y));
 	if (blend_mtn_en) {
-		VSYNC_WR_MPEG_REG(DI_MTNRD_CTRL,
+		DI_VSYNC_WR_MPEG_REG(DI_MTNRD_CTRL,
 (di_mtnprd_mif->canvas_num << 8) | (urgent << 16)
 	 ); /* current field mtn canvas index */
 	}
 
 	if (di_ddr_en) {
-		VSYNC_WR_MPEG_REG(DI_DIWR_X,
+		if ((post_wr_en && post_wr_surpport)) {
+			DI_VSYNC_WR_MPEG_REG(DI_DIWR_X,
 (di_diwr_mif->start_x << 16) | (di_diwr_mif->end_x));
-	   VSYNC_WR_MPEG_REG(DI_DIWR_Y,
+			DI_VSYNC_WR_MPEG_REG(DI_DIWR_Y,
+(di_diwr_mif->start_y << 16) | (di_diwr_mif->end_y));
+			DI_VSYNC_WR_MPEG_REG(DI_DIWR_CTRL,
+			di_diwr_mif->canvas_num|
+			(urgent << 16) |
+			(di_ddr_en << 30));
+		} else {
+		DI_VSYNC_WR_MPEG_REG(DI_DIWR_X,
+(di_diwr_mif->start_x << 16) | (di_diwr_mif->end_x));
+	   DI_VSYNC_WR_MPEG_REG(DI_DIWR_Y,
 (di_diwr_mif->start_y << 16) | (di_diwr_mif->end_y * 2 + 1));
-	   VSYNC_WR_MPEG_REG(DI_DIWR_CTRL, di_diwr_mif->canvas_num|
+	   DI_VSYNC_WR_MPEG_REG(DI_DIWR_CTRL, di_diwr_mif->canvas_num|
 (urgent << 16));
-	}
+		}
+}
 
-		VSYNC_WR_MPEG_REG(DI_BLEND_CTRL, Rd(DI_BLEND_CTRL)|
-			(blend_en<<31) | (blend_mode<<20) | 0x1c0001f);
+	DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL, 7, 22, 3);
+	DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL,
+		blend_en&0x1, 31, 1);
+	DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL,
+		blend_mode&0x3, 20, 2);
+	if (debug_blend_mode_ctrl != 0xff)
+		DI_VSYNC_WR_MPEG_REG_BITS(DI_BLEND_CTRL,
+			debug_blend_mode_ctrl&0x3, 20, 2);
 
-	VSYNC_WR_MPEG_REG(DI_POST_CTRL,
+	DI_VSYNC_WR_MPEG_REG(DI_POST_CTRL,
 ((ei_en | blend_en) << 0) |	/* line buffer 0 enable */
 ((blend_mode == 1?1:0) << 1)  |
 (ei_en << 2) | /* ei  enable */
@@ -1325,22 +1727,26 @@ blend_mtn_en,blend_mode); */
 (di_vpp_en << 12) |	/* post viu link */
 (hold_line << 16) |	/* post hold line number */
 (post_field_num << 29) |	/* post field number. */
-(0x1 << 30)	/* post soft rst  post frame rst. */
+(((post_wr_en && post_wr_surpport)?0x3:0x1) << 30)
+/* post soft rst  post frame rst. */
 		);
 }
 
 void disable_post_deinterlace_2(void)
 {
-	VSYNC_WR_MPEG_REG(DI_POST_CTRL, 0x3 << 30);
-	VSYNC_WR_MPEG_REG(DI_POST_SIZE, (32-1) | ((128-1) << 16));
-	VSYNC_WR_MPEG_REG(DI_IF1_GEN_REG, 0x3 << 30);
+	DI_VSYNC_WR_MPEG_REG(DI_POST_CTRL, 0x3 << 30);
+	DI_VSYNC_WR_MPEG_REG(DI_POST_SIZE, (32-1) | ((128-1) << 16));
+	DI_VSYNC_WR_MPEG_REG(DI_IF1_GEN_REG, 0x3 << 30);
+	if (is_meson_txl_cpu())
+		DI_VSYNC_WR_MPEG_REG(DI_IF2_GEN_REG, 0x3 << 30);
 	if (get_cpu_type() >= MESON_CPU_MAJOR_ID_GXBB) {
 		/* disable ma,enable if0 to vpp,enable afbc to vpp */
-		VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0, 0, 16, 4);
+		if (Rd_reg_bits(VIU_MISC_CTRL0, 16, 4) != 0)
+			DI_VSYNC_WR_MPEG_REG_BITS(VIU_MISC_CTRL0, 0, 16, 4);
 		/* DI inp(current data) switch to memory */
-		VSYNC_WR_MPEG_REG_BITS(VIUB_MISC_CTRL0, 0, 16, 1);
+		DI_VSYNC_WR_MPEG_REG_BITS(VIUB_MISC_CTRL0, 0, 16, 1);
 	}
-	/* VSYNC_WR_MPEG_REG(DI_IF1_GEN_REG,
+	/* DI_VSYNC_WR_MPEG_REG(DI_IF1_GEN_REG,
 Rd(DI_IF1_GEN_REG) & 0xfffffffe); */
 }
 
@@ -1399,7 +1805,7 @@ bool read_pulldown_info(pulldown_detect_info_t *field_pd_info,
 	int i;
 	unsigned long pd_info[6];
 	unsigned long tmp;
-	Wr(DI_INFO_ADDR, 0);
+	DI_Wr(DI_INFO_ADDR, 0);
 	for (i  = 0; i < 6; i++)
 		pd_info[i] = Rd(DI_INFO_DATA);
 
@@ -1416,7 +1822,7 @@ bool read_pulldown_info(pulldown_detect_info_t *field_pd_info,
 	fdn[4] = field_pd_info->frame_diff_num;
 	/* if (fdn[0] || fdn[1] || fdn[2] || fdn[3] || fdn[4]) */
 	if (frame_dynamic_dbg)
-		pr_info("\n fdn[4]= %x", fdn[4]);
+		pr_dbg("\n fdn[4]= %x", fdn[4]);
 	if (frame_dynamic_level == 0)
 		fdn[4] = fdn[4]&0xffff00;
 	else if (frame_dynamic_level == 1)
@@ -1456,59 +1862,86 @@ bool read_pulldown_info(pulldown_detect_info_t *field_pd_info,
 	return frame_dynamic;
 }
 
+void read_new_pulldown_info(struct FlmModReg_t *pFMReg)
+{
+	int i = 0;
+	for (i = 0; i < 6; i++) {
+		pFMReg->rROFrmDif02[i] = Rd(DIPD_RO_COMB_0+i);
+		pFMReg->rROFldDif01[i] = Rd(DIPD_RO_COMB_6+i);
+	}
+
+	/* pFMReg->rROFrmDif02[0] = Rd(DIPD_RO_COMB_0); */
+	/* pFMReg->rROFldDif01[0] = Rd(DIPD_RO_COMB_6); */
+
+	for (i = 0; i < 9; i++)
+		pFMReg->rROCmbInf[i] = Rd(DIPD_RO_COMB_12+i);
+}
+
 void di_post_read_reverse(bool reverse)
 {
 #ifdef NEW_DI_TV
 	if (reverse) {
-		Wr_reg_bits(DI_IF1_GEN_REG2,	3, 2, 2);
-		Wr_reg_bits(VD1_IF0_GEN_REG2, 0xf, 2, 4);
-		Wr_reg_bits(VD2_IF0_GEN_REG2, 0xf, 2, 4);
-		#ifdef MCDI_SUPPORT
-		/* motion vector read reverse*/
-		Wr_reg_bits(MCDI_MCVECRD_X, 1, 30, 1);
-		Wr_reg_bits(MCDI_MCVECRD_Y, 1, 30, 1);
-		Wr_reg_bits(MCDI_MC_CRTL, 0, 8, 1);
-		#endif
+		DI_Wr_reg_bits(DI_IF1_GEN_REG2, 3, 2, 2);
+		DI_Wr_reg_bits(VD1_IF0_GEN_REG2, 0xf, 2, 4);
+		DI_Wr_reg_bits(VD2_IF0_GEN_REG2, 0xf, 2, 4);
+		if (mcpre_en) {
+			/* motion vector read reverse*/
+			DI_Wr_reg_bits(MCDI_MCVECRD_X, 1, 30, 1);
+			DI_Wr_reg_bits(MCDI_MCVECRD_Y, 1, 30, 1);
+			DI_Wr_reg_bits(MCDI_MC_CRTL, 0, 8, 1);
+		}
 	} else {
-		Wr_reg_bits(DI_IF1_GEN_REG2,  0, 2, 2);
-		Wr_reg_bits(VD1_IF0_GEN_REG2, 0, 2, 4);
-		Wr_reg_bits(VD2_IF0_GEN_REG2, 0, 2, 4);
-		#ifdef MCDI_SUPPORT
-		Wr_reg_bits(MCDI_MCVECRD_X, 0, 30, 1);
-		Wr_reg_bits(MCDI_MCVECRD_Y, 0, 30, 1);
-		Wr_reg_bits(MCDI_MC_CRTL, 1, 8, 1);
-		#endif
+		DI_Wr_reg_bits(DI_IF1_GEN_REG2,  0, 2, 2);
+		DI_Wr_reg_bits(VD1_IF0_GEN_REG2, 0, 2, 4);
+		DI_Wr_reg_bits(VD2_IF0_GEN_REG2, 0, 2, 4);
+		if (mcpre_en) {
+			DI_Wr_reg_bits(MCDI_MCVECRD_X, 0, 30, 1);
+			DI_Wr_reg_bits(MCDI_MCVECRD_Y, 0, 30, 1);
+			DI_Wr_reg_bits(MCDI_MC_CRTL, 1, 8, 1);
+		}
 	}
 #endif
 }
 void di_post_read_reverse_irq(bool reverse)
 {
-#ifdef NEW_DI_TV
 	if (reverse) {
-		VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG2,    3, 2, 2);
-		VSYNC_WR_MPEG_REG_BITS(VD1_IF0_GEN_REG2, 0xf, 2, 4);
-		VSYNC_WR_MPEG_REG_BITS(VD2_IF0_GEN_REG2, 0xf, 2, 4);
-		VSYNC_WR_MPEG_REG_BITS(DI_MTNRD_CTRL, 0xf, 17, 4);
-		#ifdef MCDI_SUPPORT
-		/* motion vector read reverse*/
-		VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_X, 1, 30, 1);
-		VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_Y, 1, 30, 1);
-		VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 0, 8, 1);
-		#endif
+		DI_VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG2,    3, 2, 2);
+		DI_VSYNC_WR_MPEG_REG_BITS(VD1_IF0_GEN_REG2, 0xf, 2, 4);
+		DI_VSYNC_WR_MPEG_REG_BITS(VD2_IF0_GEN_REG2, 0xf, 2, 4);
+		DI_VSYNC_WR_MPEG_REG_BITS(DI_MTNRD_CTRL, 0xf, 17, 4);
+		if (mcpre_en) {
+			/* motion vector read reverse*/
+			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_X, 1, 30, 1);
+			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_Y, 1, 30, 1);
+			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 0, 8, 1);
+		}
 	} else {
-		VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG2,  0, 2, 2);
-		VSYNC_WR_MPEG_REG_BITS(VD1_IF0_GEN_REG2, 0, 2, 4);
-		VSYNC_WR_MPEG_REG_BITS(VD2_IF0_GEN_REG2, 0, 2, 4);
-		VSYNC_WR_MPEG_REG_BITS(DI_MTNRD_CTRL, 0, 17, 4);
-		#ifdef MCDI_SUPPORT
-		VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_X, 0, 30, 1);
-		VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_Y, 0, 30, 1);
-		VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL, 1, 8, 1);
-		#endif
+		DI_VSYNC_WR_MPEG_REG_BITS(DI_IF1_GEN_REG2,  0, 2, 2);
+		DI_VSYNC_WR_MPEG_REG_BITS(VD1_IF0_GEN_REG2, 0, 2, 4);
+		DI_VSYNC_WR_MPEG_REG_BITS(VD2_IF0_GEN_REG2, 0, 2, 4);
+		DI_VSYNC_WR_MPEG_REG_BITS(DI_MTNRD_CTRL, 0, 17, 4);
+		if (mcpre_en) {
+			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_X, 0, 30, 1);
+			DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MCVECRD_Y, 0, 30, 1);
+			if (is_meson_txl_cpu())
+				DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
+					mc_pre_flag, 8, 2);
+			else
+				DI_VSYNC_WR_MPEG_REG_BITS(MCDI_MC_CRTL,
+					1, 8, 1);
+		}
 	}
-#endif
 }
 
+void diwr_set_power_control(unsigned char enable)
+{
+	switch_vpu_mem_pd_vmod(VPU_VIU_VD1,
+		enable?VPU_MEM_POWER_ON:VPU_MEM_POWER_DOWN);
+	switch_vpu_mem_pd_vmod(VPU_DI_POST,
+		enable?VPU_MEM_POWER_ON:VPU_MEM_POWER_DOWN);
+}
+
+
 static unsigned char pre_power_on;
 static unsigned char post_power_on;
 void di_set_power_control(unsigned char type, unsigned char enable)
@@ -1543,28 +1976,170 @@ unsigned char di_get_power_control(unsigned char type)
 
 static void di_nr_init(void)
 {
-	Wr(DI_NR_CTRL0, 0xc60c0804);
-	Wr(DI_NR_CTRL1, 0x403e3c3a);
-	Wr(DI_NR_CTRL2, 0x08010a01);
-	Wr(NR2_MET_NM_CCTRL, 0x45056410);
-	Wr(NR2_MATNR_SNR_NRM_GAIN, 0x4);
-	Wr(NR2_MATNR_SNR_LPF_CFG, 0xc2b64);
-	Wr(NR2_MATNR_SNR_EDGE2B, 0xcff08);
-	Wr(NR2_MATNR_YBETA_SCL, 0x00ff2000);
-	Wr(NR2_MATNR_MTN_CRTL2, 0x32020);
-	Wr(NR2_MATNR_MTN_COR, 0x3333);
-	Wr(NR2_MATNR_DEGHOST, 0x133);
-	Wr(NR2_MATNR_ALPHALP_LUT1, 0x80805040);
-	Wr(NR2_MATNR_ALPHALP_LUT2, 0x90808080);
-	Wr(NR2_MATNR_ALPHALP_LUT3, 0xffe0c0a4);
-	Wr(NR2_MATNR_ALPHAHP_LUT1, 0x80805040);
-	Wr(NR2_MATNR_ALPHAHP_LUT2, 0x90808080);
-	Wr(NR2_MATNR_ALPHAHP_LUT3, 0xffe0c0a4);
-	Wr(NR3_MODE, 0x3);
-	Wr(NR3_COOP_PARA, 0x28ff00);
-	Wr(NR3_CNOOP_GAIN, 0x881900);
-	Wr(NR3_YMOT_PARA, 0x0c0a1e);
-	Wr(NR3_CMOT_PARA, 0x08140f);
-	Wr(NR3_SUREMOT_YGAIN, 0x100c4014);
-	Wr(NR3_SUREMOT_CGAIN, 0x22264014);
+#if 0
+	DI_Wr(DI_NR_CTRL0, 0xc60c0804);
+	DI_Wr(DI_NR_CTRL1, 0x403e3c3a);
+	DI_Wr(DI_NR_CTRL2, 0x08010a01);
+	DI_Wr(NR2_MET_NM_CCTRL, 0x45056410);
+	DI_Wr(NR2_MATNR_SNR_NRM_GAIN, 0x4);
+	DI_Wr(NR2_MATNR_SNR_LPF_CFG, 0xc2b64);
+	DI_Wr(NR2_MATNR_SNR_EDGE2B, 0xcff08);
+	DI_Wr(NR2_MATNR_YBETA_SCL, 0x00ff2000);
+	DI_Wr(NR2_MATNR_MTN_CRTL2, 0x32020);
+	DI_Wr(NR2_MATNR_MTN_COR, 0x3333);
+	DI_Wr(NR2_MATNR_DEGHOST, 0x133);
+	DI_Wr(NR2_MATNR_ALPHALP_LUT0, 0x99999a9a);
+	DI_Wr(NR2_MATNR_ALPHALP_LUT1, 0x9aa0a6e3);
+	DI_Wr(NR2_MATNR_ALPHALP_LUT2, 0x90808080);
+	DI_Wr(NR2_MATNR_ALPHALP_LUT3, 0xffe0c0a4);
+	DI_Wr(NR2_MATNR_ALPHAHP_LUT1, 0x80805040);
+	DI_Wr(NR2_MATNR_ALPHAHP_LUT2, 0x90808080);
+	DI_Wr(NR2_MATNR_ALPHAHP_LUT3, 0xffe0c0a4);
+#endif
+	DI_Wr(NR3_MODE, 0x3);
+	DI_Wr(NR3_COOP_PARA, 0x28ff00);
+	DI_Wr(NR3_CNOOP_GAIN, 0x881900);
+	DI_Wr(NR3_YMOT_PARA, 0x0c0a1e);
+	DI_Wr(NR3_CMOT_PARA, 0x08140f);
+	DI_Wr(NR3_SUREMOT_YGAIN, 0x100c4014);
+	DI_Wr(NR3_SUREMOT_CGAIN, 0x22264014);
+
+	DI_Wr(0x1745, 0x5056410);
+	DI_Wr(0x1746, 0x45056410);
+	DI_Wr(0x1747, 0x45056410);
+	DI_Wr(0x1748, 0x1);
+	DI_Wr(0x1749, 0x7c3a);
+	DI_Wr(0x174a, 0x29e77);
+	DI_Wr(0x174b, 0x9f1a);
+	DI_Wr(0x174c, 0x2822c);
+	DI_Wr(0x174d, 0x77);
+	DI_Wr(0x174e, 0x3030);
+	DI_Wr(0x174f, 0x20030);
+	DI_Wr(0x1750, 0xf002d0);
+	DI_Wr(0x1751, 0x132f);
+	DI_Wr(0x1752, 0x8d);
+	DI_Wr(0x1753, 0x40ff00);
+	DI_Wr(0x1754, 0x4);
+	DI_Wr(0x1755, 0xc2b64);
+	DI_Wr(0x1756, 0x0);
+	DI_Wr(0x1757, 0x3608);
+	DI_Wr(0x1758, 0x420);
+	DI_Wr(0x1759, 0xa06664);
+	DI_Wr(0x175a, 0xe0000);
+	DI_Wr(0x175b, 0x991c00);
+	DI_Wr(0x175c, 0x991000);
+	DI_Wr(0x175d, 0xf9f3e);
+	DI_Wr(0x175e, 0x7292abcd);
+	DI_Wr(0x175f, 0x1c23314f);
+	DI_Wr(0x1760, 0xf111317);
+	DI_Wr(0x1761, 0x8090a0c);
+	DI_Wr(0x1762, 0x80a0e0ff);
+	DI_Wr(0x1763, 0x4102050);
+	DI_Wr(0x1764, 0x2);
+	DI_Wr(0x1765, 0x0);
+	DI_Wr(0x1766, 0x20100400);
+	DI_Wr(0x1767, 0xc4804030);
+	DI_Wr(0x1768, 0xfffff0e0);
+	DI_Wr(0x1769, 0xffffffff);
+	DI_Wr(0x176a, 0x1132);
+	DI_Wr(0x176b, 0x32020);
+	DI_Wr(0x176c, 0x3333);
+	DI_Wr(0x176d, 0x4b4e4b4d);
+	DI_Wr(0x176e, 0x111);
+	DI_Wr(0x176f, 0x32181818);
+	DI_Wr(0x1770, 0x80644032);
+	DI_Wr(0x1771, 0x9e808080);
+	DI_Wr(0x1772, 0xffffffff);
+	DI_Wr(0x1773, 0x32181818);
+	DI_Wr(0x1774, 0x80644032);
+	DI_Wr(0x1775, 0xa5808080);
+	DI_Wr(0x1776, 0xffffffff);
+	DI_Wr(0x1777, 0xa06663);
+	DI_Wr(0x1778, 0x372);
+	DI_Wr(0x1779, 0x14141414);
+	DI_Wr(0x177a, 0x1400);
+	DI_Wr(0x177b, 0x80064);
+	DI_Wr(0x177c, 0x80064);
+	DI_Wr(0x177d, 0x80a0a);
+	DI_Wr(0x177e, 0x4281e);
+	DI_Wr(0x177f, 0x0);
+	DI_Wr(0x179c, 0x11b);
+	DI_Wr(0x179d, 0x202220);
+}
+
+void enable_di_pre_mif(int en)
+{
+	if (en) {
+		/* enable input mif*/
+		DI_Wr(DI_CHAN2_GEN_REG, Rd(DI_CHAN2_GEN_REG) | 0x1);
+		DI_Wr(DI_MEM_GEN_REG, Rd(DI_MEM_GEN_REG) | 0x1);
+		DI_Wr(DI_INP_GEN_REG, Rd(DI_INP_GEN_REG) | 0x1);
+		/* nrwr no clk gate en=0 */
+		RDMA_WR_BITS(DI_NRWR_CTRL, 0, 24, 1);
+		if (mcpre_en) {
+			/* gate clk */
+			RDMA_WR_BITS(MCDI_MCVECWR_CTRL, 0, 9, 1);
+			/* gate clk */
+			RDMA_WR_BITS(MCDI_MCINFOWR_CTRL, 0, 9, 1);
+		}
+		/* enable di nr/mtn/mv mif */
+		RDMA_WR(VPU_WRARB_REQEN_SLV_L1C1, 0x3f);
+	} else {
+		/* nrwr no clk gate en=1 */
+		RDMA_WR_BITS(DI_NRWR_CTRL, 1, 24, 1);
+		/* nr wr req en =0 */
+		RDMA_WR_BITS(DI_PRE_CTRL, 0, 0, 1);
+		/* mtn wr req en =0 */
+		RDMA_WR_BITS(DI_PRE_CTRL, 0, 1, 1);
+		/* cont wr req en =0 */
+		RDMA_WR_BITS(DI_MTN_1_CTRL1, 0, 31, 1);
+		if (mcpre_en) {
+			/* no gate clk */
+			RDMA_WR_BITS(MCDI_MCVECWR_CTRL, 1, 9, 1);
+			/* no gate clk */
+			RDMA_WR_BITS(MCDI_MCINFOWR_CTRL, 1, 9, 1);
+			/* mcvec wr req en =0 */
+			RDMA_WR_BITS(MCDI_MCVECWR_CTRL, 0, 12, 1);
+			/* mcinfo wr req en =0 */
+			RDMA_WR_BITS(MCDI_MCINFOWR_CTRL, 0, 12, 1);
+			/* mcinfo rd req en = 0 */
+			RDMA_WR_BITS(MCDI_MCINFORD_CTRL, 0, 9, 1);
+		}
+		/* disable nr cont mtn mv minfo mif */
+		RDMA_WR(VPU_WRARB_REQEN_SLV_L1C1, 0x2b);
+		/* disable cont rd */
+		DI_Wr(DI_PRE_CTRL, Rd(DI_PRE_CTRL) & ~(1 << 25));
+		/* disable input mif*/
+		DI_Wr(DI_CHAN2_GEN_REG, Rd(DI_CHAN2_GEN_REG) & ~0x1);
+		DI_Wr(DI_MEM_GEN_REG, Rd(DI_MEM_GEN_REG) & ~0x1);
+		DI_Wr(DI_INP_GEN_REG, Rd(DI_INP_GEN_REG) & ~0x1);
+	}
+}
+
+void combing_pd22_window_config(unsigned int width, unsigned int height)
+{
+	unsigned short y1 = 39, y2 = height - 41;
+	if (width == 1080) {
+		y1 = 79;
+		y2 = height - 81;
+	}
+
+	DI_Wr_reg_bits(DECOMB_WIND00, 0, 16, 13);/* dcomb x0 */
+	DI_Wr_reg_bits(DECOMB_WIND00, (width-1), 0, 13);/* dcomb x1 */
+	DI_Wr_reg_bits(DECOMB_WIND01, 0, 16, 13);/* dcomb y0 */
+	DI_Wr_reg_bits(DECOMB_WIND01, y1, 0, 13);/* dcomb y1 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND0_X, 0, 0, 13);/* pd22 x0 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND0_X, (width-1), 16, 13);/* pd22 x1 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND0_Y, 0, 0, 13);/* pd22 y0 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND0_Y, y1, 16, 13);/* pd y1 */
+
+	DI_Wr_reg_bits(DECOMB_WIND10, 0, 16, 13);/* dcomb x0 */
+	DI_Wr_reg_bits(DECOMB_WIND10, (width-1), 0, 13);/* dcomb x1 */
+	DI_Wr_reg_bits(DECOMB_WIND11, (y1+1), 16, 13);/* dcomb y0 */
+	DI_Wr_reg_bits(DECOMB_WIND11, y2, 0, 13);/* dcomb y1 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND1_X, 0, 0, 13);/* pd x0 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND1_X , (width-1), 16, 13);/* pd x1 */
+	DI_Wr_reg_bits(MCDI_PD_22_CHK_WND1_Y, (y1+1), 0, 13);/* pd y0 */
+	DI_Wr_reg_bits(DECOMB_WIND11, y2, 16, 13);/* pd y1 */
+
 }
diff --git a/drivers/amlogic/deinterlace/deinterlace_pd.c b/drivers/amlogic/deinterlace/deinterlace_pd.c
index d031c43..f3c9ced 100644
--- a/drivers/amlogic/deinterlace/deinterlace_pd.c
+++ b/drivers/amlogic/deinterlace/deinterlace_pd.c
@@ -570,22 +570,22 @@ void init_pd_para(void)
 			win_pd_th[i].field_diff_num_th = 10;
 	}
 
-	Wr(DI_MC_32LVL1, 16 |	/* region 3 */
+	DI_Wr(DI_MC_32LVL1, 16 |	/* region 3 */
 	(16 << 8));/* region 4 */
 
-	Wr(DI_MC_32LVL0, 16	|	/* field 32 level */
+	DI_Wr(DI_MC_32LVL0, 16	|	/* field 32 level */
 	(16 << 8)  |	/* region 0 */
 	(16 << 16) |	/* region 1 */
 	(16 << 24));	/* region 2 */
-	Wr(DI_MC_22LVL0,  256  |/* field 22 level */
+	DI_Wr(DI_MC_22LVL0,  256  |/* field 22 level */
 	(768 << 16));	/* region 0 */
 
-	Wr(DI_MC_22LVL1, 768	|/* region 1 */
+	DI_Wr(DI_MC_22LVL1, 768	|/* region 1 */
 	(768 << 16));	/* region 2 */
 
-	Wr(DI_MC_22LVL2, 768 |	/* region 3 */
+	DI_Wr(DI_MC_22LVL2, 768 |	/* region 3 */
 	(768 << 16));	/* region 4. */
-	Wr(DI_MC_CTRL, 0x1f);	/* enable region level */
+	DI_Wr(DI_MC_CTRL, 0x1f);	/* enable region level */
 
 }
 
diff --git a/drivers/amlogic/deinterlace/detect3d.c b/drivers/amlogic/deinterlace/detect3d.c
index e9b5fd0..89ebc9a 100644
--- a/drivers/amlogic/deinterlace/detect3d.c
+++ b/drivers/amlogic/deinterlace/detect3d.c
@@ -5,9 +5,11 @@
 
 #include <linux/amlogic/iomap.h>
 #include <linux/amlogic/tvin/tvin.h>
+#include <linux/amlogic/iomap.h>
 
 #include "register.h"
 #include "detect3d.h"
+#include "deinterlace.h"
 
 /*******************Local defines**********************/
 #define DET3D_REG_NUM				9
@@ -86,23 +88,23 @@ void det3d_enable(bool flag)
 
 	if (flag == 1) {
 		/* disable 3D detection */
-		WRITE_DET3D_REG_BITS(NR2_SW_EN, 0, DET3D_EN_BIT, DET3D_EN_WID);
+		DI_Wr_reg_bits(NR2_SW_EN, 0, DET3D_EN_BIT, DET3D_EN_WID);
 
 		/* initalize the registers */
 		for (i = 0; i < DET3D_REG_NUM; i++)
-			WRITE_DET3D_REG((DET3D_BASE_ADD + i), det3d_table[i]);
+			DI_Wr((DET3D_BASE_ADD + i), det3d_table[i]);
 
 		/* Det 3D interrupt enble */
-		WRITE_DET3D_REG_BITS(DET3D_MOTN_CFG, 1,
+		DI_Wr_reg_bits(DET3D_MOTN_CFG, 1,
 DET3D_INTR_EN_BIT, DET3D_INTR_EN_WID);
 		/* enable 3D detection */
-		WRITE_DET3D_REG_BITS(NR2_SW_EN, 1, DET3D_EN_BIT, DET3D_EN_WID);
+		DI_Wr_reg_bits(NR2_SW_EN, 1, DET3D_EN_BIT, DET3D_EN_WID);
 	} else{
 		/* Det 3D interrupt disable */
-		WRITE_DET3D_REG_BITS(DET3D_MOTN_CFG, 0,
+		DI_Wr_reg_bits(DET3D_MOTN_CFG, 0,
 DET3D_INTR_EN_BIT, DET3D_INTR_EN_WID);
 		/* disable 3D detection */
-		WRITE_DET3D_REG_BITS(NR2_SW_EN, 0, DET3D_EN_BIT, DET3D_EN_WID);
+		DI_Wr_reg_bits(NR2_SW_EN, 0, DET3D_EN_BIT, DET3D_EN_WID);
 		memset(&det3d_info, 0, sizeof(det3d_info));
 	}
 }
@@ -120,10 +122,10 @@ int read_cbus_reg_signed_bits(unsigned int reg, unsigned int startbit,
 
 	if (length > 31)
 		length = 31;
-	val = READ_DET3D_REG_BITS(reg, startbit, length);
+	val = Rd_reg_bits(reg, startbit, length);
 	tmp = tmp << (length - 1);
 
-	/* pr_info("len = %d, unsigned value = %d,
+	/* pr_dbg("len = %d, unsigned value = %d,
 signed value = %d",length,val,((val >= tmp )?(val - (tmp << 1)):val));*/
 	return (val >= tmp)?(val - (tmp << 1)):val;
 }
@@ -204,7 +206,7 @@ det3d_info.tscore_3d_tb_accum + (tb_score <= 0) -
 		det3d_info.score_3d_chs = det3d_info.score_3d_chs + tmp1;
 		det3d_info.score_3d_int = det3d_info.score_3d_int + tmp2;
 		if (det3d_debug)
-			pr_info("%s input(%d,%d),output (%d,%d).\n",
+			pr_dbg("%s input(%d,%d),output (%d,%d).\n",
 __func__, chessbd_score, int_score,
 det3d_info.score_3d_chs, det3d_info.score_3d_int);
 		/* cliping to s7 */
@@ -228,7 +230,7 @@ INTERLACE_FMT_SCORE_MIN : det3d_info.score_3d_int;
  * detect 3D format
  * execute one or more frame after init;
  */
-enum det3d_fmt_e det3d_fmt_detect(void)
+enum tvin_trans_fmt det3d_fmt_detect(void)
 {
 	/* FW registers */
 	int chessbd_hor_rate = 31;/* 8bits: norm to 16 */
@@ -253,14 +255,14 @@ enum det3d_fmt_e det3d_fmt_detect(void)
 
 	/* Split line contribution */
 	tmp_sp_lr =
-READ_DET3D_REG_BITS(DET3D_RO_SPLT_HT,
+Rd_reg_bits(DET3D_RO_SPLT_HT,
 	DET3D_SPLIT_HT_VAILID_BIT, DET3D_SPLIT_HT_VAILID_WID)
-+ READ_DET3D_REG_BITS(DET3D_RO_SPLT_HB,
++ Rd_reg_bits(DET3D_RO_SPLT_HB,
 	DET3D_SPLIT_HB_VAILID_BIT, DET3D_SPLIT_HB_VAILID_WID);
 	tmp_sp_tb =
-READ_DET3D_REG_BITS(DET3D_RO_SPLT_VL,
+Rd_reg_bits(DET3D_RO_SPLT_VL,
 	DET3D_SPLIT_VL_VAILID_BIT, DET3D_SPLIT_VL_VAILID_WID)
-+ READ_DET3D_REG_BITS(DET3D_RO_SPLT_VR,
++ Rd_reg_bits(DET3D_RO_SPLT_VR,
 	DET3D_SPLIT_VR_VAILID_BIT, DET3D_SPLIT_VR_VAILID_WID);
 
 	/* protect static graphics pattern */
@@ -305,24 +307,24 @@ READ_DET3D_REG_BITS(DET3D_RO_SPLT_VL,
 
 	for (m = 0; m < 8; m++) {
 		tmp_symtc_lr = tmp_symtc_lr
-+ READ_DET3D_REG_BITS(DET3D_RO_MAT_LUMA_LR, DET3D_LUMA_LR_SYMTC_BIT + m, 1)
-+ READ_DET3D_REG_BITS(DET3D_RO_MAT_CHRU_LR, DET3D_CHRU_LR_SYMTC_BIT + m, 1)
-+ READ_DET3D_REG_BITS(DET3D_RO_MAT_CHRV_LR, DET3D_CHRV_LR_SYMTC_BIT + m, 1)
-+ READ_DET3D_REG_BITS(DET3D_RO_MAT_HEDG_LR, DET3D_HEDG_LR_SYMTC_BIT + m, 1)
-+ READ_DET3D_REG_BITS(DET3D_RO_MAT_VEDG_LR, DET3D_VEDG_LR_SYMTC_BIT + m, 1)
-+ READ_DET3D_REG_BITS(DET3D_RO_MAT_MOTN_LR, DET3D_MOTN_LR_SYMTC_BIT + m, 1);
++ Rd_reg_bits(DET3D_RO_MAT_LUMA_LR, (DET3D_LUMA_LR_SYMTC_BIT + m), 1)
++ Rd_reg_bits(DET3D_RO_MAT_CHRU_LR, (DET3D_CHRU_LR_SYMTC_BIT + m), 1)
++ Rd_reg_bits(DET3D_RO_MAT_CHRV_LR, (DET3D_CHRV_LR_SYMTC_BIT + m), 1)
++ Rd_reg_bits(DET3D_RO_MAT_HEDG_LR, (DET3D_HEDG_LR_SYMTC_BIT + m), 1)
++ Rd_reg_bits(DET3D_RO_MAT_VEDG_LR, (DET3D_VEDG_LR_SYMTC_BIT + m), 1)
++ Rd_reg_bits(DET3D_RO_MAT_MOTN_LR, (DET3D_MOTN_LR_SYMTC_BIT + m), 1);
 		tmp_symtc_tb = tmp_symtc_tb
-+ READ_DET3D_REG_BITS(DET3D_RO_MAT_LUMA_TB, DET3D_LUMA_TB_SYMTC_BIT + m, 1)
-+ READ_DET3D_REG_BITS(DET3D_RO_MAT_CHRU_TB, DET3D_CHRU_TB_SYMTC_BIT + m, 1)
-+ READ_DET3D_REG_BITS(DET3D_RO_MAT_CHRV_TB, DET3D_CHRV_TB_SYMTC_BIT + m, 1)
-+ READ_DET3D_REG_BITS(DET3D_RO_MAT_HEDG_TB, DET3D_HEDG_TB_SYMTC_BIT + m, 1)
-+ READ_DET3D_REG_BITS(DET3D_RO_MAT_VEDG_TB, DET3D_VEDG_TB_SYMTC_BIT + m, 1)
-+ READ_DET3D_REG_BITS(DET3D_RO_MAT_MOTN_TB, DET3D_MOTN_TB_SYMTC_BIT + m, 1);
++ Rd_reg_bits(DET3D_RO_MAT_LUMA_TB, (DET3D_LUMA_TB_SYMTC_BIT + m), 1)
++ Rd_reg_bits(DET3D_RO_MAT_CHRU_TB, (DET3D_CHRU_TB_SYMTC_BIT + m), 1)
++ Rd_reg_bits(DET3D_RO_MAT_CHRV_TB, (DET3D_CHRV_TB_SYMTC_BIT + m), 1)
++ Rd_reg_bits(DET3D_RO_MAT_HEDG_TB, (DET3D_HEDG_TB_SYMTC_BIT + m), 1)
++ Rd_reg_bits(DET3D_RO_MAT_VEDG_TB, (DET3D_VEDG_TB_SYMTC_BIT + m), 1)
++ Rd_reg_bits(DET3D_RO_MAT_MOTN_TB, (DET3D_MOTN_TB_SYMTC_BIT + m), 1);
 	}
 
 	tmp_symtc_lr = tmp_symtc_lr > LR_SYMMETRY_LOWER_LIMIT;
 	tmp_symtc_tb = tmp_symtc_tb > TB_SYMMETRY_LOWER_LIMIT;
-	tmp_frmstill = READ_DET3D_REG_BITS(DET3D_RO_FRM_MOTN,
+	tmp_frmstill = Rd_reg_bits(DET3D_RO_FRM_MOTN,
 DET3D_FRAME_MOTION_BIT, DET3D_FRAME_MOTION_WID) < 100;
 
 	/* if FrmStill && score>=0, force score decrease 1 */
@@ -336,16 +338,16 @@ DET3D_FRAME_MOTION_BIT, DET3D_FRAME_MOTION_WID) < 100;
 	/* if (tmp_frmstill&&tmp_symtc_tb&&(tmp_tb>=0)) tmp_tb = 0; */
 
 	/* ChessBoard/interlace mode score */
-	tmp1 = READ_DET3D_REG_BITS(DET3D_RO_DET_CB_HOR,
+	tmp1 = Rd_reg_bits(DET3D_RO_DET_CB_HOR,
 DET3D_CHESSBD_HOR_VALUE_BIT, DET3D_CHESSBD_HOR_VALUE_WID);
-	tmp2 = READ_DET3D_REG_BITS(DET3D_RO_DET_CB_HOR,
+	tmp2 = Rd_reg_bits(DET3D_RO_DET_CB_HOR,
 DET3D_CHESSBD_NHOR_VALUE_BIT, DET3D_CHESSBD_NHOR_VALUE_WID);
 	chessbd_hor_valid = tmp1 >
 (((tmp2 * chessbd_hor_rate) >> 4) + chessbd_hor_thrd);
 
-	tmp1 = READ_DET3D_REG_BITS(DET3D_RO_DET_CB_VER,
+	tmp1 = Rd_reg_bits(DET3D_RO_DET_CB_VER,
 DET3D_CHESSBD_VER_VALUE_BIT, DET3D_CHESSBD_VER_VALUE_WID);
-	tmp2 = READ_DET3D_REG_BITS(DET3D_RO_DET_CB_VER,
+	tmp2 = Rd_reg_bits(DET3D_RO_DET_CB_VER,
 DET3D_CHESSBD_NVER_VALUE_BIT, DET3D_CHESSBD_NVER_VALUE_WID);
 	chessbd_ver_valid = tmp1 > (((tmp2 * chessbd_vrate) >> 4) +
 chessbd_ver_thrd);
@@ -367,13 +369,15 @@ chessbd_ver_thrd);
 (det3d_info.score_3d_tb < -127)) || ((det3d_info.tscore_3d_tb_accum >= 4) &&
 (det3d_info.score_3d_tb > 63)))
 		det3d_info.score_3d_tb = 0;
-
+#if 0 /*mark chessboard 3d detection*/
 	if ((det3d_info.score_3d_chs > CHESSBOADE_SCORE_LOWER_LIMIT) &&
 (det3d_info.score_3d_int < NOT_INTERLACE_SCORE_UPPER_LIMIT)) {
 		det3d_info.tfw_det3d_fmt = TVIN_TFMT_3D_DET_CHESSBOARD;
 		det3d_info.score_3d_lr = 0;
 		det3d_info.score_3d_tb = 0;
-	} else if ((det3d_info.score_3d_int > INTERLACE_SCORE_LOWER_LIMIT) &&
+	} else
+#endif
+	if ((det3d_info.score_3d_int > INTERLACE_SCORE_LOWER_LIMIT) &&
 (det3d_info.score_3d_chs < NOT_CHESSBOAD_SCORE_UPPER_LIMIT)) {
 		det3d_info.tfw_det3d_fmt = TVIN_TFMT_3D_DET_INTERLACE;
 		det3d_info.score_3d_lr = 0;
@@ -399,11 +403,12 @@ chessbd_ver_thrd);
 		}
 	}
 
-	if (det3d_debug)
-		pr_info("det3d:frame = %d, 3D_fmt = %d, score_3d_lr = %d,",
+	if (det3d_debug) {
+		pr_dbg("det3d:frame = %d, 3D_fmt = %d, score_3d_lr = %d,",
 det3d_info.nfrm, det3d_info.tfw_det3d_fmt, det3d_info.score_3d_lr);
-		pr_info("score_3d_tb = %d, score_3d_int = %d, score_3d_chs = %d",
+		pr_dbg("score_3d_tb = %d, score_3d_int = %d, score_3d_chs = %d",
 det3d_info.score_3d_tb, det3d_info.score_3d_int, det3d_info.score_3d_chs);
+	}
 	return det3d_info.tfw_det3d_fmt;
 }
 
diff --git a/drivers/amlogic/deinterlace/detect3d.h b/drivers/amlogic/deinterlace/detect3d.h
index d99dc63..2c235da 100644
--- a/drivers/amlogic/deinterlace/detect3d.h
+++ b/drivers/amlogic/deinterlace/detect3d.h
@@ -294,12 +294,12 @@ enum det3d_fmt_e {
 /* ******** GLOBAL FUNCTION CLAIM ******** */
 /* *************************************** */
 extern void det3d_enable(bool flag);
-extern enum det3d_fmt_e det3d_fmt_detect(void);
+extern enum tvin_trans_fmt det3d_fmt_detect(void);
 #define WRITE_DET3D_REG(x, val)				aml_write_vcbus(x, val)
 #define WRITE_DET3D_REG_BITS(x, val, start, length) \
-	aml_vcbus_update_bits(x, ((1<<length)-1)<<start, val)
+	aml_vcbus_update_bits(x, ((1<<(length))-1)<<(start), val)
 #define READ_DET3D_REG(x)	aml_read_vcbus(x)
 #define READ_DET3D_REG_BITS(x, start, length) \
-	(aml_read_vcbus(x)&(((1<<length)-1)<<start))
+	(aml_read_vcbus(x)&(((1<<(length))-1)<<(start)))
 
 #endif  /* _DET3D_H */
diff --git a/drivers/amlogic/deinterlace/dnr.c b/drivers/amlogic/deinterlace/dnr.c
index 567bd25..e0baa63 100644
--- a/drivers/amlogic/deinterlace/dnr.c
+++ b/drivers/amlogic/deinterlace/dnr.c
@@ -5,6 +5,7 @@
 #include <linux/amlogic/iomap.h>
 #include "register.h"
 #include "dnr.h"
+#include "deinterlace.h"
 
 static DNR_PRM_t dnr_param;
 static DNR_PRM_t *pDnrPrm = &dnr_param;
@@ -12,6 +13,18 @@ static bool dnr_pr;
 module_param(dnr_pr, bool, 0644);
 MODULE_PARM_DESC(dnr_pr, "/n print dnr debug information /n");
 
+bool dnr_dm_en;/*gxtvbb can't work normal,must set to 0*/
+module_param(dnr_dm_en, bool, 0644);
+MODULE_PARM_DESC(dnr_dm_en, "/n dnr dm enable debug /n");
+
+bool dnr_reg_update = 1;/*gxtvbb can't work normal,must set to 0*/
+module_param(dnr_reg_update, bool, 0644);
+MODULE_PARM_DESC(dnr_reg_update, "/n dnr dm enable debug /n");
+
+static unsigned int dnr_stat_coef = 3;/*gxtvbb default is 3*/
+module_param(dnr_stat_coef, uint, 0644);
+MODULE_PARM_DESC(dnr_stat_coef, "/n dnr stat coef /n");
+
 static int dnr_prm_init(DNR_PRM_t *pPrm)
 {
 	pPrm->prm_sw_gbs_ctrl = 0;
@@ -197,9 +210,9 @@ int hor_blk_ofst_calc_sw(int *pHbOfVldCnt,
 	}
 	*/
 	if (dnr_pr) {
-		pr_info("Max1 = %5d, Max2 = %5d, MaxIdx = %5d, Rat0 = %5d,Rat1 = %5d.\n",
+		pr_dbg("Max1 = %5d, Max2 = %5d, MaxIdx = %5d, Rat0 = %5d,Rat1 = %5d.\n",
 				nMax1, nMax2, nMaxIdx, nRat0, nRat1);
-		pr_info("CurHbOfst = %5d, HbOfVldFlg = %d, HbOfVldCnt = %d.\n",
+		pr_dbg("CurHbOfst = %5d, HbOfVldFlg = %d, HbOfVldCnt = %d.\n",
 				nCurHbOfst, *pHbOfVldFlg, *pHbOfVldCnt);
 	}
 
@@ -280,9 +293,16 @@ reg_dnr_stat_yst=0,reg_dnr_stat_yed=0; */
 #ifdef DNR_HV_SHIFT
 	int ro_hbof_stat_cnt[32], ro_vbof_stat_cnt[32], i = 0;
 #endif
-	Wr(DNR_HVSIZE, nCol<<16|nRow);
-	Wr(DNR_STAT_X_START_END, nCol-1);
-	Wr(DNR_STAT_Y_START_END, nRow-1);
+	if (dnr_reg_update == 0)
+		return;
+	DI_Wr(DNR_CTRL, 0x1df00);
+	DI_Wr(DNR_DM_CTRL, Rd(DNR_DM_CTRL)|(1 << 11));
+	DI_Wr_reg_bits(DNR_DM_CTRL, dnr_dm_en, 9, 1);
+	DI_Wr(DNR_HVSIZE, nCol<<16|nRow);
+	DI_Wr(DNR_STAT_X_START_END, (((8*dnr_stat_coef)&0x3fff) << 16)
+		|((nCol-(8*dnr_stat_coef+1))&0x3fff));
+	DI_Wr(DNR_STAT_Y_START_END, (((8*dnr_stat_coef)&0x3fff) << 16)
+		|((nRow-(8*dnr_stat_coef+1))&0x3fff));
 	ro_gbs_stat_lr = Rd(DNR_RO_GBS_STAT_LR);
 	ro_gbs_stat_ll = Rd(DNR_RO_GBS_STAT_LL);
 	ro_gbs_stat_rr = Rd(DNR_RO_GBS_STAT_RR);
@@ -337,25 +357,26 @@ reg_dnr_stat_yst=0,reg_dnr_stat_yed=0; */
 #endif
 	/* update hardware registers */
 	if (0 == pDnrPrm->prm_sw_gbs_ctrl) {
-		Wr(DNR_GBS, (1 == pDnrPrm->sw_gbs_vld_flg)?pDnrPrm->sw_gbs : 0);
+		DI_Wr(DNR_GBS,
+			(1 == pDnrPrm->sw_gbs_vld_flg)?pDnrPrm->sw_gbs : 0);
 	} else if (1 == pDnrPrm->prm_sw_gbs_ctrl) {
-		Wr_reg_bits(DNR_BLK_OFFST,
+		DI_Wr_reg_bits(DNR_BLK_OFFST,
 1 == pDnrPrm->sw_hbof_vld_flg?pDnrPrm->sw_hbof:0, 4, 3);
-		Wr(DNR_GBS,
+		DI_Wr(DNR_GBS,
 (1 == pDnrPrm->sw_hbof_vld_flg &&
 1 == pDnrPrm->sw_gbs_vld_flg)?pDnrPrm->sw_gbs:0);
 	} else if (2 == pDnrPrm->prm_sw_gbs_ctrl) {
-		Wr_reg_bits(DNR_BLK_OFFST,
+		DI_Wr_reg_bits(DNR_BLK_OFFST,
 1 == pDnrPrm->sw_vbof_vld_flg?pDnrPrm->sw_vbof:0, 0, 3);
-		Wr(DNR_GBS,
+		DI_Wr(DNR_GBS,
 (1 == pDnrPrm->sw_vbof_vld_flg &&
 1 == pDnrPrm->sw_gbs_vld_flg)?pDnrPrm->sw_gbs:0);
 	} else if (3 == pDnrPrm->prm_sw_gbs_ctrl) {
-		Wr_reg_bits(DNR_BLK_OFFST,
+		DI_Wr_reg_bits(DNR_BLK_OFFST,
 1 == pDnrPrm->sw_hbof_vld_flg ? pDnrPrm->sw_hbof : 0, 4, 3);
-	Wr_reg_bits(DNR_BLK_OFFST,
+	DI_Wr_reg_bits(DNR_BLK_OFFST,
 1 == pDnrPrm->sw_vbof_vld_flg ? pDnrPrm->sw_vbof : 0, 0, 3);
-	Wr(DNR_GBS,
+	DI_Wr(DNR_GBS,
 (1 == pDnrPrm->sw_hbof_vld_flg && 1 == pDnrPrm->sw_vbof_vld_flg &&
 1 == pDnrPrm->sw_gbs_vld_flg)?pDnrPrm->sw_gbs:0);
 	}
@@ -422,7 +443,7 @@ static ssize_t dnr_param_store(struct device *dev,
 		if (!strcmp(parm[0], dnr_params[i].name)) {
 			vaule = kstrtol(parm[1], 10, NULL);
 			*(dnr_params[i].addr) = vaule;
-			pr_info("%s=%d.\n", dnr_params[i].name,
+			pr_dbg("%s=%d.\n", dnr_params[i].name,
 *(dnr_params[i].addr));
 		}
 	}
diff --git a/drivers/amlogic/deinterlace/film_fw1.c b/drivers/amlogic/deinterlace/film_fw1.c
new file mode 100644
index 0000000..1265911
--- /dev/null
+++ b/drivers/amlogic/deinterlace/film_fw1.c
@@ -0,0 +1,1367 @@
+/* Film Detection and VOF detection Software implementation
+* Designer: Xin.Hu@amlogic.com
+* Date: 12/06/13 */
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "film_vof_soft.h"
+
+/* Software parameters (registers) */
+UINT8 FlmVOFSftInt(struct sFlmSftPar *pPar)
+{
+	pPar->sFrmDifAvgRat = 16;	/* 0~32 */
+	/* The Large Decision should be: (large>average+LgDifThrd) */
+	pPar->sFrmDifLgTDif = 4096;
+	pPar->sF32StpWgt01 = 15;
+	pPar->sF32StpWgt02 = 15;
+	/* Dif>Rat*Min  --> Larger */
+	pPar->sF32DifLgRat = 16;
+
+	pPar->sFlm2MinAlpha = 32;	/* [0~63] */
+	pPar->sFlm2MinBelta = 32;	/* [0~63] */
+	pPar->sFlm20ftAlpha = 16;	/* [0~63] */
+	pPar->sFlm2LgDifThd = 4096;	/* [0~63] %LgDifThrd */
+	pPar->sFlm2LgFlgThd = 8;
+
+	pPar->sF32Dif01A1 = 65;
+	pPar->sF32Dif01T1 = 128;
+	pPar->sF32Dif01A2 = 65;
+	pPar->sF32Dif01T2 = 128;
+
+	pPar->rCmbRwMinCt0 = 8;	/* for film 3-2 */
+	pPar->rCmbRwMinCt1 = 7;	/* for film 2-2 */
+
+	pPar->sFlm32NCmb = 8;	/* absolute no combing for film 32 */
+	/* pre-processing (t-0), post-processing f(t-mPstDlyPre); No RTL */
+	pPar->mPstDlyPre = 1;
+	/* pre-processing (t-0), pre-processing f(t+mNxtDlySft);
+	No RTL,default=1 */
+	pPar->mNxtDlySft = 1;
+
+	pPar->sF32Dif02M0 = 4096;	/* mpeg-4096, cvbs-8192 */
+	pPar->sF32Dif02M1 = 4096;
+
+	field_count = 0;
+
+	return 0;
+}
+
+/* Outputs:
+*     rCmb32Spcl:  1-bit, 0/1
+*    rPstCYWnd0~4[0]: bgn,
+*     rPstCYWnd0~4[1]: end,
+*     rPstCYWnd0~4[2]: 0-mtn,1-with-buffer,2-ei,3-di,
+*     rFlmPstGCm: 1-bit, global combing (maybe unused)
+*     rFlmSltPre: 1-bit, 0-next field, 1-previous field
+*     rFlmPstMod: 2-bit, 00-no, 01-22, 10-23, 11-other
+* Inputs:
+*     rROFldDif01:  difference f(t) and f(t-1), U32
+*     rROFldDif02:  difference f(t) and f(t-2), U32
+*     rROCmbInf[9]: U32 x 9
+*     nROW: (240 for 480i) */
+
+uint pr_pd = 0;
+module_param(pr_pd, uint, 0644);
+MODULE_PARM_DESC(pr_pd, "/n printk /n");
+
+bool prt_flg = 0;
+module_param(prt_flg, bool, 0644);
+MODULE_PARM_DESC(prt_flg, "/n prt_flg /n");
+
+char debug_str[512];
+
+/* if flmxx level > flmxx_first_num */
+/* flmxx first: even when 2-2 3-2 detected */
+/* unsigned int flmxx_first_num = 50; */
+/* module_param(flmxx_first_num, uint, 0644); */
+/* MODULE_PARM_DESC(flmxx_first_num, */
+/* "/n flmxx first: even when 2-2 3-2 detected /n"); */
+
+/* if flmxx level > flmxx_maybe_num */
+/* mabye flmxx: when 2-2 3-2 not detected */
+unsigned int flmxx_maybe_num = 15;
+module_param(flmxx_maybe_num, uint, 0644);
+MODULE_PARM_DESC(flmxx_maybe_num,
+"/n mabye flmxx: when 2-2 3-2 not detected /n");
+
+int flm32_mim_frms = 6;
+module_param(flm32_mim_frms, int, 0644);
+MODULE_PARM_DESC(flm32_mim_frms, "flm32_mim_frms");
+
+int flm22_mim_frms = 60;
+module_param(flm22_mim_frms, int, 0644);
+MODULE_PARM_DESC(flm22_mim_frms, "flm22_mim_frms");
+
+int flm32_f2fdif_min0 = 11;
+module_param(flm32_f2fdif_min0, int, 0644);
+MODULE_PARM_DESC(flm32_f2fdif_min0, "flm32_f2fdif_min0");
+
+int flm32_f2fdif_min1 = 11;
+module_param(flm32_f2fdif_min1, int, 0644);
+MODULE_PARM_DESC(flm32_f2fdif_min1, "flm32_f2fdif_min1");
+
+int flm32_chk1_rtn = 25;
+module_param(flm32_chk1_rtn, int, 0644);
+MODULE_PARM_DESC(flm32_chk1_rtn, "flm32_chk1_rtn");
+
+int flm32_ck13_rtn = 8;
+module_param(flm32_ck13_rtn, int, 0644);
+MODULE_PARM_DESC(flm32_ck13_rtn, "flm32_ck13_rtn");
+
+int flm32_chk2_rtn = 16;
+module_param(flm32_chk2_rtn, int, 0644);
+MODULE_PARM_DESC(flm32_chk2_rtn, "flm32_chk2_rtn");
+
+int flm32_chk3_rtn = 16;
+module_param(flm32_chk3_rtn, int, 0644);
+MODULE_PARM_DESC(flm32_chk3_rtn, "flm32_chk3_rtn");
+
+int flm22_chk20_sml = 6;
+module_param(flm22_chk20_sml, int, 0644);
+MODULE_PARM_DESC(flm22_chk20_sml, "flm22_chk20_sml");
+
+int flm22_chk21_sml = 6;
+module_param(flm22_chk21_sml, int, 0644);
+MODULE_PARM_DESC(flm22_chk21_sml, "flm22_chk21_sml");
+
+int flm22_chk21_sm2 = 10;
+module_param(flm22_chk21_sm2, int, 0644);
+MODULE_PARM_DESC(flm22_chk21_sm2, "flm22_chk21_sm2");
+
+int flm22_lavg_sft = 4;
+module_param(flm22_lavg_sft, int, 0644);
+MODULE_PARM_DESC(flm22_lavg_sft, "flm22_lavg_sft");
+
+int flm22_lavg_lg = 24;
+module_param(flm22_lavg_lg, int, 0644);
+MODULE_PARM_DESC(flm22_lavg_lg, "flm22_lavg_lg");
+
+/* dif02 < (size >> sft) => static */
+int flm22_stl_sft = 7; /*10*/
+module_param(flm22_stl_sft, int, 0644);
+MODULE_PARM_DESC(flm22_stl_sft, "flm22_stl_sft");
+
+int flm22_chk5_avg = 50;
+module_param(flm22_chk5_avg, int, 0644);
+MODULE_PARM_DESC(flm22_chk5_avg, "flm22_chk5_avg");
+
+int flm22_chk6_max = 20;
+module_param(flm22_chk6_max, int, 0644);
+MODULE_PARM_DESC(flm22_chk6_max, "flm22_chk6_max");
+
+int flm22_anti_chk1 = 61;
+module_param(flm22_anti_chk1, int, 0644);
+MODULE_PARM_DESC(flm22_anti_chk1, "flm22_anti_chk1");
+
+int flm22_anti_chk3 = 140;
+module_param(flm22_anti_chk3, int, 0644);
+MODULE_PARM_DESC(flm22_anti_chk3, "flm22_anti_chk3");
+
+int flm22_anti_chk4 = 128;
+module_param(flm22_anti_chk4, int, 0644);
+MODULE_PARM_DESC(flm22_anti_chk4, "flm22_anti_chk4");
+
+int flm22_anti_ck140 = 32;
+module_param(flm22_anti_ck140, int, 0644);
+MODULE_PARM_DESC(flm22_anti_ck140, "flm22_anti_ck140");
+
+int flm22_anti_ck141 = 80;
+module_param(flm22_anti_ck141, int, 0644);
+MODULE_PARM_DESC(flm22_anti_ck141, "flm22_anti_ck141");
+
+
+int FlmVOFSftTop(UINT8 *rCmb32Spcl, unsigned short *rPstCYWnd0,
+		 unsigned short *rPstCYWnd1, unsigned short *rPstCYWnd2,
+		 unsigned short *rPstCYWnd3, unsigned short *rPstCYWnd4,
+		 UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
+		 UINT32 *rROFldDif01, UINT32 *rROFrmDif02, UINT32 *rROCmbInf,
+		 int *tTCNm,
+		 struct sFlmSftPar *pPar, int nROW, int nCOL)
+{
+	static UINT32 DIF01[HISDIFNUM]; /* Last one is global */
+	static UINT32 DIF02[HISDIFNUM]; /* Last one is global */
+    /* Dif01 of 5th windows used for 2-2 */
+	static UINT32 DifW5[HISDIFNUM];
+
+	static struct sFlmDatSt pRDat;
+	static int pre22lvl;
+
+	int nDIF01[HISDIFNUM];
+	int nDIF02[HISDIFNUM];
+	/* UINT32 nCb32=0; */
+
+	/* int nRCMB[ROWCMBNUM]; */
+	int mDly = pPar->mPstDlyPre;
+	int mNDly = pPar->mNxtDlySft;
+
+	int nT0 = 0;
+	int nT1 = 0;
+	int nS0 = 0;
+	int nS1 = 0;
+	int nMod = 0;
+
+	/* difference */
+	pRDat.rROFrmDif02 = rROFrmDif02;
+	/* size of the image */
+	pRDat.iHeight = nROW; /* field height */
+	pRDat.iWidth  = nCOL;
+
+	prt_flg = 0;
+	debug_str[0] = '\0';
+
+	/* Initialization */
+	if (field_count < 3) {
+		for (nT1 = 0; nT1 < HISDIFNUM; nT1++) {
+			DIF01[nT1] = 0xffffffff;
+			DIF02[nT1] = 0xffffffff;
+			DifW5[nT1] = 0xffffffff;
+		}
+
+		for (nT1 = 0; nT1 < HISDETNUM; nT1++) {
+			pRDat.pFlg32[nT1] = 0;
+			pRDat.pMod32[nT1] = 0;
+			pRDat.mNum32[nT1] = 0;
+
+			pRDat.pFld32[nT1] = 0;
+			pRDat.pFrm32[nT1] = 0;
+			pRDat.pFrm32t[nT1] = 0;
+
+			pRDat.pFlg22[nT1] = 0;
+			pRDat.pMod22[nT1] = 0;
+			pRDat.mNum22[nT1] = 0;
+
+			pRDat.pStp22[nT1] = 0;
+			pRDat.pSmp22[nT1] = 0;
+
+			/* HISDETNUM hist */
+			pRDat.pModXx[nT1] = 0;
+			pRDat.pFlgXx[nT1] = 0; /* pre-1, nxt-0 */
+			pRDat.pLvlXx[nT1] = 0;  /* mode level */
+		}
+	} else {
+		for (nT1 = 1; nT1 < HISDETNUM; nT1++) {
+			pRDat.mNum32[nT1 - 1] = pRDat.mNum32[nT1];
+			pRDat.mNum22[nT1 - 1] = pRDat.mNum22[nT1];
+		}
+	}
+
+	/* -------------------------------------------------------------- */
+	nS0 = 0;
+	nS1 = 0;
+	/* int rROFrmDif02[6]; // Read only */
+	/* int rROFldDif01[6]; // Read only */
+	for (nT1 = 1; nT1 < HISDIFNUM; nT1++) {
+		DIF01[nT1 - 1] = DIF01[nT1];
+		DIF02[nT1 - 1] = DIF02[nT1];
+		DifW5[nT1-1]   = DifW5[nT1];
+	}
+
+	DIF01[HISDIFNUM - 1] = rROFldDif01[0];	/* 5windows+global */
+	DIF02[HISDIFNUM - 1] = rROFrmDif02[0];	/* 5windows+global */
+
+	if (pr_pd)
+		sprintf(debug_str, "\nField#%5d: [%4dx%4d]\n",
+			field_count, nROW, nCOL);
+
+	prt_flg = (pr_pd & 0x1);
+	if (prt_flg) {
+		sprintf(debug_str + strlen(debug_str), "Dif012=[%u,%u]\n",
+			DIF01[HISDIFNUM - 1], DIF02[HISDIFNUM - 1]);
+
+		for (nT1 = 1; nT1 < 6; nT1++)
+			sprintf(debug_str + strlen(debug_str),
+				"WDif12[%d]=[%u,%u]\n", nT1,
+				rROFldDif01[nT1], rROFrmDif02[nT1]);
+
+		for (nT1 = 0; nT1 < ROWCMBLEN; nT1++)
+			sprintf(debug_str + strlen(debug_str),
+				"rROCmbInf[%d]=%08x\n", nT1,
+				rROCmbInf[nT1]);
+	}
+	if (pr_pd)
+		pr_info("%s", debug_str);
+
+	/* --------------------------------------------------------------- */
+	/* int nDIF01[HISDIFNUM]; */
+	/* int nDIF02[HISDIFNUM]; */
+	for (nT1 = 0; nT1 < HISDIFNUM; nT1++) {
+		nDIF01[nT1] = DIF01[nT1];
+		nDIF02[nT1] = DIF02[nT1];
+	}
+	/* --------------------------------------------------------- */
+	/* Film-Detection */
+	nS1 = FlmDetSft(&pRDat, nDIF01, nDIF02, nT0, pPar);
+
+	nS0 = FlmModsDet(&pRDat, rROFldDif01[0], rROFrmDif02[0]);
+	/* --------------------------------------------------------- */
+
+	/* for panda 2-2 : flag	1, 3 */
+	if (pRDat.pFlg22[HISDETNUM-1] &	0x1) {
+		/* diff01 of the 5th window	*/
+		/* for panda 2-2: VOF */
+		DifW5[HISDIFNUM-1] =
+			(16 * rROFldDif01[5]) / (rROFldDif01[0] + 16);
+		nT1	= (DifW5[HISDIFNUM-1] << 2);
+		if (nS1	> nT1)
+			nS1	-= nT1;	/* reset the 5th window	*/
+
+		pre22lvl = nS1;
+	} else if (pRDat.pFlg22[HISDETNUM-1])
+		nS1	= pre22lvl;
+	else
+		pre22lvl = 0;
+
+	/* Current f(t-0) with previous */
+	/* pFMReg->rCmb32Spcl =0; */
+	*rCmb32Spcl = 0;
+	if (pRDat.pMod32[HISDETNUM - 1] == 3) {
+		nMod = pRDat.pMod32[HISDETNUM - 1];
+		/* nT0 = pRDat.pFlg32[HISDETNUM - 1] % 2; */
+
+		if (pRDat.mNum32[HISDETNUM - 1] < 255)	/* maximum */
+			pRDat.mNum32[HISDETNUM - 1] += 1;
+
+		/* 3-2 film combing special precessing (A-A-A) */
+		if (pRDat.pFlg32[HISDETNUM - 1] == (mNDly % 5))
+			*rCmb32Spcl = 1;
+	} else if (pRDat.pMod22[HISDETNUM - 1] == 2) {
+		nMod = pRDat.pMod22[HISDETNUM - 1];
+		/* nT0 = pRDat.pFlg22[HISDETNUM - 1] % 2; */
+
+		if (pRDat.mNum22[HISDETNUM - 1] < 255)	/* maximum */
+			pRDat.mNum22[HISDETNUM - 1] += 1;
+	} else {
+		nMod = 0;
+
+		pRDat.mNum32[HISDETNUM - 1] = 0;
+		pRDat.mNum22[HISDETNUM - 1] = 0;
+	}
+
+	/* Only frame (t-1) */
+	/* pFMReg->rFlmPstGCm = 0; */
+	*rFlmPstGCm = 0;
+	/* rFlmPstGCm = 1; */
+	if (pRDat.pMod32[HISDETNUM - 1 - mDly] == 3) {
+		nT0 = pRDat.pFlg32[HISDETNUM - 1 - mDly] % 2;
+		*rFlmSltPre = nT0;
+		/* Post-processing: film mode,00: global combing,
+		01: 2-2 film, 10: 2-3 film, 11:-others */
+		*rFlmPstMod = 2;
+		/* param: at least 5 field+5 */
+		if (pRDat.mNum32[HISDETNUM - 1] < flm32_mim_frms) {
+			*rFlmSltPre = 0;
+			*rFlmPstMod = 0;
+		}
+		nS1 = 0;
+	} else if (pRDat.pMod22[HISDETNUM - 1 - mDly] == 2) {
+		nT0 = pRDat.pFlg22[HISDETNUM - 1 - mDly] % 2;
+		*rFlmSltPre = nT0;
+		/* Post-processing: film mode,
+		00: global combing, 01: 2-2 film, 10: 2-3 film, 11:-others */
+		*rFlmPstMod = 1;
+
+		/* param: at least 60 field+4 */
+		if (pRDat.mNum22[HISDETNUM - 1] < flm22_mim_frms) {
+			*rFlmSltPre = 0;
+			*rFlmPstMod = 0;
+		}
+	} else {
+		*rFlmSltPre = 0;
+		/* Post-processing: film mode,00: global combing,
+		01: 2-2 film, 10: 2-3 film, 11:-others */
+		*rFlmPstMod = 0;
+		nS1 = 0;
+	}
+
+	VOFSftTop(rFlmPstGCm, rFlmSltPre, rFlmPstMod,
+		rPstCYWnd0, rPstCYWnd1, rPstCYWnd2, rPstCYWnd3,
+		nMod, rROCmbInf, &pRDat, pPar, nROW, nCOL);
+
+	nT1 = pRDat.pLvlXx[HISDETNUM - 1 - mDly];
+	if ((*rFlmPstMod == 0) && (nT1 > flmxx_maybe_num)
+		&& (nS0 != 6) && (pRDat.pMod22[HISDETNUM - 1 - mDly] != 2)) {
+		*rFlmSltPre = pRDat.pFlgXx[HISDETNUM - 1 - mDly];
+		*rFlmPstMod = 4 + pRDat.pModXx[HISDETNUM - 1 - mDly];
+		nS1 = pRDat.pLvlXx[HISDETNUM - 1 - mDly];
+	}
+
+	*tTCNm = pRDat.TCNm[HISCMBNUM - 1];
+	return nS1;
+}
+
+/* Film Detection Software implementation */
+/* nDif01: Field Difference */
+/* nDif02: Frame Difference */
+/* WND: The index of Window */
+int FlmDetSft(struct sFlmDatSt *pRDat, int *nDif01, int *nDif02,
+	      int WND, struct sFlmSftPar *pPar)
+{
+	int nT0 = 0;
+
+	/* 3-2 */
+	Flm32DetSft(pRDat, nDif02, nDif01, pPar);
+
+	/* Film2-2 Detection */
+	/* debug0304 */
+	nT0 = Flm22DetSft(pRDat, nDif02, nDif01, pPar);
+	/* ---------------------------------------- */
+	prt_flg = 0;
+	return nT0;
+}
+
+/* pFlm02[0:nLEN-1] : recursive, 0-2 dif */
+/* pFlm01[0:nLEN-1] : recursive, 0-1 dif */
+int Flm32DetSft(struct sFlmDatSt *pRDat, int *nDif02,
+		int *nDif01, struct sFlmSftPar *pPar)
+{
+	int sFrmDifAvgRat = pPar->sFrmDifAvgRat;	/* 16;  //0~32 */
+	/*  The Large Decision should be: (large>average+LgDifThrd) */
+	int sFrmDifLgTDif = pPar->sFrmDifLgTDif; /* 4096 */
+	int sF32StpWgt01 = pPar->sF32StpWgt01;	/* 15; */
+	int sF32StpWgt02 = pPar->sF32StpWgt02;	/* 15; */
+	int sF32DifLgRat = pPar->sF32DifLgRat;	/* 16; Dif>Rat*Min-->Larger */
+
+	/* int sF32DifSmRat = 16;  //Dif*Rat<Max  --> Smaller */
+
+	UINT8 *pFlm02 = pRDat->pFrm32;
+	UINT8 *pFlm02t = pRDat->pFrm32t;
+	UINT8 *pFlm01 = pRDat->pFld32;
+	UINT8 *pFlg32 = pRDat->pFlg32;
+
+	static UINT8 sFld32[6] = { 0, 0, 0, 0, 0, 0 };
+
+	UINT8 FIX02[2][5] = { {2, 3, 4, 5, 1}, {4, 5, 1, 2, 3} };
+
+	int nT0 = 0;
+	int nT1 = 0;
+	int nT2 = 0;
+
+	int nMn = nDif02[HISDIFNUM - 1];
+	int nMx = nDif02[HISDIFNUM - 1];
+	int nSM = nDif02[HISDIFNUM - 1];
+	UINT8 nFlg01[6] = { 0, 0, 0, 0, 0, 0 };
+	UINT8 nFlg02[6] = { 0, 0, 0, 0, 0, 0 };
+	UINT8 nFlg12[6] = { 0, 0, 0, 0, 0, 0 };
+
+	int nAV10 = 0;
+	int nAV11 = 0;
+	int nAV12 = 0;
+	int nAV1 = 0;
+	int nSTP = 0;
+	UINT8 nMIX = 0;
+
+	int nFlgChk1 = 0;
+	int nFlgChk2 = 0;
+	int nFlgChk3 = 0; /* for Mit32VHLine */
+
+	prt_flg = ((pr_pd >> 2) & 0x1);
+	if (prt_flg)
+		sprintf(debug_str, "#Dbg32:\n");
+
+	/* ---------------------------------- */
+	/* Get min/max from the last fives */
+	for (nT0 = 2; nT0 <= 5; nT0++) {
+		nT1 = nDif02[HISDIFNUM - nT0];
+		nSM += nT1;
+
+		if (nT1 < nMn)
+			nMn = nT1;
+
+		if (nT1 > nMx)
+			nMx = nT1;
+	}
+	nAV10 = ((nSM - nMx + 2) >> 2);
+	nAV12 = ((nSM + 3 * nMn + 4) >> 3);
+
+	nSM = 0;
+	nT2 = 0;
+	for (nT0 = 1; nT0 <= 5; nT0++) {
+		nT1 = nDif02[HISDIFNUM - nT0];
+		if (nT1 >= nAV10) {
+			nT2 += 1;
+			nSM += nT1;
+		}
+	}
+	nAV11 = (nSM - nMx + nT2 / 2) / (nT2 - 1);
+
+	nAV1 = (sFrmDifAvgRat * nAV11 + (32 - sFrmDifAvgRat) * nAV12);
+	nAV1 = ((nAV1 + 16) >> 5);
+
+	/* for Mit32VHLine */
+	if (nDif02[HISDIFNUM-1] > nDif02[HISDIFNUM-6])
+		nFlgChk1 = nDif02[HISDIFNUM-1] - nDif02[HISDIFNUM-6];
+	else
+		nFlgChk1 = nDif02[HISDIFNUM-6] - nDif02[HISDIFNUM-1];
+
+	/* if (pFlg32[HISDETNUM-1] == 4) { */
+	/* B-B A-A-A X-Y-Z */
+	/* ---------=>Sceen changed */
+	if (pFlg32[HISDETNUM-1] == 4 || pFlg32[HISDETNUM-1] == 5) {
+		nFlgChk3 = nFlgChk1;
+		for (nT0 = 2; nT0 <= 5; nT0++) {
+			nFlgChk2 = nDif02[HISDIFNUM-nT0]
+					- nDif02[HISDIFNUM-nT0-5];
+			if (nFlgChk2 < 0)
+				nFlgChk2 = -nFlgChk2;
+
+			/* 5-loop: maximum */
+			if (nFlgChk2 > nFlgChk3)
+				nFlgChk3 = nFlgChk2;
+		}
+		nFlgChk3 = 16 * nFlgChk3 / nAV1;
+	} else
+		nFlgChk3 = 255;
+	/* for Mit32VHLine */
+
+	if (pFlg32[HISDETNUM - 1] == 2 || pFlg32[HISDETNUM - 1] == 4
+		|| pFlg32[HISDETNUM - 1] == 3) {
+		/* ========================================== */
+		if (nDif02[HISDIFNUM - 2] > nDif02[HISDIFNUM - 7])
+			nFlgChk2 =
+			    nDif02[HISDIFNUM - 2] - nDif02[HISDIFNUM - 7];
+		else
+			nFlgChk2 =
+			    nDif02[HISDIFNUM - 7] - nDif02[HISDIFNUM - 2];
+
+		if (nFlgChk1 > nFlgChk2)
+			nFlgChk2 = nFlgChk1 - nFlgChk2;
+		else
+			nFlgChk2 = nFlgChk2 - nFlgChk1;
+
+		nFlgChk2 = 16 * nFlgChk2 / nAV1;
+		/* ============================================ */
+
+		/* please check the DI-skateboard */
+		/* the next should be 1 and 3 */
+		/* dif02(flg=2 vs 1) almost same */
+		/* dif02(flg=4 vs 3) almost same */
+		if (nDif02[HISDIFNUM - 1] > nDif02[HISDIFNUM - 2])
+			nFlgChk1 =
+			    nDif02[HISDIFNUM - 1] - nDif02[HISDIFNUM - 2];
+		else
+			nFlgChk1 =
+			    nDif02[HISDIFNUM - 2] - nDif02[HISDIFNUM - 1];
+
+		nFlgChk1 = 16 * nFlgChk1 / nAV1;
+
+		if (prt_flg)
+			sprintf(debug_str + strlen(debug_str),
+				"nFlgChk1/2/3=(%2d,%2d,%02d)\n",
+			    nFlgChk1, nFlgChk2, nFlgChk3);
+	} else {
+		nFlgChk1 = 0;
+		nFlgChk2 = 0;
+	}
+	/* ============================================= */
+
+	nT2 = 5 * nDif02[HISDIFNUM - 1] / (nMn + sFrmDifLgTDif + 1);
+	nT2 = nT2>>1;
+	if (nMn <= (1 << flm32_f2fdif_min0)) {
+		nSTP = nT2;
+	} else {
+		nSTP =
+		    16 * (nDif02[HISDIFNUM - 1] - nMn) + (nAV1 - nMn +
+							  sFrmDifLgTDif) / 2;
+		nSTP = nSTP / (nAV1 - nMn + sFrmDifLgTDif);
+
+		/* ======================== */
+		/* patch for DI1 3:2, [ 16 16 9 16 0] */
+		if (nT2 > nSTP)
+			nSTP = nT2;
+		/* ======================== */
+	}
+
+	if (nSTP > 16)
+		nSTP = 16;
+
+	for (nT0 = 1; nT0 < HISDETNUM; nT0++) {
+		pFlm02[nT0 - 1] = pFlm02[nT0];
+		pFlm02t[nT0 - 1] = pFlm02t[nT0];
+	}
+
+	if (nDif02[HISDIFNUM - 1] > (nMn + sFrmDifLgTDif) * sF32DifLgRat) {
+		pFlm02t[HISDETNUM - 1] =
+		    nDif02[HISDIFNUM - 1] / (nMn + sFrmDifLgTDif);
+	} else {
+		pFlm02t[HISDETNUM - 1] = nSTP;
+	}
+
+	pFlm02[HISDETNUM - 1] = nSTP;
+
+	/* -------------------------------- */
+	nMn = pFlm02[HISDETNUM - 1];
+	nMIX = 5;
+	for (nT0 = 0; nT0 < 6; nT0++) {
+		nFlg02[5 - nT0] = pFlm02[HISDETNUM - 1 - nT0];
+		if (nFlg02[5 - nT0] < nMn && nT0 <= 4) {
+			nMn = nFlg02[5 - nT0];
+			nMIX = 5 - nT0;
+		}
+	}
+	nFlg02[nMIX] = 16 - nFlg02[nMIX];
+	if (nMIX == 5)
+		nFlg02[0] = 16 - nFlg02[0];
+
+	/* -------------------------------------------- */
+	/* field difference */
+	/* pFlm01 */
+	/* length of pFlm01/nDif01: [0:5]; */
+	/* iDx: index of minimum dif02 ([0:5] */
+	Cal32Flm01(pFlm01, nDif01, nMIX, pPar);
+	for (nT0 = 0; nT0 < 6; nT0++) {
+		if ((nT0 == FIX02[0][nMIX - 1]) || (nT0 == FIX02[1][nMIX - 1]))
+			nFlg01[nT0] = pFlm01[HISDETNUM - 6 + nT0];
+		else
+			nFlg01[nT0] = 16 - pFlm01[HISDETNUM - 6 + nT0];
+	}
+
+	if (FIX02[0][nMIX - 1] == 5 || FIX02[1][nMIX - 1] == 5)
+		nFlg01[0] = pFlm01[HISDETNUM - 6];
+
+	/* A-A-A B-B C-C-C D-D E-E-E */
+	/* 0-1-1 0-0 0-1-1 0-0 */
+	for (nT0 = 0; nT0 < 6; nT0++) {
+
+		if (nMIX == 1 && nT0 == 5) {
+			nSTP =
+			    sF32StpWgt02 * nFlg02[nT0] + (16 -
+							  sF32StpWgt02) *
+			    nFlg01[nT0];
+		} else if (nMIX == 5 && nT0 == 0) {
+			nSTP =
+			    sF32StpWgt02 * nFlg02[nT0] + (16 -
+							  sF32StpWgt02) *
+			    nFlg01[nT0];
+		} else if (nT0 == nMIX || nT0 == nMIX - 1) {
+			nSTP =
+			    sF32StpWgt02 * nFlg02[nT0] + (16 -
+							  sF32StpWgt02) *
+			    nFlg01[nT0];
+		} else {
+			nSTP =
+			    sF32StpWgt01 * nFlg01[nT0] + (16 -
+							  sF32StpWgt02) *
+			    nFlg02[nT0];
+		}
+
+		nFlg12[nT0] = ((nSTP + 8) >> 4);
+	}
+	/* -------------------------------------------- */
+
+	/* -------------------------------------------- */
+	Flm32DetSub1(pRDat, nFlg12, pFlm02t, nFlg01, nFlg02, nMIX);
+	/* -------------------------------------------- */
+
+	/* 150213-patch */
+	nSTP = pRDat->pFrm32[HISDETNUM - 6 + nMIX];
+	for (nT1 = 5; nT1 > 0; nT1--) {
+		if (nT1 != nMIX)
+			nSTP += (16 - pRDat->pFrm32[HISDETNUM - 6 + nT1]);
+	}
+
+	if (nMn < (1 << flm32_f2fdif_min1) && nSTP <= 2) {
+		nSTP = 0;
+		for (nT1 = 4; nT1 >= 0; nT1--) {
+			if (sFld32[nT1] >= pRDat->pFld32[HISDETNUM - 6 + nT1]) {
+				nSTP +=
+				    (sFld32[nT1] -
+				     pRDat->pFld32[HISDETNUM - 6 + nT1]);
+			} else {
+				nSTP +=
+				    (pRDat->pFld32[HISDETNUM - 6 + nT1] -
+				     sFld32[nT1]);
+			}
+		}
+
+		if (nSTP <= 2) {
+			pRDat->pMod32[HISDETNUM - 1] = 3;
+			pRDat->pFlg32[HISDETNUM - 1] = nMIX;
+		}
+	}
+
+	for (nT1 = 1; nT1 <= 5; nT1++)
+		sFld32[nT1 - 1] = sFld32[nT1];
+
+	sFld32[5] = pRDat->pFld32[HISDETNUM - 5];
+	/* -------------------------------------------- */
+
+	/* ============================================= */
+	/* please check the DI-skateboard */
+	/* the next should be 1 and 3 */
+	/* dif02(flg=2 vs 1) almost same */
+	/* dif02(flg=4 vs 3) almost same */
+	/* nFlgChk3: for Mit32VHLine */
+	/* last: for sceen change */
+	if (((nFlgChk1 > flm32_chk1_rtn) &&
+		(nFlgChk3 > flm32_ck13_rtn))
+		|| (nFlgChk2 > flm32_chk2_rtn)
+		|| ((pFlg32[HISDETNUM-1] == 4) &&
+		(nFlgChk3 > flm32_chk3_rtn))) {
+		pRDat->pMod32[HISDETNUM - 1] = 0;
+		pRDat->pFlg32[HISDETNUM - 1] = 0;
+
+		if (prt_flg)
+			sprintf(debug_str + strlen(debug_str),
+			"Reg: ck1=%d, ck13=%d, ck2=%d, ck3=%d\n",
+			flm32_chk1_rtn, flm32_ck13_rtn,
+			flm32_chk2_rtn, flm32_chk3_rtn);
+	}
+	/* ============================================= */
+
+	if (prt_flg) {
+		sprintf(debug_str + strlen(debug_str),
+			"Mod=%d, Flg=%d, Num=%3d\n",
+			pRDat->pMod32[HISDETNUM - 1],
+			pRDat->pFlg32[HISDETNUM - 1],
+			pRDat->mNum32[HISDETNUM - 1]);
+		pr_info("%s", debug_str);
+	}
+
+	return 0;
+}
+
+/* length of pFlm01/nDif01: [0:5]; */
+/* iDx: index of minimum dif02 ([0:5] */
+int Cal32Flm01(UINT8 *pFlm01, int *nDif01, int iDx,
+		struct sFlmSftPar *pPar)
+{
+	int sF32Dif01A1 = pPar->sF32Dif01A1;	/* 65; */
+	int sF32Dif01T1 = pPar->sF32Dif01T1;	/* 128; */
+
+	int sF32Dif01A2 = pPar->sF32Dif01A2;	/* 65; */
+	int sF32Dif01T2 = pPar->sF32Dif01T2;	/* 128; */
+
+	int dDif05[5]; /* patch for MIT32-Line */
+
+	int nT0 = 0;
+	int nT1 = 0;
+	/* int nT2=0; */
+	int nSP = 0;
+
+	int CP = nDif01[HISDIFNUM - 1];	/* Last */
+	int PP = nDif01[HISDIFNUM - 2];	/* Prev */
+
+	int nMn = ((CP < PP) ? CP : PP);
+	int nMx = ((CP > PP) ? CP : PP);
+
+	for (nT0 = 0; nT0 < HISDETNUM - 1; nT0++)
+		pFlm01[nT0] = pFlm01[nT0 + 1];
+
+	nSP = nDif01[HISDIFNUM-1];
+	for (nT0 = 0; nT0 < 5; nT0++) {
+		if (nDif01[HISDIFNUM-1-nT0] >= nDif01[HISDIFNUM-6-nT0])
+			dDif05[nT0] = nDif01[HISDIFNUM-1-nT0]
+				- nDif01[HISDIFNUM-6-nT0];
+		else
+			dDif05[nT0] = nDif01[HISDIFNUM-6-nT0]
+				- nDif01[HISDIFNUM-1-nT0];
+
+		if (nDif01[HISDIFNUM-1-nT0] < nSP)
+			nSP = nDif01[HISDIFNUM-1-nT0];
+	}
+
+	for (nT0 = 0; nT0 < 5; nT0++)
+		dDif05[nT0] = 8 * dDif05[nT0] / (nSP + 1024);
+
+
+	if (iDx == 5) {
+		/* Last three */
+		if (nDif01[HISDIFNUM - 3] > nMx)
+			nMx = nDif01[HISDIFNUM - 3];
+
+		if (nDif01[HISDIFNUM - 3] < nMn)
+			nMn = nDif01[HISDIFNUM - 3];
+
+		nSP = 16 * (CP - nMn) + (nMx - nMn) / 2;
+		nSP = nSP / (nMx - nMn + 1);
+		if (nSP > 16)
+			nSP = 16;
+
+		pFlm01[HISDETNUM - 1] = nSP;
+	} else if (iDx == 4) {
+		nT0 = sF32Dif01T1 + ((CP * sF32Dif01A1 + 32) >> 6); /* x/64 */
+		nT1 = sF32Dif01T1 + ((PP * sF32Dif01A1 + 32) >> 6); /* x/64 */
+
+		if (nT0 <= PP) {
+			pFlm01[HISDETNUM - 1] = 0;
+			pFlm01[HISDETNUM - 2] = 16;
+		} else if (nT1 <= CP) {
+			pFlm01[HISDETNUM - 2] = 0;
+			pFlm01[HISDETNUM - 1] = 16;
+		} else {
+			pFlm01[HISDETNUM - 2] = 8;	/* overlap */
+			pFlm01[HISDETNUM - 1] = 8;	/* overlap */
+		}
+	} else {
+		nT0 = sF32Dif01T2 + ((CP * sF32Dif01A2 + 32) >> 6); /* x/64 */
+		nT1 = sF32Dif01T2 + ((PP * sF32Dif01A2 + 32) >> 6); /* x/64 */
+
+		if (nT0 <= PP)
+			pFlm01[HISDETNUM - 1] = 0;
+		else if (nT1 <= CP)
+			pFlm01[HISDETNUM - 1] = 16;
+		else
+			pFlm01[HISDETNUM - 1] = 8;	/* overlap */
+	}
+
+	nSP = dDif05[0];
+	for (nT0 = 1; nT0 < 5; nT0++) {
+		if (nSP < dDif05[nT0])
+			nSP = dDif05[nT0]; /* maximum */
+	}
+	if (nSP <= 3) {
+		if (iDx == 2) {
+			pFlm01[HISDETNUM-1] = 16;
+			pFlm01[HISDETNUM-2] = 0;
+		} else if (iDx == 1) {
+			pFlm01[HISDETNUM-1] = 0;
+			pFlm01[HISDETNUM-2] = 16;
+		}
+	}
+
+	return 0;
+}
+
+/* length: [0:5] */
+/* MIX: [1~5] */
+int Flm32DetSub1(struct sFlmDatSt *pRDat, UINT8 *nFlg12, UINT8 *pFlm02t,
+		 UINT8 *nFlg01, UINT8 *nFlg02, UINT8 MIX)
+{
+	UINT8 *pFlg = pRDat->pFlg32;
+	UINT8 *pMod = pRDat->pMod32;
+
+	int CFg = pFlg[HISDETNUM - 1];
+	int RFlg[5] = { 5, 1, 2, 3, 4 };
+	int nT0 = 0;
+	int CNT = 0;
+
+	UINT8 MN0 = nFlg12[5];
+	UINT8 MN1 = nFlg01[5];
+	UINT8 MN2 = nFlg02[5];
+
+	int ID0 = 0;
+	int ID1 = 0;
+
+	for (nT0 = 5; nT0 >= 0; nT0--) {
+		if (pMod[nT0] == 3)
+			CNT++;
+		else
+			break;
+	}
+
+	for (nT0 = 0; nT0 < HISDETNUM - 1; nT0++) {
+		pMod[nT0] = pMod[nT0 + 1];
+		pFlg[nT0] = pFlg[nT0 + 1];
+	}
+
+	for (nT0 = 0; nT0 < 5; nT0++) {
+		if (nFlg12[nT0] < MN0)
+			MN0 = nFlg12[nT0];
+
+		if (nFlg01[nT0] < MN1)
+			MN1 = nFlg01[nT0];
+
+		if (nFlg02[nT0] < MN2)
+			MN2 = nFlg02[nT0];
+	}
+
+	if (CFg == 0 && MN0 >= 10 && MN1 >= 10 && MN2 >= 10) {
+		pMod[HISDETNUM - 1] = 3;
+		pFlg[HISDETNUM - 1] = MIX;
+	} else if (CFg != 0 && RFlg[CFg - 1] == MIX && MN0 >= 8) {
+		pMod[HISDETNUM - 1] = 3;
+		pFlg[HISDETNUM - 1] = MIX;
+		if (CNT <= 2 && (MN1 <= 8 || MN2 <= 8))
+			pFlg[HISDETNUM - 1] = 0;
+	} else {
+		pMod[HISDETNUM - 1] = 0;
+		pFlg[HISDETNUM - 1] = 0;
+
+		MN0 = pFlm02t[HISDETNUM - 1];
+		MN1 = pFlm02t[HISDETNUM - 1];
+		ID0 = 5;
+		ID1 = 5;
+		for (nT0 = 4; nT0 >= 1; nT0--) {
+			if (pFlm02t[HISDETNUM - 6 + nT0] < MN0) {
+				MN1 = MN0;
+				ID1 = ID0;
+				MN0 = pFlm02t[HISDETNUM - 6 + nT0];
+				ID0 = nT0;
+			} else if (pFlm02t[HISDETNUM - 6 + nT0] < MN1) {
+				MN1 = pFlm02t[HISDETNUM - 6 + nT0];
+				ID1 = nT0;
+			}
+		}
+
+		MIX = ID0;
+		if (ID0 == 5 && ID1 == 5) {
+			if (pFlm02t[HISDETNUM - 6] > MN0)
+				MN0 = pFlm02t[HISDETNUM - 6];
+
+			CNT = 0;
+			for (nT0 = 1; nT0 <= 4; nT0++) {
+				if (pFlm02t[HISDETNUM - 6 + nT0] >
+				    (MN0 + 2) * 32) {
+					CNT++;
+				}
+			}
+
+			if (CNT == 4) {
+				if (CFg == 0) {
+					pMod[HISDETNUM - 1] = 3;
+					pFlg[HISDETNUM - 1] = MIX;
+				} else if (RFlg[CFg - 1] == MIX) {
+					pMod[HISDETNUM - 1] = 3;
+					pFlg[HISDETNUM - 1] = MIX;
+				}
+			}
+		} else if (MN1 > (MN0 + 2) * 32) {
+			/* All >64 */
+			if (ID0 != 5) {
+				if (CFg == 0) {
+					pMod[HISDETNUM - 1] = 3;
+					pFlg[HISDETNUM - 1] = MIX;
+				} else if (RFlg[CFg - 1] == MIX) {
+					pMod[HISDETNUM - 1] = 3;
+					pFlg[HISDETNUM - 1] = MIX;
+				}
+			}	/* if(ID0!=5) */
+		}		/* if(MN1>(MN0+2)*32) */
+	}
+
+	return 0;
+}
+
+/* Film2-2 Detection */
+int Flm22DetSft(struct sFlmDatSt *pRDat, int *nDif02,
+			int *nDif01, struct sFlmSftPar *pPar)
+{
+	UINT8 *pFlg = pRDat->pFlg22;
+	UINT8 *pMod = pRDat->pMod22;
+
+	UINT8 *pStp = pRDat->pStp22;
+	UINT8 *pSmp = pRDat->pSmp22;
+	UINT8 *mNum22 = pRDat->mNum22;
+
+	int sFlm2MinAlpha = pPar->sFlm2MinAlpha;	/* 32; // [0~63] */
+	int sFlm2MinBelta = pPar->sFlm2MinBelta;	/* 32; // [0~63] */
+	int sFlm20ftAlpha = pPar->sFlm20ftAlpha;	/* 16; // [0~63] */
+	int sFlm2LgDifThd = pPar->sFlm2LgDifThd;	/* 4096; */
+	int sFlm2LgFlgThd = pPar->sFlm2LgFlgThd;	/* 8; */
+
+	int cFlg = pFlg[HISDETNUM - 1];
+	int rFlg[4] = { 2, 3, 4, 1 };
+
+	int nT0 = 0;
+	int nT1 = 0;
+	int CNT0 = 0;
+	int CNT1 = 0;
+
+	int nMn = nDif01[HISDIFNUM - 1];
+	int nMx = nDif01[HISDIFNUM - 1];
+
+	int nSM20 = nDif01[HISDIFNUM - 1];
+	int nSM21 = 0;
+	int nSM22 = 0;
+	int nL21 = 0;
+	int nL22 = 0;
+	int Mx56 = 0;
+	int Mn56 = 0;
+
+	int nAV20 = 0;
+	int nAV21 = 0;
+	int nAV22 = 0;
+	int nOfst = 0;
+	int tMgn = 0;
+	int BtMn = 0;
+
+	int FdTg[6];
+
+	int nFlgChk1 = 0; /* chk1 */
+	int nFlgCk20 = 0; /* chk2-0 */
+	int nFlgCk21 = 0; /* chk2-1 */
+	int nFlgChk3 = 0; /* chk3 */
+	int nFlgChk4 = 0; /* chk4 */
+	int nFlgChk5 = 0; /* chk5 */
+	int nFlgChk6 = 0; /* dif02-small */
+
+	static UINT8 nCk20Cnt;
+	static UINT8 nCk21Cnt;
+	/* check 2-2: for panda sequence */
+	/* static UINT8 nCk22Flg[HISDETNUM]; */
+	/* static UINT8 nCk22Cnt; */
+
+	/* size of image */
+	int iWidth  = pRDat->iWidth;
+	int iHeight = pRDat->iHeight;
+	int nFlm22Lvl = 0;
+	int nSIZE = iWidth * iHeight + 1;
+
+	prt_flg = ((pr_pd >> 3) & 0x1);
+	if (prt_flg)
+		sprintf(debug_str, "#Dbg22:\n");
+
+	for (nT0 = 0; nT0 < HISDETNUM - 1; nT0++) {
+		pFlg[nT0] = pFlg[nT0 + 1];
+		pMod[nT0] = pMod[nT0 + 1];
+		pStp[nT0] = pStp[nT0 + 1];
+		pSmp[nT0] = pSmp[nT0 + 1];
+		/* nCk22Flg[nT0] = nCk22Flg[nT0+1]; */
+	}
+
+	/* ========== check1/3 2-2 mode  ========== */
+	/* |dif02(t-1) - dif02(t-0)| => should be small */
+	/* |dif01(t-1) - (dif01(t)+dif02(t))| => should be small */
+	nFlgChk1 = 0;
+	nFlgChk3 = 0;
+	nAV20 = 0;
+	if (pFlg[HISDETNUM-1] == 0) {
+		nFlgChk1 = 255;
+		nFlgChk3 = 255;
+		nFlgChk4 = 0;
+		/* nCk22Cnt = 0; */
+	} else if (pFlg[HISDETNUM-1] == 2
+			|| pFlg[HISDETNUM-1] == 4) {
+		for (nT0 = 1; nT0 <= 7; nT0 = nT0+2) {
+			if (nDif02[HISDIFNUM-nT0] > nDif02[HISDIFNUM-nT0-1]) {
+				nOfst = nDif02[HISDIFNUM-nT0]
+					- nDif02[HISDIFNUM-nT0-1];
+				nAV20 = nAV20 + nDif02[HISDIFNUM-nT0-1];
+			} else {
+				nOfst = nDif02[HISDIFNUM-nT0-1]
+					- nDif02[HISDIFNUM-nT0];
+				nAV20 = nAV20 + nDif02[HISDIFNUM-nT0];
+			}
+
+			/* maximum */
+			if (nOfst > nFlgChk1)
+				nFlgChk1 = nOfst;
+
+			tMgn = nDif02[HISDIFNUM-nT0]+nDif01[HISDIFNUM-nT0];
+			if (tMgn > nDif01[HISDIFNUM-nT0-1])
+				BtMn = tMgn - nDif01[HISDIFNUM-nT0-1];
+			else
+				BtMn = nDif01[HISDIFNUM-nT0-1] - tMgn;
+
+			if (BtMn > nFlgChk3)
+				nFlgChk3 = BtMn;
+
+		}
+		nAV20 = nAV20>>2;
+		nFlgChk1 = 16*nFlgChk1/(nAV20+1024);
+		nFlgChk3 = 16*nFlgChk3/(nAV20+1024);
+		if (nAV20 < (nSIZE >> flm22_stl_sft))
+			mNum22[HISDETNUM-1] = 0; /* static sequence */
+
+		if (prt_flg)
+			sprintf(debug_str + strlen(debug_str),
+			"nAV20(%04d) < (%04d)\n",
+			nAV20, (nSIZE >> flm22_stl_sft));
+	} else {
+		nFlgChk1 = 0;
+		nFlgChk3 = 0;
+
+		for (nT0 = 1; nT0 <= 8; nT0 = nT0 + 2) {
+			if (nDif02[HISDIFNUM-nT0] > nDif01[HISDIFNUM-nT0])
+				nFlgChk4++;
+		}
+	}
+	/* ========== check1/3 2-2 mode  ========== */
+
+	for (nT0 = 2; nT0 <= 4; nT0++) {
+		nT1 = nDif01[HISDIFNUM - nT0];
+
+		nSM20 += nT1;
+
+		if (nMx < nT1)
+			nMx = nT1;
+
+		if (nMn > nT1)
+			nMn = nT1;
+	}
+	/* sum(0~5), last-6 */
+	nSM20 += (nDif01[HISDIFNUM - 5] + nDif01[HISDIFNUM - 6]);
+	nAV20 = (nSM20 - nMx + 2) / 5;
+
+	nFlgChk6 = 0;
+	for (nT0 = 1; nT0 <= 6; nT0++) {
+		nT1 = nDif01[HISDIFNUM - nT0];
+		if (nT1 >= nAV20) {
+			nL21 += 1;
+			nSM21 += nT1;
+		}
+
+		if (nT1 <= nAV20) {
+			nL22 += 1;
+			nSM22 += nT1;
+		}
+		nFlgChk6 += (nDif02[HISDIFNUM-nT0] >> 8);
+	}
+	nFlgChk6 = nFlgChk6 / 6;
+
+	nAV21 = (nSM21 + nL21 / 2) / nL21;	/* High average */
+	nAV22 = (nSM22 + nL22 / 2) / nL22;	/* Low average */
+	nOfst = nAV21 - nAV22;
+
+	if (prt_flg)
+		sprintf(debug_str + strlen(debug_str),
+		"LAvg=%04d\n", (nAV22/nSIZE));
+
+	if (nAV22 > (nSIZE << 3))
+		mNum22[HISDETNUM - 1] = 0;
+	else if (nAV22 > (nSIZE * flm22_lavg_lg >> 3))
+		mNum22[HISDETNUM - 1] = 0;
+
+	/* ========== check2 2-2 mode  ========== */
+	/* |dif01(t-0) - dif01(t-2)| => should be small */
+	/* |dif01(t-0) - dif01(t-4)| => should be small */
+	nFlgCk20 = 0;
+	nFlgCk21 = 0;
+	for (nT0 = 1; nT0 <= 4; nT0++) {
+		nOfst = nDif01[HISDIFNUM-nT0] - nDif01[HISDIFNUM-nT0-2];
+		if (nOfst < 0)
+			nOfst = -nOfst;
+		if (nOfst > nFlgCk20) /* maximum */
+			nFlgCk20 = nOfst;
+
+		nOfst = nDif01[HISDIFNUM-nT0] - nDif01[HISDIFNUM-nT0-4];
+		if (nOfst < 0)
+			nOfst = -nOfst;
+		if (nOfst > nFlgCk21) /* maximum */
+			nFlgCk21 = nOfst;
+	}
+	nFlgCk20 = 16*nFlgCk20/(nAV22+1024);
+	nFlgCk21 = 16*nFlgCk21/(nAV22+1024);
+
+	if (nFlgCk20 < flm22_chk20_sml) {
+		if (nCk20Cnt < 255)
+			nCk20Cnt++;
+	} else
+		nCk20Cnt = 0;
+
+	if (nFlgCk21 < flm22_chk21_sml) {
+		if (nCk21Cnt < 255)
+			nCk21Cnt++;
+	} else
+		nCk21Cnt = 0;
+
+	/* ========== check2 2-2 mode  ========== */
+
+	/* ------------------------------ */
+	/* Max or min of (5/6) */
+	if (nDif01[HISDIFNUM - 1] > nDif01[HISDIFNUM - 2]) {
+		Mx56 = nDif01[HISDIFNUM - 1];
+		Mn56 = nDif01[HISDIFNUM - 2];
+	} else {
+		Mx56 = nDif01[HISDIFNUM - 2];
+		Mn56 = nDif01[HISDIFNUM - 1];
+	}
+	/* ------------------------------ */
+
+	CNT0 = 0;
+	for (nT0 = 5; nT0 >= 0; nT0--) {
+		if (pMod[HISDETNUM - 6 + nT0] == 2)
+			CNT0++;
+		else
+			break;
+	}
+
+	if (CNT0 >= 1) {
+		sFlm20ftAlpha = sFlm20ftAlpha - ((CNT0 * 25 + 8) >> 4);
+		sFlm2MinBelta = sFlm2MinBelta - ((CNT0 * 36 + 8) >> 4);
+	}
+
+	/* water girl: part-2 */
+	if (nCk21Cnt < flm22_chk21_sm2) {
+		nT0 = sFlm2MinAlpha*Mn56+sFlm20ftAlpha*nOfst;
+		tMgn = ((nT0+16)>>5);
+
+		nT1 = sFlm2MinBelta*Mn56;
+		BtMn = ((nT1+32)>>6);
+
+		/* ----------------------------------- */
+		/* int *pStp = pRDat->pStp22; */
+		/* int *pSmp = pRDat->pSmp22; */
+		nT0 = 16*(Mx56-tMgn) + (BtMn+sFlm2LgDifThd)/2;
+		nT1 = nT0/(BtMn+sFlm2LgDifThd);
+		if (nT1 > 16)
+			nT1 = 16;
+		else if (nT1 < 0)
+			nT1 = 0;
+	} else {
+		nT1 = 16;
+	}
+
+	pStp[HISDETNUM - 1] = nT1;
+	if (Mx56 == nDif01[HISDIFNUM - 1])
+		pSmp[HISDETNUM - 1] = 1;
+	else
+		pSmp[HISDETNUM - 1] = 0;
+
+	/* ------------------------------------ */
+	CNT0 = 0;
+	CNT1 = 0;
+	for (nT0 = 0; nT0 < 6; nT0++) {
+		if (pStp[HISDETNUM - 6 + nT0] >= sFlm2LgFlgThd) {
+			FdTg[CNT0] = nT0;
+			CNT0++;
+		}
+		CNT1 += pSmp[HISDETNUM - 6 + nT0];
+	}
+
+	nT0 = 0;
+	nT1 = 0;
+	nFlgChk5 = 0;
+	if (CNT0 == 6 && CNT1 == 3) {
+		if (pSmp[HISDETNUM - 6] && pSmp[HISDETNUM - 4] &&
+			pSmp[HISDETNUM - 2]) {
+			nT1 = 2;
+			if (cFlg != 0) {
+				if (cFlg % 2 == 0)
+					nT0 = rFlg[cFlg - 1];
+			} else {
+				nT0 = 1;
+			}
+		} else if (pSmp[HISDETNUM - 5] && pSmp[HISDETNUM - 3] &&
+			pSmp[HISDETNUM - 1]) {	/* All 1 */
+			nT1 = 2;
+			if (cFlg != 0) {
+				if (cFlg % 2 == 1)
+					nT0 = rFlg[cFlg - 1];
+			} else {
+				nT0 = 4;
+			}
+		}
+
+		/* --------------------------------------- */
+		/* patch for toilet paper */
+		/* Low average avg>(totoal*x) x>1 */
+		/* tMgn = (nAV22 * 64) >> 8; */
+		/* if(tMgn > 720*240) */
+		/* if(tMgn > iWidth*iHeight*32) */ /*toilet paper*/
+		/* parameter */
+		nOfst = nAV21 - nAV22;
+		if (nAV22 > (nSIZE << flm22_lavg_sft)) /* low average */
+			nFlgChk5 = 16;
+		else if ((nAV22 << 4) > (nSIZE * flm22_chk5_avg))
+			nFlgChk5 = nAV22 / nSIZE;
+		else if (nOfst < ((nAV22 * 46) >> 7))
+			nFlgChk5 = (nAV22 << 2) / (nOfst + 32);
+
+		if (nFlgChk5 > 32)
+			nFlgChk5 = 32;
+		/* --------------------------------------- */
+
+		nL22 = (nSIZE >> 9) + 1;
+		if (nFlgChk6 < nL22)
+			nFlgChk6 = nL22 / (nFlgChk6 + 1);
+		else if (nFlgChk6 > (nL22 << 1))
+			nFlgChk6 = nFlgChk6 / nL22;
+		else
+			nFlgChk6 = 0;
+
+		if (nFlgChk6 > flm22_chk6_max)
+			nFlgChk6 = flm22_chk6_max;
+	}
+	pFlg[HISDETNUM - 1] = nT0;
+	pMod[HISDETNUM - 1] = nT1;
+	/* ----------------------------------- */
+
+	/* for panda */
+	/* check bug */
+	/*
+	if (pFlg[HISDETNUM-1] & 0x1) {
+		nCk22Flg[HISDETNUM-1] = nT0;
+
+		if (nT0 == 0)
+			nCk22Cnt = nCk22Cnt+1;
+		else
+			nCk22Cnt = 0;
+
+		if (nCk22Cnt > 254)
+			nCk22Cnt = 254;
+	}
+	*/
+
+	/* debug 2-2 mode */
+	/* if(pr_pd && (nT0 != 0) && pFlg[HISDETNUM-1]!=0) { */
+	if (prt_flg && (pFlg[HISDETNUM-1] & 0x1)) {
+		if (nT0 != 0) {
+			sprintf(debug_str + strlen(debug_str),
+				"nCk1/3/4=(%2d,%2d,%2d)\n",
+				nFlgChk1, nFlgChk3, nFlgChk4);
+			sprintf(debug_str + strlen(debug_str),
+				"nCk20/1Cnt=(%2d,%2d)\n",
+				nCk20Cnt, nCk21Cnt);
+		}
+	}
+
+	/* ========== check2 2-2 mode  ========== */
+	nFlm22Lvl	= (mNum22[HISDETNUM-1] >> 2);
+	if (nFlm22Lvl	> 64)
+		nFlm22Lvl	= 64;
+
+	/* panda */
+	/* if (pFlg[HISDETNUM-1] && nCk22Cnt < 20) */
+	/*	nFlm22Lvl = nFlm22Lvl + nCk22Cnt - 20; */
+
+	/* 2-2 but with combing: force dejaggies */
+	/* return information */
+	if (nFlgChk1 < flm22_anti_chk1) {
+		nT1 = ((flm22_anti_chk1 - nFlgChk1) >> 2);
+		nFlm22Lvl += nT1;
+	}
+
+	nT1 = ((nCk20Cnt > nCk21Cnt) ? nCk20Cnt : nCk21Cnt);
+	if (nT1 > 128)
+		nT1 = 128;
+	nT1 = ((nT1 + 4) >> 3);
+	nFlm22Lvl += nT1;
+
+	if (nFlgChk3 < flm22_anti_chk3) {
+		nT1 = ((flm22_anti_chk3 - nFlgChk3) >> 3);
+		nFlm22Lvl += nT1;
+	}
+
+	if (nFlgChk4 < flm22_anti_chk4) {
+		nT1 = ((flm22_anti_chk4 - nFlgChk4) >> 3);
+		nFlm22Lvl += nT1;
+	}
+
+	/* for sony-mp3 */
+	if (flm22_anti_ck141 < flm22_anti_ck140)
+		flm22_anti_ck141 = flm22_anti_ck140;
+	nT0 = flm22_anti_ck141 - flm22_anti_ck140;
+
+	if ((nFlgChk1 > flm22_anti_ck140) ||
+		(nFlgChk4 > flm22_anti_ck141)) {
+		if (nFlgChk1 > (nFlgChk4 + nT0))
+			nT1 = nFlgChk1 - flm22_anti_ck140;
+		else
+			nT1 = nFlgChk4 - flm22_anti_ck141;
+
+		if (nT1 > 128)
+			nT1 = 128;
+
+		nT1 = (nT1>>2);
+
+		nFlm22Lvl -= nT1;
+	}
+	/* for sony-mp3 */
+
+	nFlm22Lvl -= nFlgChk5;
+	nFlm22Lvl -= nFlgChk6;
+
+	if (nFlm22Lvl < 0)
+		nFlm22Lvl = 0;
+
+	if (prt_flg) {
+		sprintf(debug_str + strlen(debug_str),
+			"Mod=%d, Flg=%d, Num=%3d, Lvl=%3d\n",
+			pMod[HISDETNUM - 1], pFlg[HISDETNUM - 1],
+			mNum22[HISDETNUM-1], nFlm22Lvl);
+
+		pr_info("%s", debug_str);
+	}
+
+	return nFlm22Lvl;
+}
diff --git a/drivers/amlogic/deinterlace/film_vof_soft.h b/drivers/amlogic/deinterlace/film_vof_soft.h
new file mode 100644
index 0000000..7c6d4a3
--- /dev/null
+++ b/drivers/amlogic/deinterlace/film_vof_soft.h
@@ -0,0 +1,180 @@
+#ifndef _FLMVOFSFT_H_
+#define _FLMVOFSFT_H_
+
+/* Film Detection and VOF detection Software implementation */
+/* Designer: Xin.Hu@amlogic.com */
+/* Date: 12/06/13 */
+
+/* Difference Windows Number (Last one is the global/total dif) */
+/* 5wind+global */
+/* #define DIFWNDNUM 6 */
+#define HISDIFNUM 10
+#define HISCMBNUM 10
+/* detection history information */
+#define HISDETNUM 6
+/* The number of VOF window */
+#define VOFWNDNUM 4
+
+#define PDXX_PT_NUM 7
+
+/* 288Row, 1bit/row -> (288/32)=9 */
+#define ROWCMBNUM 288
+#define ROWCMBLEN 9
+
+#ifndef UINT32
+#define UINT32 unsigned int
+#endif
+
+#ifndef UINT8
+#define UINT8 unsigned char
+#endif
+
+#ifndef UShort
+#define UShort unsigned short
+#endif
+
+extern uint pr_pd;
+extern bool prt_flg;
+extern char debug_str[];
+
+/* Software: Film Detection and VOF parameters */
+struct sFlmDatSt {
+	UINT8 pFlg32[HISDETNUM]; /* history information */
+	UINT8 pMod32[HISDETNUM];
+	UINT8 mNum32[HISDETNUM];
+
+	UINT8 pFld32[HISDETNUM];
+	UINT8 pFrm32[HISDETNUM];
+	UINT8 pFrm32t[HISDETNUM]; /* history information: spacial processing */
+
+	UINT8 pFlg22[HISDETNUM];
+	UINT8 pMod22[HISDETNUM];
+	UINT8 mNum22[HISDETNUM];
+
+	UINT8 pStp22[HISDETNUM];
+	UINT8 pSmp22[HISDETNUM];
+
+	UINT8 pModXx[HISDETNUM]; /* mode */
+	UINT8 pFlgXx[HISDETNUM]; /* pre-1, nxt-0 */
+	UINT8 pLvlXx[HISDETNUM]; /* mode level */
+
+	int TCNm[HISCMBNUM];/* history: the number of combing-rows */
+
+	UINT32 *rROFrmDif02;
+
+	/* size of the image */
+	int iHeight;
+	int iWidth;
+};
+
+/* Software parameters */
+struct sFlmSftPar {
+	/* software */
+	int sFrmDifAvgRat;	/* 16;  //0~32 */
+	/* 4096; //The Large Decision should be: (large>average+LgDifThrd) */
+	int sFrmDifLgTDif;
+	int sF32StpWgt01;	/* 15; */
+	int sF32StpWgt02;	/* 15; */
+	int sF32DifLgRat;	/* 16;  //Dif>Rat*Min  --> Larger */
+
+	int sFlm2MinAlpha;	/* = 32; // [0~63] */
+	int sFlm2MinBelta;	/* = 32; // [0~63] */
+	int sFlm20ftAlpha;	/* = 16; // [0~63] */
+	int sFlm2LgDifThd;	/* = 4096; // [0~63] %LgDifThrd */
+	int sFlm2LgFlgThd;	/* = 8; */
+
+	int sF32Dif01A1;	/* 65; */
+	int sF32Dif01T1;	/* 128; */
+	int sF32Dif01A2;	/* 65; */
+	int sF32Dif01T2;	/* 128; */
+
+	int rCmbRwMinCt0;	/* 8; //for film 3-2 */
+	int rCmbRwMinCt1;	/* =7; //for film 2-2 */
+
+	UINT8 sFlm32NCmb;	/* absolute no combing for film 32 */
+
+	/* pre-processing (t-0), post-processing f(t-mPstDlyPre); // No RTL */
+	int mPstDlyPre;
+	/* pre-processing (t-0), pre-processing f(t+mNxtDlySft); default=1 */
+	int mNxtDlySft;
+
+	UINT32 sF32Dif02M0;	/* mpeg-4096, cvbs-8192 */
+	UINT32 sF32Dif02M1;	/* mpeg-4096, cvbs-8192 */
+};
+
+struct FlmModReg_t {
+	UINT32 rROFrmDif02[6];	/* Read only */
+	UINT32 rROFldDif01[6];	/* Read only */
+	UINT32 rROCmbInf[9];/* Inf[0]-[31:0], First-[31], Lst-[0] (Only 0/1) */
+};
+
+struct FlmDectRes {
+	UINT8 rCmb32Spcl;
+	UINT8 rFlmPstGCm;
+	UINT8 rFlmSltPre;
+	UINT8 rFlmPstMod;
+	UShort rPstCYWnd0[3];
+	UShort rPstCYWnd1[3];
+	UShort rPstCYWnd2[3];
+	UShort rPstCYWnd3[3];
+	UShort rPstCYWnd4[3];
+	UShort rF22Flag;
+};
+
+UINT8 FlmVOFSftInt(struct sFlmSftPar *pPar);
+/* Get 1-Row combing information, 1bit */
+/* iHSCMB[9]; 9x32=288 */
+UINT8 Get1RCmb(UINT32 *iHSCMB, UINT32 iRow);
+
+int FlmModsDet(struct sFlmDatSt *pRDat, int nDif01, int nDif02);
+
+
+/*  */
+int FlmVOFSftTop(UINT8 *rCmb32Spcl, UShort *rPstCYWnd0, UShort *rPstCYWnd1,
+		 UShort *rPstCYWnd2, UShort *rPstCYWnd3, UShort *rPstCYWnd4,
+		 UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
+		 UINT32 *rROFldDif01, UINT32 *rROFrmDif02, UINT32 *rROCmbInf,
+		 int *tTCNm,
+		 struct sFlmSftPar *pPar, int nROW, int nCOL);
+
+/* length of pFlm01/nDif01: [0:5]; */
+/* iDx: index of minimum dif02 ([0:5] */
+int Cal32Flm01(UINT8 *pFlm01, int *nDif01, int iDx, struct sFlmSftPar *pPar);
+
+/* Film Detection Software implementation */
+/* nDif01: Fild Difference */
+/* nDif02: Frame Difference */
+/* WND: The index of Window */
+int FlmDetSft(struct sFlmDatSt *pRDat, int *nDif01, int *nDif02, int WND,
+	      struct sFlmSftPar *pPar);
+
+int VOFDetSub1(int *PREWV, int *nCNum, int nMod, UINT32 *nRCmb, int nROW,
+	       struct sFlmSftPar *pPar);
+
+/* Video on Film Detection Software implementaion */
+int VOFDetSft(int *VOFWnd, int *nCNum, int *nGCmb,
+	      UINT32 HSCMB[HISCMBNUM][ROWCMBLEN], int nMod, UINT8 *PREWV,
+	      int nROW, struct sFlmSftPar *pPar);
+
+/*  */
+int Flm32DetSft(struct sFlmDatSt *pRDat, int *nDif02, int *nDif01,
+		struct sFlmSftPar *pPar);
+
+/* Film2-2 Detection */
+int Flm22DetSft(struct sFlmDatSt *pRDat, int *nDif02,
+			int *nDif01, struct sFlmSftPar *pPar);
+
+/* length: [0:5] */
+/* MIX: [1~5] */
+int Flm32DetSub1(struct sFlmDatSt *pRDat, UINT8 *nFlg12, UINT8 *pFlm02t,
+		 UINT8 *nFlg01, UINT8 *nFlg02, UINT8 MIX);
+
+int VOFSftTop(UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
+	      UShort *rPstCYWnd0, UShort *rPstCYWnd1, UShort *rPstCYWnd2,
+	      UShort *rPstCYWnd3, int nMod, UINT32 *rROCmbInf,
+	      struct sFlmDatSt *pRDat, struct sFlmSftPar *pPar,
+	      int nROW, int nCOL);
+
+extern UINT32 field_count;
+
+#endif
diff --git a/drivers/amlogic/deinterlace/flm_mod_xx.c b/drivers/amlogic/deinterlace/flm_mod_xx.c
new file mode 100644
index 0000000..3cf0ad4
--- /dev/null
+++ b/drivers/amlogic/deinterlace/flm_mod_xx.c
@@ -0,0 +1,520 @@
+#include <linux/kernel.h>
+#include <linux/module.h>
+#include "film_vof_soft.h"
+
+/* dif02 < (size >> sft) => static */
+int flm2224_stl_sft = 7; /*10*/
+module_param(flm2224_stl_sft, int, 0644);
+MODULE_PARM_DESC(flm2224_stl_sft, "flm2224_stl_sft");
+
+int aMax02[15]; /* maximum 4 */
+int aXId02[15];
+int aMin02[15]; /* minimum 4 */
+int aNId02[15];
+int aXMI02[15];
+
+int GetMaxNIdx(int *nMax4, int *nXId4, int N, int *nQt01, int nLen)
+{
+	int nT1 = 0;
+	int nT3 = 0;
+	int nT4 = 0;
+	int nTmp = 0;
+
+	for (nT1 = 0; nT1 <	N; nT1++) {
+		nMax4[nT1] = 0;
+		nXId4[nT1] = 0;
+	}
+
+	for (nT1 = 0; nT1 <	nLen; nT1++) {
+		nTmp = nQt01[nT1];
+
+		/* maximum */
+		for (nT3 = 0; nT3 < N; nT3++) {
+			if (nTmp > nMax4[nT3]) {
+				for (nT4 = 3; nT4 >= nT3+1; nT4--) {
+					nMax4[nT4] = nMax4[nT4-1];
+					nXId4[nT4] = nXId4[nT4-1];
+				}
+				nMax4[nT3] = nTmp;
+				nXId4[nT3] = nT1;
+				break;
+			}
+		}
+	}
+	return 0;
+}
+
+int GetMinNIdx(int *nMax4, int *nXId4, int N, int *nQt01, int nLen)
+{
+	int nT1 = 0;
+	int nT3 = 0;
+	int nT4 = 0;
+	int nTmp = 0;
+
+	for (nT1 = 0; nT1 <	N; nT1++) {
+		nMax4[nT1] = 17;
+		nXId4[nT1] = 0;
+	}
+
+	for (nT1 = 0; nT1 <	nLen; nT1++) {
+		nTmp = nQt01[nT1];
+
+		/* minimum */
+		for (nT3 = 0; nT3 < N; nT3++) {
+			if (nTmp < nMax4[nT3]) {
+				for (nT4 = 3; nT4 >= nT3+1; nT4--) {
+					nMax4[nT4] = nMax4[nT4-1];
+					nXId4[nT4] = nXId4[nT4-1];
+				}
+				nMax4[nT3] = nTmp;
+				nXId4[nT3] = nT1;
+				break;
+			}
+		}
+	}
+	return 0;
+}
+
+/* 15: 8-7 */
+/* 12: 3-2-3-2-2 */
+/* 10: 6-4 */
+/* 10: 5-5 */
+/* 10: 2-2-2-4 */
+/* 10: 2-3-3-2 */
+/* 10: 3-2-3-2 */
+/* pulldown pattern number */
+int	FlmModsDet(struct sFlmDatSt *pRDat, int nDif01, int nDif02)
+{
+	int iWidth  = pRDat->iWidth;
+	int iHeight = pRDat->iHeight;
+	int iSIZE = (iWidth * iHeight);
+	int iMxDif  = (iSIZE >> 6);
+	int nPrtLog[PDXX_PT_NUM] = {87, 32322, 64, 55, 2224, 2332, 3232};
+
+	/* HISDETNUM hist */
+	UINT8 *pModXx = pRDat->pModXx;
+	UINT8 *pFlgXx = pRDat->pFlgXx; /* pre-1, nxt-0 */
+	UINT8 *pLvlXx = pRDat->pLvlXx;  /* mode level */
+
+	static unsigned int sModFlg01[PDXX_PT_NUM]; /* flags */
+	static unsigned int sModFlg02[PDXX_PT_NUM]; /* flags */
+	static int nModCnt[PDXX_PT_NUM]; /* mode counter */
+
+	unsigned int tModFlg01[PDXX_PT_NUM]; /* current flags */
+	unsigned int tModFlg02[PDXX_PT_NUM]; /* current flags */
+
+	int nMxMn[PDXX_PT_NUM][2] = { {2, 4}, {-2, -2}, {2, 4},
+	{2, 4}, {4, -2}, {4, -2}, {4, -2} };
+
+	int nModLvl[PDXX_PT_NUM] = {0, 0, 0, 0, 0, 0, 0}; /* mode level */
+	int nQt01[15];
+	int nQt02[15];
+
+	int aMax01[15]; /* maximum 4 */
+	int aXId01[15];
+	int aMin01[15]; /* minimum 4 */
+	int aNId01[15];
+	int aXMI01[15];
+
+	int	nT0	= 0;
+	int	nT1	= 0;
+	int	nT2	= 0;
+	int	nT3	= 0;
+	int	nT4	= 0;
+
+	int	tT0	= 0;
+	int	tT1	= 0;
+	int	tT2	= 0;
+	int	tT3	= 0;
+
+	unsigned int uT01 = 0;
+	unsigned int uT02 = 0;
+	unsigned int uT03 = 0;
+
+	int	nS01[PDXX_PT_NUM]	= {0, 0, 0,	0, 0, 0, 0};
+	int	nS02[PDXX_PT_NUM]	= {0, 0, 0,	0, 0, 0, 0};
+	int	nStp[PDXX_PT_NUM]	= {15, 12, 10, 10, 10, 10};
+
+	static int pDif01[30];
+	static int pDif02[30];
+
+	int nLen1 = 0;
+	int nLen2 = 0;
+
+	int	nMin01 = 0;
+	int	nMax01 = 0;
+	int	nMin02 = 0;
+	int	nMax02 = 0;
+	int tModLvl = 0;
+	iMxDif = (iMxDif >> 4) + 1;
+
+	prt_flg = ((pr_pd >> 4) & 0x1);
+	if (prt_flg)
+		sprintf(debug_str, "#DbgXx:\n");
+
+
+	for (nT0 = 1; nT0 < HISDETNUM; nT0++) {
+		pFlgXx[nT0 - 1] = pFlgXx[nT0];
+		pLvlXx[nT0 - 1] = pLvlXx[nT0];
+		pModXx[nT0 - 1] = pModXx[nT0];
+	}
+
+	for	(nT0 = 0; nT0 <	29;	nT0++) {
+		pDif01[nT0]	= pDif01[nT0 + 1];
+		pDif02[nT0]	= pDif02[nT0 + 1];
+	}
+	pDif01[29] = (nDif01 >> 6);
+	pDif02[29] = (nDif02 >> 6);
+
+	for	(nT0 = 0; nT0 <	3; nT0++) {
+		nT2	= nStp[nT0];
+
+		nT3	= pDif01[29];
+		nT4	= pDif02[29];
+
+		nMin01 = nT3;
+		nMax01 = nT3;
+		nMin02 = nT4;
+		nMax02 = nT4;
+
+		nT3 = pDif01[29] - pDif01[29 - nT2];
+		nT4 = pDif02[29] - pDif02[29 - nT2];
+		if (nT3 < 0)
+			nT3 = -nT3;
+		if (nT4 < 0)
+			nT4 = -nT4;
+		nS01[nT0] = nT3;
+		nS02[nT0] = nT4;
+
+		/* nS01, nS02: sum of difference */
+		for	(nT1 = 1; nT1 <	nT2; nT1++)	{
+			nT3	= pDif01[29	- nT1];
+			nT4	= pDif02[29	- nT1];
+
+			if (nT3 > nMax01)
+				nMax01 = nT3;
+			if (nT3 < nMin01)
+				nMin01 = nT3;
+
+			if (nT4 > nMax02)
+				nMax02 = nT4;
+			if (nT4 < nMin02)
+				nMin02 = nT4;
+
+			/* diff max */
+			nT3 = pDif01[29	- nT1] - pDif01[29 - nT1 - nT2];
+			nT4	= pDif02[29	- nT1] - pDif02[29 - nT1 - nT2];
+			if (nT3 < 0)
+				nT3 = -nT3;
+			if (nT4 < 0)
+				nT4 = -nT4;
+			if (nT3 > nS01[nT0])
+				nS01[nT0] = nT3;
+			if (nT4 > nS02[nT0])
+				nS02[nT0] = nT4;
+		}
+
+		for (nT1 = 0; nT1 <	nT2; nT1++)	{
+			nT3 = pDif01[29 - nT1] - nMin01;
+			nT4 = nMax01 - nMin01 + 32;
+			nT3 = (16 * nT3) + (nT4 / 2);
+			nQt01[nT1] = (nT3 / nT4);
+
+			nT3 = pDif02[29 - nT1] - nMin02;
+			nT4 = nMax02 - nMin02 + 32;
+			nT3 = (16 * nT3) + (nT4 / 2);
+			nQt02[nT1] = (nT3 / nT4);
+		}
+
+		if (nT0 == 2)
+			tT2 = PDXX_PT_NUM - 2;
+		else
+			tT2 = 1;
+
+		for (tT1 = 0; tT1 < tT2; tT1++) {
+			tT0	= nT0 + tT1;
+
+			tModLvl = ((nModCnt[tT0] + 2) >> 2);
+			if (tModLvl > 64)
+				tModLvl = 64;
+
+			if (nS01[nT0] > nMax01)
+				nT3 = 8;
+			else {
+				nT3 = (nS01[nT0] << 3);
+				nT3 = nT3 + (nMax01 >> 1);
+				nT3 = nT3 / (nMax01 + 1);
+				if (nT3 > 8)
+					nT3 = 8;
+			}
+			tModLvl -= nT3;
+
+			if (nS02[nT0] > nMax02)
+				nT4 = 8;
+			else {
+				nT4 = (nS02[nT0] << 3);
+				nT4 = nT4 + (nMax02 >> 1);
+				nT4 = nT4 / (nMax02 + 1);
+				if (nT4 > 8)
+					nT4 = 8;
+			}
+			tModLvl -= nT4;
+
+			if (nMxMn[tT0][0] > 0) {
+				nLen1 = nMxMn[tT0][0];
+				GetMaxNIdx(aMax01, aXId01, nLen1, nQt01, nT2);
+
+				nT4 = 0;
+				for (tT3 = 0; tT3 < nLen1; tT3++) {
+					aXMI01[tT3] = aXId01[tT3];
+					nT4 += (16 - aMax01[tT3]);
+				}
+				nT4 /= nLen1;
+				tModLvl -= nT4;
+			} else {
+				nLen1 = -nMxMn[tT0][0];
+				GetMinNIdx(aMin01, aNId01, nLen1, nQt01, nT2);
+
+				nT4 = 0;
+				for (tT3 = 0; tT3 < nLen1; tT3++) {
+					aXMI01[tT3] = aNId01[tT3];
+					nT4 += aMin01[tT3];
+				}
+				nT4 /= nLen1;
+				tModLvl -= nT4;
+			}
+
+			if (nMxMn[tT0][1] > 0) {
+				nLen2 = nMxMn[tT0][1];
+				GetMaxNIdx(aMax02, aXId02, nLen2, nQt02, nT2);
+
+				nT4 = 0;
+				for (tT3 = 0; tT3 < nLen2; tT3++) {
+					aXMI02[tT3] = aXId02[tT3];
+					nT4 += (16 - aMax02[tT3]);
+				}
+				nT4 /= nLen1;
+				tModLvl -= nT4;
+			} else {
+				nLen2 = -nMxMn[tT0][1];
+				GetMinNIdx(aMin02, aNId02, nLen2, nQt02, nT2);
+
+				nT3 = 0;
+				nT4 = 0;
+				for (tT3 = 0; tT3 < nLen2; tT3++) {
+					aXMI02[tT3] = aNId02[tT3];
+					nT4 += aMin02[tT3];
+
+					nT3 = pDif02[29 - aNId02[tT3]];
+					if (nT3 > iMxDif)
+						nT4 += 8;
+					else {
+						nT3 = (nT3 << 3) +
+							(iMxDif >> 1);
+						nT3 /= (iMxDif + 1);
+						nT4 += nT3;
+					}
+				}
+				nT4 /= (2 * nLen2);
+				tModLvl -= nT4;
+			}
+
+			tModFlg01[tT0] = 0;
+			for (tT3 = 0; tT3 < nLen1; tT3++)
+				tModFlg01[tT0] |= (1 << aXMI01[tT3]);
+
+			tModFlg02[tT0] = 0;
+			for (tT3 = 0; tT3 < nLen2; tT3++)
+				tModFlg02[tT0] |= (1 << aXMI02[tT3]);
+
+			uT03 = (1 << nT2) - 1;
+			tModFlg01[tT0] &= uT03;
+			tModFlg02[tT0] &= uT03;
+
+			uT01 = (sModFlg01[tT0] << 1);
+			uT01 |= (uT01 >> nT2);
+			uT01 &= uT03;
+
+			uT02 = (sModFlg02[tT0] << 1);
+			uT02 |= (uT02 >> nT2);
+			uT02 &= uT03;
+
+			/* minimum check */
+			nLen2 = 0;
+			if (tT0 == 0) { /* 8-7 */
+				nLen2 = 11;
+			} else if (tT0 == 2) { /* 6-4 */
+				nLen2 = 6;
+			} else if (tT0 == 3) { /* 5-5 */
+				nLen2 = 6;
+			}
+
+			if (nLen2 > 0) {
+				GetMinNIdx(aMin02, aNId02, nLen2, nQt02, nT2);
+				nT4 = 0;
+				for (tT3 = 0; tT3 < nLen2; tT3++) {
+					nT3 = pDif02[29 - aNId02[tT3]];
+					if (nT3 > iMxDif)
+						nT4 += 8;
+					else {
+						nT3 = (nT3 << 3)
+							+ (iMxDif >> 1);
+						nT3 /= (iMxDif + 1);
+						nT4 += nT3;
+					}
+				}
+				nT4 /= nLen2;
+				tModLvl -= nT4;
+			}
+
+			if (nMin02 > iMxDif) {
+				tModLvl -= 16;
+					nModCnt[tT0] = 0;
+			} else {
+				nT4 = (nMin02 << 4);
+				nT4 = nT4 / iMxDif;
+				tModLvl -= nT4;
+			}
+
+			/*
+			nT4 = (nMin02 << 6) + (iMxDif >> 1);
+			nT4 = nT4 / iMxDif;
+			if (nModCnt[tT0] > nT4)
+				nModCnt[tT0] -= nT4;
+			else
+				nModCnt[tT0] = 0;
+			*/
+
+
+			/* Distance between maximum-2 dif01*/
+			if (aXMI01[1] > aXMI01[0])
+				nT3 = aXMI01[1] - aXMI01[0];
+			else
+				nT3 = aXMI01[0] - aXMI01[1];
+
+			/* Distance between minimium-2 dif02 */
+			if (aXMI02[1] > aXMI02[0])
+				nT4 = aXMI02[1] - aXMI02[0];
+			else
+				nT4 = aXMI02[0] - aXMI02[1];
+
+
+			if ((uT01 == tModFlg01[tT0]) &&
+				(uT02 == tModFlg02[tT0]) &&
+				(nT3 > 0) && (uT01 > 0) &&
+				(uT02 > 0)) {
+				if (tT0 == 0) {
+					if (nT3 == 7 || nT3 == 8) {
+						nModCnt[tT0] += 1;
+						tModLvl += 2;
+					} else
+						nModCnt[tT0] = 0;
+				} else if (tT0 == 2) {
+					if (nT3 == 4 || nT3 == 6) {
+						nModCnt[tT0] += 1;
+						tModLvl += 2;
+					} else
+						nModCnt[tT0] = 0;
+				} else if (tT0 == 3) {
+					if (nT3 == 5) {
+						nModCnt[tT0] += 1;
+						tModLvl += 2;
+					} else
+						nModCnt[tT0] = 0;
+				}
+			}
+
+			if ((uT02 == tModFlg02[tT0]) &&
+				(nT4 > 0) && (uT02 > 0)) {
+				if ((uT01 == tModFlg01[tT0]) && (uT01 > 0))
+					tModLvl += 1;
+
+				 if (tT0 == 1) {
+					if (nT4 == 5 || nT4 == 7) {
+						nModCnt[tT0] += 1;
+						tModLvl += 1;
+					} else
+						nModCnt[tT0] = 0;
+				}  else if (tT0 == 4) {
+					if (nT4 == 1 || nT4 == 9) {
+						nModCnt[tT0] += 1;
+						tModLvl += 1;
+					} else
+						nModCnt[tT0] = 0;
+				} else if (tT0 == 5) {
+					if (nT4 == 3 || nT4 == 7) {
+						nModCnt[tT0] += 1;
+						tModLvl += 1;
+					} else
+						nModCnt[tT0] = 0;
+				} else if (tT0 == 6) {
+					if (nT4 == 5) {
+						nModCnt[tT0] += 1;
+						tModLvl += 1;
+					} else
+						nModCnt[tT0] = 0;
+				}
+			}
+
+			if (nModCnt[tT0] > 254)
+				nModCnt[tT0] = 254;
+
+			if (tModLvl < 0)
+				tModLvl = 0;
+
+			nModLvl[tT0] = tModLvl;
+
+			sModFlg01[tT0] = tModFlg01[tT0];
+			sModFlg02[tT0] = tModFlg02[tT0];
+		} /* 2-3-4-5*/
+	}
+
+	tModLvl = nModLvl[0];
+	nT1 = 0;
+	for	(nT0 = 1; nT0 <	PDXX_PT_NUM; nT0++) {
+		if (nModLvl[nT0] > tModLvl) {
+			tModLvl = nModLvl[nT0];
+			nT1 = nT0;
+		}
+	}
+
+	if (prt_flg)
+		sprintf(debug_str + strlen(debug_str),
+			"nMax02(10)=%4d < (%4d)\n",
+			nMax02, (iSIZE >> flm2224_stl_sft));
+
+	if ((nT1 == 4) &&
+		(nMax02 <= (iSIZE >> flm2224_stl_sft)))
+		nModCnt[nT1] = 0;
+
+	pModXx[HISDETNUM - 1] = nT1;
+	pLvlXx[HISDETNUM - 1] = tModLvl;
+	pFlgXx[HISDETNUM - 1] = (pDif01[29] < pDif01[28]);
+
+	/* recheck */
+	if ((pFlgXx[HISDETNUM - 2] == 0) &&
+		(pDif01[29] > pDif01[28]))
+		pFlgXx[HISDETNUM - 2] = 1;
+
+	if (prt_flg && tModLvl > 0) {
+		sprintf(debug_str + strlen(debug_str),
+			"#FM%5d detected ct(%3d) lvl(%2d)\n",
+			nPrtLog[nT1], nModCnt[nT1], nModLvl[nT1]);
+		if (pDif01[29] < pDif01[28])
+			sprintf(debug_str + strlen(debug_str),
+				"#Pre: A<-A\n");
+		else
+			sprintf(debug_str + strlen(debug_str),
+				"#Nxt: A B->\n");
+	}
+
+	if (prt_flg) {
+		sprintf(debug_str + strlen(debug_str),
+			"Mod=%5d, Flg=%d, Lvl=%3d\n",
+			nT1, pFlgXx[HISDETNUM - 1],
+			tModLvl);
+		pr_info("%s", debug_str);
+	}
+
+	return nT1;
+}
diff --git a/drivers/amlogic/deinterlace/register.h b/drivers/amlogic/deinterlace/register.h
index 0513c21..f6b2bfa 100644
--- a/drivers/amlogic/deinterlace/register.h
+++ b/drivers/amlogic/deinterlace/register.h
@@ -10,7 +10,7 @@
 #define Wr_reg_bits(adr, val, start, len)  \
 		aml_vcbus_update_bits(adr, ((1<<len)-1)<<start, val<<start)
 #define Rd_reg_bits(adr, start, len)  \
-		(aml_read_vcbus(adr)&(((1<<len)-1)<<start))
+		((aml_read_vcbus(adr)&(((1<<len)-1)<<start))>>start)
 
 unsigned int RDMA_WR(unsigned int adr, unsigned int val);
 unsigned int RDMA_RD(unsigned int adr);
@@ -18,10 +18,117 @@ unsigned int RDMA_WR_BITS(unsigned int adr, unsigned int val,
 		unsigned int start, unsigned int len);
 unsigned int RDMA_RD_BITS(unsigned int adr, unsigned int start,
 		unsigned int len);
+#define VPU_WRARB_REQEN_SLV_L1C1	((0x2795)) /* << 2) + 0xd0100000) */
+#define VPU_ARB_DBG_STAT_L1C1		((0x27b4)) /* << 2) + 0xd0100000) */
+#define SRSHARP0_SHARP_SR2_CTRL     ((0x3257)) /* << 2) + 0xd0100000) */
+/* Bit 24,  sr2_dejaggy_en  */
+
+#define SRSHARP0_SHARP_DEJ2_MISC    ((0x3263)) /* << 2) + 0xd0100000) */
+/* Bit 3 sr2_dejaggy2_alpha_force,
+force enable of the alpha for dejaggy2 */
+/* Bit 2: 0	sr2_dejaggy2_alpha_value,
+  forced value of alpha for dejaggy2     */
+
+#define SRSHARP0_DEJ_CTRL             0x3264  /*<< 2) + 0xd0100000)*/
+/*Bit 31:4    reserved
+*Bit 3:2,    reg_sr3_dejaggy_sameside_prtct
+*u2:  enable of sr3 dejaggy same side curve protect from filter,
+*[0] for proc, [1] for ctrl path,  default=3
+*Bit 1,      reg_sr3_dejaggy_sameside_mode
+*u1: mode of the sameside flag decision: default =1
+*Bit 0,      reg_sr3_dejaggy_enable
+u1: enable of sr3 dejaggy: default =0*/
+
+#define SRSHARP0_SHARP_DEJ2_PRC     ((0x3261)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,  reg_dejaggy2_hcon_thrd             : .
+unsigned, default =5,hcon threshold, only pixels with hcon equal or
+larger than this value can be detected as jaggy2 */
+/* Bit 23:16,  reg_dejaggy2_svdif_thrd            : . unsigned,
+default =30,abs(sum(vdif[4])) threshold to decide jaggy2, only
+pixels ws abs(sum(vdif[4]))>= thrd can be jaggy2 */
+/* Bit 15: 8,  reg_dejaggy2_svdif_rate            : .
+unsigned, default =32,sum(abs(vdif[4])) <= (rate*abs(sum(vdif[4]))/16)
+rate to decide jaggy2,(normalized 2) */
+/* Bit  7: 6,  reserved */
+/* Bit  5: 0,  reg_dejaggy2_vdif_thrd             : .
+signed, default =-3,vdif threshold for same trend decidion, these value
+is the margin for not same trend; if >0, means need to be same trend, <0,
+can be a little bit glitch
+*/
+#define SRSHARP0_SHARP_DEJ1_PRC    ((0x3262)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,  reg_dejaggy1_hcon_thrd             : . unsigned,
+default =1,hcon threshold, only pixels with hcon equal or larger
+than this value can be detected as jaggy1 */
+/* Bit 23:16,  reg_dejaggy1_svdif_thrd            : . unsigned,
+default =50,abs(sum(vdif[4])) threshold to decide jaggy1, only
+pixels ws abs(sum(vdif[4]))<= thrd can be jaggy1 */
+/* Bit 15: 8, reg_dejaggy1_svdif_rate            : . unsigned,
+default =64,sum(abs(vdif[4])) <= (rate*abs(sum(vdif[4]))/16) rate
+to decide jaggy2,(normalized 2) */
+/* Bit  7: 6,  reserved */
+/* Bit  5: 0,  reg_dejaggy1_dif12_rate            : . unsigned,
+default =16,sum(abs(vdif2[3]))< (sum(abs(vdif[4]))*rate/32) rate
+to decide jaggy2, (normalized 0.5) */
+#define SRSHARP0_SHARP_DEJ1_MISC   ((0x3264)) /* << 2) + 0xd0100000) */
+/* Bit 31:12,  reserved */
+/* Bit 11: 8,  reg_dejaggy1_svdif_ofst            : .
+unsigned, default =2,sum(abs(vdif[4])) >= (rate*abs(sum(vdif[4]))/32 + ofst)
+offset to decide jaggy2,(normalized 2) */
+/* Bit  7,     reg_dejaggy1_proc_chrm             : .
+unsigned, default =1, enable to filter 2 pixels step on chroma */
+/* Bit  6,     reg_dejaggy1_proc_luma             : .
+unsigned, default =1, enable to filter 2 pixels step on luma */
+/* Bit  5: 4,  reg_dejaggy1_extend_mode           : .
+unsigned, default =3, extend mode for dejaggy1 horizontally,
+0, no extnd, 1: exend 1 pixel, 2: extend 2 pixels, 3, extend 3 pixels */
+/* Bit  3,     reserved */
+/* Bit  2,     reg_dejaggy1_alpha_force           : .
+unsigned, default =0, force enable of the alpha for dejaggy1 */
+/* Bit  1: 0,  reg_dejaggy1_alpha_value           : .
+unsigned, default =0, force value of the alpha for dejaggy1 */
+
+
 
 /* vdin */
 #define VDIN_WR_CTRL					0x1220
-		/* 0xd0104880 */
+/* 0xd0104880 */
+/* Bit 31:30 hconv_mode, Applicable only to bit[13:12]=0 or 2.
+	0: Output every even pixels' CbCr; */
+/* 1: Output every odd pixels' CbCr; */
+/* 2: Output an average value per even&odd pair of pixels; */
+/* 3: Output all CbCr. (This does NOT apply to bit[13:12]=0 -- 4:2:2 mode.) */
+/* Bit 29 no_clk_gate: disable vid_wr_mif clock gating function. */
+/* Bit 28 clear write response counter in the vdin write memory interface */
+/* Bit 27 eol_sel, 1: use eol as the line end indication, 0: use width as line
+end indication in the vdin write memory interface */
+/* Bit 26 vcp_nr_en. Only used in VDIN0. NOT used in VDIN1. */
+/* Bit 25 vcp_wr_en. Only used in VDIN0. NOT used in VDIN1. */
+/* Bit 24 vcp_in_en. Only used in VDIN0. NOT used in VDIN1. */
+/* Bit 23 vdin frame reset enble, if true, it will provide frame reset during
+go_field(vsync) to the modules after that */
+/* Bit 22 vdin line fifo soft reset enable, meaning, if true line fifo will
+reset during go_field (vsync) */
+/* Bit 21 vdin direct write done status clear bit */
+/* Bit 20 vdin NR write done status clear bit */
+/* Bit 18 swap_cbcr. Applicable only to bit[13:12]=2. 0: Output CbCr (NV12);
+1: Output CrCb (NV21). */
+/* Bit 17:16 vconv_mode, Applicable only to bit[13:12]=2. 0: Output every even
+lines' CbCr; */
+/* 1: Output every odd lines' CbCr; */
+/* 2: Reserved; */
+/* 3: Output all CbCr. */
+/* Bit 13:12 vdin write format, 0: 4:2:2 to luma canvas, 1: 4:4:4
+to luma canvas, */
+/* 2: Y to luma canvas, CbCr to chroma canvas. For NV12/21, also define Bit
+31:30, 17:16, and bit 18. */
+/* Bit 11 vdin write canvas double buffer enable, means the canvas address will
+be latched by vsync before using */
+/* Bit 10 1: disable ctrl_reg write pulse which will reset internal counter.
+when bit 11 is 1, this bit should be 1. */
+/* Bit 9 vdin write request urgent */
+/* Bit 8 vdin write request enable */
+/* Bit 7:0 Write luma canvas address */
+
 /* timerc */
 #define ISA_TIMER_MUX					0x2650
 		/* 0xc1109940 */
@@ -55,889 +162,3536 @@ unsigned int RDMA_RD_BITS(unsigned int adr, unsigned int start,
 #define VIU_OSD1_CTRL_STAT				0x1a10
 		/* 0xd0106840 */
 /* afbc */
-#define AFBC_ENABLE						0x1ae0
-		/* 0xd0106b80 */
-#define AFBC_MODE						0x1ae1
-		/* 0xd0106b84 */
-#define AFBC_SIZE_IN					0x1ae2
-		/* 0xd0106b88 */
-#define AFBC_DEC_DEF_COLOR				0x1ae3
-		/* 0xd0106b8c */
-#define AFBC_CONV_CTRL					0x1ae4
-		/* 0xd0106b90 */
-#define AFBC_LBUF_DEPTH					0x1ae5
-		/* 0xd0106b94 */
-#define AFBC_HEAD_BADDR					0x1ae6
-		/* 0xd0106b98 */
-#define AFBC_BODY_BADDR					0x1ae7
-		/* 0xd0106b9c */
-#define AFBC_OUT_XSCOPE					0x1ae8
-		/* 0xd0106ba0 */
-#define AFBC_OUT_YSCOPE					0x1ae9
-		/* 0xd0106ba4 */
-#define AFBC_STAT						0x1aea
-		/* 0xd0106ba8 */
-#define AFBC_VD_CFMT_CTRL				0x1aeb
-		/* 0xd0106bac */
-#define AFBC_VD_CFMT_W					0x1aec
-		/* 0xd0106bb0 */
-#define AFBC_MIF_HOR_SCOPE				0x1aed
-		/* 0xd0106bb4 */
-#define AFBC_MIF_VER_SCOPE				0x1aee
-		/* 0xd0106bb8 */
-#define AFBC_PIXEL_HOR_SCOPE			0x1aef
-		/* 0xd0106bbc */
-#define AFBC_PIXEL_VER_SCOPE			0x1af0
-		/* 0xd0106bc0 */
-#define AFBC_VD_CFMT_H					0x1af1
-		/* 0xd0106bc4 */
+#define AFBC_ENABLE                        ((0x1ae0)) /* << 2) + 0xd0100000) */
+/* Bit   31:1,     reserved */
+/* Bit   8,        dec_enable        unsigned  , default = 0 */
+/* Bit   7:1,      reserved */
+/* Bit   0,        frm_start         unsigned  , default = 0 */
+#define AFBC_MODE                          ((0x1ae1)) /* << 2) + 0xd0100000) */
+/* Bit   31,       soft_reset        the use as go_field */
+/* Bit   30:28,    reserved */
+/* Bit   27:26,    rev_mode          uns, default = 0 , reverse mode */
+/* Bit   25:24,    mif_urgent        uns, default = 3 ,
+info mif and data mif urgent */
+/* Bit   22:16,    hold_line_num */
+/* Bit   15:14,    burst_len         uns, default = 1,
+0: burst1 1:burst2 2:burst4 */
+/* Bit   13:8,     compbits_yuv      uns, default = 0 , */
+/* bit 1:0,: y  component bitwidth : 00-8bit 01-9bit 10-10bit */
+/* bit 3:2,: u  component bitwidth : 00-8bit 01-9bit 10-10bit */
+/* bit 5:4,: v  component bitwidth : 00-8bit 01-9bit 10-10bit */
+/* Bit   7:6,      vert_skip_y       uns, default = 0 ,
+luma vert skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2 */
+/* Bit   5:4,      horz_skip_y       uns, default = 0 ,
+luma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2 */
+/* Bit   3:2,      vert_skip_uv      uns, default = 0 ,
+chroma vert skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2 */
+/* Bit   1:0,      horz_skip_uv      uns, default = 0 ,
+chroma horz skip mode : 00-y0y1, 01-y0, 10-y1, 11-(y0+y1)/2 */
+#define AFBC_SIZE_IN                       ((0x1ae2)) /* << 2) + 0xd0100000) */
+/* Bit   31:29,    reserved */
+/* Bit   28:16     hsize_in          uns, default = 1920 ,
+pic horz size in  unit: pixel */
+/* Bit   15:13,    reserved */
+/* Bit   12:0,     vsize_in          uns, default = 1080 ,
+pic vert size in  unit: pixel */
+#define AFBC_DEC_DEF_COLOR                 ((0x1ae3)) /* << 2) + 0xd0100000) */
+/* Bit   31:29,    reserved */
+/* Bit   29:20,   def_color_y        uns, default = 0,
+afbc dec y default setting value */
+/* Bit   19:10,   def_color_u        uns, default = 0,
+afbc dec u default setting value */
+/* Bit    9: 0,   def_color_v        uns, default = 0,
+afbc dec v default setting value */
+#define AFBC_CONV_CTRL                     ((0x1ae4)) /* << 2) + 0xd0100000) */
+/* Bit   31:12,   reserved */
+/* Bit   11: 0,   conv_lbuf_len       uns, default = 256,
+unit=16 pixel need to set = 2^n */
+#define AFBC_LBUF_DEPTH                    ((0x1ae5)) /* << 2) + 0xd0100000) */
+/* Bit   31:28,   reserved */
+/* Bit   27:16,   dec_lbuf_depth      uns, default = 128; // unit= 8 pixel */
+/* Bit   15:12,   reserved */
+/* Bit   11:0,    mif_lbuf_depth      uns, default = 128; */
+#define AFBC_HEAD_BADDR                    ((0x1ae6)) /* << 2) + 0xd0100000) */
+/* Bit   31:0,   mif_info_baddr      uns, default = 32'h0; */
+#define AFBC_BODY_BADDR                    ((0x1ae7)) /* << 2) + 0xd0100000) */
+/* Bit   31:0,   mif_data_baddr      uns, default = 32'h0001_0000; */
+
+#define AFBC_SIZE_OUT                    ((0x1ae8)) /* << 2) + 0xd0100000) */
+/*Bit   31:29,   reserved
+   Bit   28:16,   hsize_out    uns, default = 1920    ;    unit: 1 pixel
+   Bit   15:13,   reserved
+   Bit    12:0,   vsize_out    uns, default = 1080 ;       unit: 1 pixel*/
+
+#define AFBC_OUT_YSCOPE                    ((0x1ae9)) /* << 2) + 0xd0100000) */
+/* Bit   31:29,   reserved */
+/* Bit   28:16,   out_vert_bgn        uns, default = 0    ; // unit: 1 pixel */
+/* Bit   15:13,   reserved */
+/* Bit    12:0,   out_vert_end        uns, default = 1079 ; // unit: 1 pixel */
+#define AFBC_STAT                          ((0x1aea)) /* << 2) + 0xd0100000) */
+/* Bit   31:1,   reserved */
+/* Bit      0,   frm_end_stat         uns, frame end status */
+#define AFBC_VD_CFMT_CTRL                  ((0x1aeb)) /* << 2) + 0xd0100000) */
+/* Bit 31    it true, disable clock, otherwise enable clock */
+/* Bit 30    soft rst bit */
+/* Bit 28    if true, horizontal formatter use repeating to generete pixel,
+otherwise use bilinear interpolation */
+/* Bit 27:24 horizontal formatter initial phase */
+/* Bit 23    horizontal formatter repeat pixel 0 enable */
+/* Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1 */
+/* Bit 20    horizontal formatter enable */
+/* Bit 19    if true, always use phase0 while vertical formater,
+meaning always */
+/* repeat data, no interpolation */
+/* Bit 18    if true, disable vertical formatter chroma repeat last line */
+/* Bit 17    veritcal formatter dont need repeat line on phase0,
+1: enable, 0: disable */
+/* Bit 16    veritcal formatter repeat line 0 enable */
+/* Bit 15:12 vertical formatter skip line num at the beginning */
+/* Bit 11:8  vertical formatter initial phase */
+/* Bit 7:1   vertical formatter phase step (3.4) */
+/* Bit 0     vertical formatter enable */
+#define AFBC_VD_CFMT_W                     ((0x1aec)) /* << 2) + 0xd0100000) */
+/* Bit 27:16  horizontal formatter width */
+/* Bit 11:0   vertical formatter width */
+#define AFBC_MIF_HOR_SCOPE                 ((0x1aed)) /* << 2) + 0xd0100000) */
+/* Bit   31:26,   reserved */
+/* Bit   25:16,   mif_blk_bgn_h        uns, default = 0  ;
+// unit: 32 pixel/block hor */
+/* Bit   15:10,   reserved */
+/* Bit    9: 0,   mif_blk_end_h        uns, default = 59 ;
+// unit: 32 pixel/block hor */
+#define AFBC_MIF_VER_SCOPE                 ((0x1aee)) /* << 2) + 0xd0100000) */
+/* Bit   31:28,   reserved */
+/* Bit   27:16,   mif_blk_bgn_v        uns, default = 0  ;
+// unit: 32 pixel/block ver */
+/* Bit   15:12,   reserved */
+/* Bit   11: 0,   mif_blk_end_v        uns, default = 269;
+// unit: 32 pixel/block ver */
+#define AFBC_PIXEL_HOR_SCOPE               ((0x1aef)) /* << 2) + 0xd0100000) */
+/* Bit   31:29,   reserved */
+/* Bit   28:16,   dec_pixel_bgn_h        uns, default = 0  ;
+// unit: pixel */
+/* Bit   15:13,   reserved */
+/* Bit   12: 0,   dec_pixel_end_h        uns, default = 1919 ; // unit: pixel */
+#define AFBC_PIXEL_VER_SCOPE               ((0x1af0)) /* << 2) + 0xd0100000) */
+/* Bit   31:29,   reserved */
+/* Bit   28:16,   dec_pixel_bgn_v        uns, default = 0  ; // unit: pixel */
+/* Bit   15:13,   reserved */
+/* Bit   12: 0,   dec_pixel_end_v        uns, default = 1079 ; // unit: pixel */
+#define AFBC_VD_CFMT_H                     ((0x1af1)) /* << 2) + 0xd0100000) */
+/* Bit 12:0   vertical formatter height */
+
+
 /* viu mux */
 #define VIU_MISC_CTRL0					0x1a06
 		/* 0xd0106818 */
 #define VIUB_MISC_CTRL0					0x2006
 		/* 0xd0108018 */
-/* di */
-#define DI_IF1_URGENT_CTRL				0x1aa3
-		/* 0xd0106a8c */
-#define DI_INP_URGENT_CTRL				0x1aa4
-		/* 0xd0106a90 */
-#define DI_MEM_URGENT_CTRL				0x1aa5
-		/* 0xd0106a94 */
-#define DI_CHAN2_URGENT_CTRL			0x1aa6
-		/* 0xd0106a98 */
+/*txl new add begin*/
+#define DI_IF2_GEN_REG					0x2010
+#define DI_IF2_CANVAS0					0x2011
+#define DI_IF2_LUMA_X0					0x2012
+#define DI_IF2_LUMA_Y0					0x2013
+#define DI_IF2_CHROMA_X0				0x2014
+#define DI_IF2_CHROMA_Y0				0x2015
+#define DI_IF2_RPT_LOOP					0x2016
+#define DI_IF2_LUMA0_RPT_PAT			0x2017
+#define DI_IF2_CHROMA0_RPT_PAT			0x2018
+#define DI_IF2_DUMMY_PIXEL				0x2019
+#define DI_IF2_LUMA_FIFO_SIZE			0x201a
+#define DI_IF2_RANGE_MAP_Y				0x201b
+#define DI_IF2_RANGE_MAP_CB				0x201c
+#define DI_IF2_RANGE_MAP_CR				0x201d
+#define DI_IF2_GEN_REG2					0x201e
+#define DI_IF2_FMT_CTRL					0x201f
+#define DI_IF2_FMT_W					0x2020
+#define DI_IF2_URGENT_CTRL				0x2021
+#define DI_IF2_GEN_REG3					0x2022
+/*txl new add end*/
 
-#define DI_PRE_CTRL						0x1700
-		/* 0xd0105c00 */
-#define DI_POST_CTRL					0x1701
-		/* 0xd0105c04 */
-#define DI_POST_SIZE					0x1702
-		/* 0xd0105c08 */
-#define DI_PRE_SIZE						0x1703
-		/* 0xd0105c0c */
-#define DI_EI_CTRL0						0x1704
-		/* 0xd0105c10 */
-#define DI_EI_CTRL1						0x1705
-		/* 0xd0105c14 */
-#define DI_EI_CTRL2						0x1706
-		/* 0xd0105c18 */
-#define DI_NR_CTRL0						0x1707
-		/* 0xd0105c1c */
-#define DI_NR_CTRL1						0x1708
-		/* 0xd0105c20 */
-#define DI_NR_CTRL2						0x1709
-		/* 0xd0105c24 */
-#define DI_NR_CTRL3						0x170a
-		/* 0xd0105c28 no use*/
-#define DI_MTN_CTRL						0x170b
-		/* 0xd0105c2c no use*/
-#define DI_CANVAS_URGENT0				0x170a
-		/* 0xd0105ee8 */
-#define DI_CANVAS_URGENT1				0x170b
-		/* 0xd0105eec */
-#define DI_MTN_CTRL1					0x170c
-		/* 0xd0105c30 */
-#define DI_BLEND_CTRL					0x170d
-		/* 0xd0105c34 */
-#define DI_BLEND_CTRL1					0x170e
-		/* 0xd0105c38 no use*/
-#define DI_CANVAS_URGENT2				0x170e
-		/* 0xd0105ef0 */
-#define DI_BLEND_CTRL2					0x170f
-		/* 0xd0105c3c no use*/
-#define DI_ARB_CTRL						0x170f
-		/* 0xd0105c3c */
-#define DI_BLEND_REG0_X					0x1710
-		/* 0xd0105c40 */
-#define DI_BLEND_REG0_Y					0x1711
-		/* 0xd0105c44 */
-#define DI_BLEND_REG1_X					0x1712
-		/* 0xd0105c48 */
-#define DI_BLEND_REG1_Y					0x1713
-		/* 0xd0105c4c */
-#define DI_BLEND_REG2_X					0x1714
-		/* 0xd0105c50 */
-#define DI_BLEND_REG2_Y					0x1715
-		/* 0xd0105c54 */
-#define DI_BLEND_REG3_X					0x1716
-		/* 0xd0105c58 */
-#define DI_BLEND_REG3_Y					0x1717
-		/* 0xd0105c5c */
-#define DI_CLKG_CTRL					0x1718
-		/* 0xd0105c60 */
-#define DI_EI_CTRL3						0x1719
-		/* 0xd0105c64 */
-#define DI_EI_CTRL4						0x171a
-		/* 0xd0105c68 */
-#define DI_EI_CTRL5						0x171b
-		/* 0xd0105c6c */
-#define DI_EI_CTRL6						0x171c
-		/* 0xd0105c70 */
-#define DI_EI_CTRL7						0x171d
-		/* 0xd0105c74 */
-#define DI_EI_CTRL8						0x171e
-		/* 0xd0105c78 */
-#define DI_EI_CTRL9						0x171f
-		/* 0xd0105c7c */
-/* pulldown */
-#define DI_MC_REG0_X					0x1720
-		/* 0xd0105c80 */
-#define DI_MC_REG0_Y					0x1721
-		/* 0xd0105c84 */
-#define DI_MC_REG1_X					0x1722
-		/* 0xd0105c88 */
-#define DI_MC_REG1_Y					0x1723
-		/* 0xd0105c8c */
-#define DI_MC_REG2_X					0x1724
-		/* 0xd0105c90 */
-#define DI_MC_REG2_Y					0x1725
-		/* 0xd0105c94 */
-#define DI_MC_REG3_X					0x1726
-		/* 0xd0105c98 */
-#define DI_MC_REG3_Y					0x1727
-		/* 0xd0105c9c */
-#define DI_MC_REG4_X					0x1728
-		/* 0xd0105ca0 */
-#define DI_MC_REG4_Y					0x1729
-		/* 0xd0105ca4 */
-#define DI_MC_32LVL0					0x172a
-		/* 0xd0105ca8 */
-#define DI_MC_32LVL1					0x172b
-		/* 0xd0105cac */
-#define DI_MC_22LVL0					0x172c
-		/* 0xd0105cb0 */
-#define DI_MC_22LVL1					0x172d
-		/* 0xd0105cb4 */
-#define DI_MC_22LVL2					0x172e
-		/* 0xd0105cb8 */
-#define DI_MC_CTRL						0x172f
-		/* 0xd0105cbc */
+/* di */
+#define DI_IF1_URGENT_CTRL                  (0x20a3)  /*  << 2 + 0xd0100000*/
+/* bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 ,
+low threshold  for di inp chroma path */
+/* bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 ,
+low threshold  for di inp luma path */
+#define DI_INP_URGENT_CTRL                  (0x20a4)  /*  << 2 + 0xd0100000*/
+/* bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 ,
+low threshold  for di mem chroma path */
+/* bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 ,
+low threshold  for di mem luma path */
+#define DI_MEM_URGENT_CTRL                  (0x20a5)  /*  << 2 + 0xd0100000*/
+/* bit15, auto enable; bit14, canvas write mode ;7:4, high threshold ;3:0 ,
+low threshold  for di chan2 chroma path */
+/* bit31, auto enable; bit30, canvas write mode ;23:20, high threshold ;19:16 ,
+low threshold  for di chan2 luma path */
+#define DI_CHAN2_URGENT_CTRL                (0x20a6)  /*  << 2 + 0xd0100000*/
 
-#define DI_INTR_CTRL					0x1730
-		/* 0xd0105cc0 */
-#define DI_INFO_ADDR					0x1731
-		/* 0xd0105cc4 */
-#define DI_INFO_DATA					0x1732
-		/* 0xd0105cc8 */
-#define DI_PRE_HOLD						0x1733
-		/* 0xd0105ccc */
-/* 3d detection */
-#define DET3D_MOTN_CFG					0x1734
-		/* 0xd0105cd0 */
-#define DET3D_CB_CFG					0x1735
-		/* 0xd0105cd4 */
-#define DET3D_SPLT_CFG					0x1736
-		/* 0xd0105cd8 */
-#define DET3D_HV_MUTE					0x1737
-		/* 0xd0105cdc */
-#define DET3D_MAT_STA_P1M1				0x1738
-		/* 0xd0105ce0 */
-#define DET3D_MAT_STA_P1TH				0x1739
-		/* 0xd0105ce4 */
-#define DET3D_MAT_STA_M1TH				0x173a
-		/* 0xd0105ce8 */
-#define DET3D_MAT_STA_RSFT				0x173b
-		/* 0xd0105cec */
-#define DET3D_MAT_SYMTC_TH				0x173c
-		/* 0xd0105cf0 */
-#define DET3D_RO_DET_CB_HOR				0x173d
-		/* 0xd0105cf4 */
-#define DET3D_RO_DET_CB_VER				0x173e
-		/* 0xd0105cf8 */
-#define DET3D_RO_SPLT_HT				0x173f
-		/* 0xd0105cfc */
+#define DI_PRE_CTRL                        ((0x1700)) /* << 2) + 0xd0100000) */
+/* bit 31,      cbus_pre_frame_rst */
+/* bit 30,      cbus_pre_soft_rst */
+/* bit 29,      pre_field_num */
+/* bit 27:26,   mode_444c422 */
+/* bit 25,      di_cont_read_en */
+/* bit 24:23,   mode_422c444 */
+/* bit 22,      mtn_after_nr */
+/* bit 21:16,   pre_hold_fifo_lines */
+/* bit 15,      nr_wr_by */
+/* bit 14,      use_vdin_go_line */
+/* bit 13,      di_prevdin_en */
+/* bit 12,      di_pre_viu_link */
+/* bit 11,      di_pre_repeat */
+/* bit 10,      di_pre_drop_1st */
+/* bit  9,      di_buf2_en */
+/* bit  8,      di_chan2_en */
+/* bit  7,      prenr_hist_en */
+/* bit  6,      chan2_hist_en */
+/* bit  5,      hist_check_en */
+/* bit  4,      check_after_nr */
+/* bit  3,      check222p_en */
+/* bit  2,      check322p_en */
+/* bit  1,      mtn_en */
+/* bit  0,      nr_en */
+#define DI_POST_CTRL                      ((0x1701)) /* << 2) + 0xd0100000) */
+/* bit 31,      cbus_post_frame_rst */
+/* bit 30,      cbus_post_soft_rst */
+/* bit 29,      post_field_num */
+/* bit 21:16,   post_hold_fifo_lines */
+/* bit 13,      prepost_link */
+/* bit 12,      di_post_viu_link */
+/* bit 11,      di_post_repeat */
+/* bit 10,      di_post_drop_1st */
+/* bit  9,      mif0_to_vpp_en */
+/* bit  8,      di_vpp_out_en */
+/* bit  7,      di_wr_bk_en */
+/* bit  6,      di_mux_en */
+/* bit  5,      di_blend_en */
+/* bit  4,      di_mtnp_read_en */
+/* bit  3,      di_mtn_buf_en */
+/* bit  2,      di_ei_en */
+/* bit  1,      di_buf1_en */
+/* bit  0,      di_buf0_en */
+#define DI_POST_SIZE                      ((0x1702)) /* << 2) + 0xd0100000) */
+/* bit 28:16,    vsize1post */
+/* bit 12:0,     hsize1post */
+#define DI_PRE_SIZE                       ((0x1703)) /* << 2) + 0xd0100000) */
+/* bit 28:16,    vsize1pre */
+/* bit 12:0,     hsize1pre */
+#define DI_EI_CTRL0                       ((0x1704)) /* << 2) + 0xd0100000) */
+/* bit 23:16,    ei0_filter[2:+]  abs_diff_left>filter &&
+...right>filter && ...top>filter && ...bot>filter -> filter */
+/* bit 15:8,     ei0_threshold[2:+] */
+/* bit 3,        ei0_vertical */
+/* bit 2,        ei0_bpscf2 */
+/* bit 1,        ei0_bpsfar1 */
+#define DI_EI_CTRL1                       ((0x1705)) /* << 2) + 0xd0100000) */
+/* bit 31:24,    ei0_diff */
+/* bit 23:16,    ei0_angle45 */
+/* bit 15:8,     ei0_peak */
+/* bit 7:0,      ei0_cross */
+#define DI_EI_CTRL2                       ((0x1706)) /* << 2) + 0xd0100000) */
+/* bit 31:24,    ei0_close2 */
+/* bit 23:16,    ei0_close1 */
+/* bit 15:8,     ei0_far2 */
+/* bit 7:0,      ei0_far1 */
+#define DI_NR_CTRL0                       ((0x1707)) /* << 2) + 0xd0100000) */
+/* bit 26,       nr_cue_en */
+/* bit 25,       nr2_en */
+#define DI_NR_CTRL1                       ((0x1708)) /* << 2) + 0xd0100000) */
+/* bit 31:30,    mot_p1txtcore_mode */
+/* bit 29:24,    mot_p1txtcore_clmt */
+/* bit 21:16,    mot_p1txtcore_ylmt */
+/* bit 15:8,     mot_p1txtcore_crate */
+/* bit 7:0,      mot_p1txtcore_yrate */
+#define DI_NR_CTRL2                       ((0x1709)) /* << 2) + 0xd0100000) */
+/* bit 29:24,    mot_curtxtcore_clmt */
+/* bit 21:16,    mot_curtxtcore_ylmt */
+/* bit 15:8,     mot_curtxtcore_crate */
+/* bit 7:0,      mot_curtxtcore_yrate */
+/* `define DI_NR_CTRL3               8'h0a */
+/* no use */
+/* `define DI_MTN_CTRL               8'h0b */
+/* no use */
+#define DI_MTN_CTRL1                      ((0x170c)) /* << 2) + 0xd0100000) */
+/* bit 13 ,      me enable */
+/* bit 12 ,      me autoenable */
+/* bit 11:8,		mtn_paramtnthd */
+/* bit 7:0,      mtn_parafltthd */
+#define DI_BLEND_CTRL                     ((0x170d)) /* << 2) + 0xd0100000) */
+/* bit 31,      blend_1_en */
+/* bit 30,      blend_mtn_lpf */
+/* bit 28,      post_mb_en */
+/* bit 27,      blend_mtn3p_max */
+/* bit 26,      blend_mtn3p_min */
+/* bit 25,      blend_mtn3p_ave */
+/* bit 24,      blend_mtn3p_maxtb */
+/* bit 23,      blend_mtn_flt_en */
+/* bit 22,      blend_data_flt_en */
+/* bit 21:20,   blend_top_mode */
+/* bit 19,      blend_reg3_enable */
+/* bit 18,      blend_reg2_enable */
+/* bit 17,      blend_reg1_enable */
+/* bit 16,      blend_reg0_enable */
+/* bit 15:14,   blend_reg3_mode */
+/* bit 13:12,   blend_reg2_mode */
+/* bit 11:10,   blend_reg1_mode */
+/* bit 9:8,     blend_reg0_mode */
+/* bit 7:0,     kdeint */
+/* `define DI_BLEND_CTRL1            8'h0e */
+/* no use */
+/* `define DI_BLEND_CTRL2            8'h0f */
+/* no use */
+#define DI_ARB_CTRL                       ((0x170f)) /* << 2) + 0xd0100000) */
+/* bit 31:26,			di_arb_thd1 */
+/* bit 25:20,			di_arb_thd0 */
+/* bit 19,			di_arb_tid_mode */
+/* bit 18,			di_arb_arb_mode */
+/* bit 17,			di_arb_acq_en */
+/* bit 16,			di_arb_disable_clk */
+/* bit 15:0,			di_arb_req_en */
+#define DI_BLEND_REG0_X                   ((0x1710)) /* << 2) + 0xd0100000) */
+/* bit 27:16,   blend_reg0_startx */
+/* bit 11:0,    blend_reg0_endx */
+#define DI_BLEND_REG0_Y                   ((0x1711)) /* << 2) + 0xd0100000) */
+#define DI_BLEND_REG1_X                   ((0x1712)) /* << 2) + 0xd0100000) */
+#define DI_BLEND_REG1_Y                   ((0x1713)) /* << 2) + 0xd0100000) */
+#define DI_BLEND_REG2_X                   ((0x1714)) /* << 2) + 0xd0100000) */
+#define DI_BLEND_REG2_Y                   ((0x1715)) /* << 2) + 0xd0100000) */
+#define DI_BLEND_REG3_X                   ((0x1716)) /* << 2) + 0xd0100000) */
+#define DI_BLEND_REG3_Y                   ((0x1717)) /* << 2) + 0xd0100000) */
+#define DI_CLKG_CTRL                      ((0x1718)) /* << 2) + 0xd0100000) */
+/* bit 31:24,   pre_gclk_ctrl     no clk gate control. if ==1,
+module clk is not gated (always on). [3] for pulldown,[2]
+for mtn_1,[1] for mtn_0,[0] for nr */
+/* bit 23:16,   post_gclk_ctrl    no clk gate control. [4]
+for ei_1, [3] for ei_0,[2] for ei_top, [1] for blend_1, [0] for blend_0 */
+/* bit 1,       di_gate_all       clk shut down. if ==1 ,
+all di clock shut down */
+/* bit 0,       di_no_clk_gate    no clk gate control.
+if di_gated_all==0 and di_no_clk_gate ==1, all di clock is always working. */
+#define DI_EI_CTRL3                       ((0x1719)) /* << 2) + 0xd0100000) */
+/* bit 31,      reg_ei_1 */
+/* bit 30,      reg_demon_en */
+/* bit 26:24,   reg_demon_mux */
+/* bit 23:20,   reg_right_win */
+/* bit 19:16,   reg_left_win */
+/* bit 7:4,     reg_ei_sadm_quatize_margin */
+/* bit 1:0,     reg_ei_sad_relative_mode */
+#define DI_EI_CTRL4                       ((0x171a)) /* << 2) + 0xd0100000) */
+/* bit 29,      reg_ei_caldrt_ambliike2_biasvertical */
+/* bit 28:24,   reg_ei_caldrt_addxla2list_drtmax */
+/* bit 22:20,   reg_ei_caldrt_addxla2list_signm0th */
+/* bit 19,      reg_ei_caldrt_addxla2list_mode */
+/* bit 18:16,   reg_ei_signm_sad_cor_rate */
+/* bit 15:12,   reg_ei_signm_sadi_cor_rate */
+/* bit 11:6,    reg_ei_signm_sadi_cor_ofst */
+/* bit 5:0,     reg_ei_signm_sad_ofst */
+#define DI_EI_CTRL5                       ((0x171b)) /* << 2) + 0xd0100000) */
+/* bit 30:28,   reg_ei_caldrt_cnflcctchk_frcverthrd */
+/* bit 26:24,   reg_ei_caldrt_cnflctchk_mg */
+/* bit 23:22,   reg_ei_caldrt_cnflctchk_ws */
+/* bit 21,      reg_ei_caldrt_cnflctchk_en */
+/* bit 20,      reg_ei_caldrt_verfrc_final_en */
+/* bit 19,      reg_ei_caldrt_verfrc_retimflt_en */
+/* bit 18:16,   reg_ei_caldrt_verftc_eithratemth */
+/* bit 15,      reg_ei_caldrt_verfrc_retiming_en */
+/* bit 14:12,   reg_ei_caldrt_verfrc_bothratemth */
+/* bit 11:9,    reg_ei_caldrt_ver_thrd */
+/* bit 8:4,     reg_ei_caldrt_addxla2list_drtmin */
+/* bit 3:0,     reg_ei_caldrt_addxla2list_drtlimit */
+#define DI_EI_CTRL6                       ((0x171c)) /* << 2) + 0xd0100000) */
+/* bit 31:24,   reg_ei_caldrt_abext_sad12thhig */
+/* bit 23:16,   reg_ei_caldrt_abext_sad00thlow */
+/* bit 15:8,    reg_ei_caldrt_abext_sad12thlow */
+/* bit 6:4,     reg_ei_caldrt_abext_ratemth */
+/* bit 2:0,     reg_ei_caldrt_abext_drtthrd */
+#define DI_EI_CTRL7                       ((0x171d)) /* << 2) + 0xd0100000) */
+/* bit 29,      reg_ei_caldrt_xlanopeak_codien */
+/* bit 28:24,   reg_ei_caldrt_xlanopeak_drtmax */
+/* bit 23,      reg_ei_caldrt_xlanopeak_en */
+/* bit 28:24,   reg_ei_caldrt_abext_monotrnd_alpha */
+/* bit 28:24,   reg_ei_caldrt_abext_mononum12_thrd */
+/* bit 28:24,   reg_ei_caldrt_abext_mononum00_thrd */
+/* bit 28:24,   reg_ei_caldrt_abext_sad00rate */
+/* bit 28:24,   reg_ei_caldrt_abext_sad12rate */
+/* bit 28:24,   reg_ei_caldrt_abext_sad00thhig */
+#define DI_EI_CTRL8                       ((0x171e)) /* << 2) + 0xd0100000) */
+/* bit 30:28,   reg_ei_assign_headtail_magin */
+/* bit 26:24,   reg_ei_retime_lastcurpncnfltchk_mode */
+/* bit 22:21,   reg_ei_retime_lastcurpncnfltchk_drtth */
+/* bit 20,      reg_ei_caldrt_histchk_cnfid */
+/* bit 19:16,   reg_ei_caldrt_histchk_thrd */
+/* bit 15,      reg_ei_caldrt_histchk_abext */
+/* bit 14,      reg_ei_caldrt_histchk_npen */
+/* bit 13:11,   reg_ei_caldrt_amblike2_drtmg */
+/* bit 10:8,    reg_ei_caldrt_amblike2_valmg */
+/* bit 7:4,     reg_ei_caldrt_amblike2_alpha */
+/* bit 3:0,     reg_ei_caldrt_amblike2_drtth */
+#define DI_EI_CTRL9                       ((0x171f)) /* << 2) + 0xd0100000) */
+/* bit 31:28,   reg_ei_caldrt_hcnfcheck_frcvert_xla_th3 */
+/* bit 27,      reg_ei_caldrt_hcnfcheck_frcvert_xla_en */
+/* bit 26:24,   reg_ei_caldrt_conf_drtth */
+/* bit 23:20,   reg_ei_caldrt_conf_absdrtth */
+/* bit 19:18,   reg_ei_caldrt_abcheck_mode1 */
+/* bit 17:16,   reg_ei_caldrt_abcheck_mode0 */
+/* bit 15:12,   reg_ei_caldrt_abcheck_drth1 */
+/* bit 11:8,    reg_ei_caldrt_abcheck_drth0 */
+/* bit 6:4,     reg_ei_caldrt_abpnchk1_th */
+/* bit 1,       reg_ei_caldrt_abpnchk1_en */
+/* bit 0,       reg_ei_caldrt_abpnchk0_en */
+#define DI_EI_CTRL10                      ((0x1793)) /* << 2) + 0xd0100000) */
+/* bit 31:28,   reg_ei_caldrt_hstrrgchk_drtth */
+/* bit 27:24,   reg_ei_caldrt_hstrrgchk_frcverthrd */
+/* bit 23:20,   reg_ei_caldrt_hstrrgchk_mg */
+/* bit 19,      reg_ei_caldrt_hstrrgchk_1sidnul */
+/* bit 18,      reg_ei_caldrt_hstrrgchk_excpcnf */
+/* bit 17:16,   reg_ei_caldrt_hstrrgchk_ws */
+/* bit 15,      reg_ei_caldrt_hstrrgchk_en */
+/* bit 14:13,   reg_ei_caldrt_hpncheck_mode */
+/* bit 12,      reg_ei_caldrt_hpncheck_mute */
+/* bit 11:9,    reg_ei_caldrt_hcnfcheck_mg2 */
+/* bit 8:6,     reg_ei_caldrt_hcnfcheck_mg1 */
+/* bit 5:4,     reg_ei_caldrt_hcnfcheck_mode */
+/* bit 3:0,     reg_ei_caldrt_hcnfcheck_mg2 */
+#define DI_EI_CTRL11                      ((0x179e)) /* << 2) + 0xd0100000) */
+/* bit 30:29,   reg_ei_amb_detect_mode */
+/* bit 28:24,   reg_ei_amb_detect_winth */
+/* bit 23:21,   reg_ei_amb_decide_rppth */
+/* bit 20:19,   reg_ei_retime_lastmappncnfltchk_drtth */
+/* bit 18:16,   reg_ei_retime_lastmappncnfltchk_mode */
+/* bit 15:14,   reg_ei_retime_lastmapvertfrcchk_mode */
+/* bit 13:12,   reg_ei_retime_lastvertfrcchk_mode */
+/* bit 11:8,    reg_ei_retime_lastpnchk_drtth */
+/* bit 6,       reg_ei_retime_lastpnchk_en */
+/* bit 5:4,     reg_ei_retime_mode */
+/* bit 3,       reg_ei_retime_last_en */
+/* bit 2,       reg_ei_retime_ab_en */
+/* bit 1,       reg_ei_caldrt_hstrvertfrcchk_en */
+/* bit 0,       reg_ei_caldrt_hstrrgchk_mode */
+#define DI_EI_CTRL12                      ((0x179f)) /* << 2) + 0xd0100000) */
+/* bit 31:28,   reg_ei_drtdelay2_lmt */
+/* bit 27:26,   reg_ei_drtdelay2_notver_lrwin */
+/* bit 25:24,   reg_ei_drtdelay_mode */
+/* bit 23,      reg_ei_drtdelay2_mode */
+/* bit 22:20,   reg_ei_assign_xla_signm0th */
+/* bit 19,      reg_ei_assign_pkbiasvert_en */
+/* bit 18,      reg_ei_assign_xla_en */
+/* bit 17:16,   reg_ei_assign_xla_mode */
+/* bit 15:12,   reg_ei_assign_nlfilter_magin */
+/* bit 11:8,    reg_ei_localsearch_maxrange */
+/* bit 7:4,     reg_ei_xla_drtth */
+/* bit 3:0,     reg_ei_flatmsad_thrd */
+#define DI_EI_CTRL13                      ((0x17a8)) /* << 2) + 0xd0100000) */
+/* bit 27:24,   reg_ei_int_drt2x_chrdrt_limit */
+/* bit 23:20,   reg_ei_int_drt16x_core */
+/* bit 19:16,   reg_ei_int_drtdelay2_notver_cancv */
+/* bit 15:8,    reg_ei_int_drtdelay2_notver_sadth */
+/* bit 7:0,     reg_ei_int_drtdelay2_vlddrt_sadth */
+#define DI_EI_XWIN0                       ((0x1798)) /* << 2) + 0xd0100000) */
+/* bit 27:16,   ei_xend0 */
+/* bit 11:0,    ei_xstart0 */
+#define DI_EI_XWIN1                       ((0x1799)) /* << 2) + 0xd0100000) */
+/* DEINTERLACE mode check. */
+#define DI_MC_REG0_X                      ((0x1720)) /* << 2) + 0xd0100000) */
+/* bit 27:16,   mc_reg0_start_x */
+/* bit 11:0,    mc_reg0_end_x */
+#define DI_MC_REG0_Y                      ((0x1721)) /* << 2) + 0xd0100000) */
+#define DI_MC_REG1_X                      ((0x1722)) /* << 2) + 0xd0100000) */
+#define DI_MC_REG1_Y                      ((0x1723)) /* << 2) + 0xd0100000) */
+#define DI_MC_REG2_X                      ((0x1724)) /* << 2) + 0xd0100000) */
+#define DI_MC_REG2_Y                      ((0x1725)) /* << 2) + 0xd0100000) */
+#define DI_MC_REG3_X                      ((0x1726)) /* << 2) + 0xd0100000) */
+#define DI_MC_REG3_Y                      ((0x1727)) /* << 2) + 0xd0100000) */
+#define DI_MC_REG4_X                      ((0x1728)) /* << 2) + 0xd0100000) */
+#define DI_MC_REG4_Y                      ((0x1729)) /* << 2) + 0xd0100000) */
+#define DI_MC_32LVL0                      ((0x172a)) /* << 2) + 0xd0100000) */
+/* bit 31:24,   mc_reg2_32lvl */
+/* bit 23:16,   mc_reg1_32lvl */
+/* bit 15:8,    mc_reg0_32lvl */
+/* bit 7:0,     field_32lvl */
+#define DI_MC_32LVL1                      ((0x172b)) /* << 2) + 0xd0100000) */
+/* bit 15:8,    mc_reg3_32lvl */
+/* bit 7:0,     mc_reg4_32lvl */
+#define DI_MC_22LVL0                      ((0x172c)) /* << 2) + 0xd0100000) */
+/* bit 31:16,   mc_reg0_22lvl */
+/* bit 15:0,    field_22lvl */
+#define DI_MC_22LVL1                      ((0x172d)) /* << 2) + 0xd0100000) */
+/* bit 31:16,   mc_reg2_22lvl */
+/* bit 15:0,    mc_reg1_22lvl */
+#define DI_MC_22LVL2                      ((0x172e)) /* << 2) + 0xd0100000) */
+/* bit 31:16,   mc_reg4_22lvl */
+/* bit 15:0,    mc_reg3_22lvl */
+#define DI_MC_CTRL                        ((0x172f)) /* << 2) + 0xd0100000) */
+/* bit 4,       mc_reg4_en */
+/* bit 3,       mc_reg3_en */
+/* bit 2,       mc_reg2_en */
+/* bit 1,       mc_reg1_en */
+/* bit 0,       mc_reg0_en */
+#define DI_INTR_CTRL                      ((0x1730)) /* << 2) + 0xd0100000) */
+#define DI_INFO_ADDR                      ((0x1731)) /* << 2) + 0xd0100000) */
+#define DI_INFO_DATA                      ((0x1732)) /* << 2) + 0xd0100000) */
+#define DI_PRE_HOLD                       ((0x1733)) /* << 2) + 0xd0100000) */
+#define DI_MTN_1_CTRL1                    ((0x1740)) /* << 2) + 0xd0100000) */
+/* bit 31,      mtn_1_en */
+/* bit 30,      mtn_init */
+/* bit 29,      di2nr_txt_en */
+/* bit 28,      di2nr_txt_mode */
+/* bit 27:24,   mtn_def */
+/* bit 23:16,   mtn_adp_yc */
+/* bit 15:8,    mtn_adp_2c */
+/* bit 7:0,     mtn_adp_2y */
+#define DI_MTN_1_CTRL2                    ((0x1741)) /* << 2) + 0xd0100000) */
+/* bit 31:24,   mtn_ykinter */
+/* bit 23:16,   mtn_ckinter */
+/* bit 15:8,    mtn_ykintra */
+/* bit  7:0,    mtn_ckintra */
+#define DI_MTN_1_CTRL3                    ((0x1742)) /* << 2) + 0xd0100000) */
+/* bit 31:24,   mtn_tyrate */
+/* bit 23:16,   mtn_tcrate */
+/* bit 15: 8,   mtn_mxcmby */
+/* bit  7: 0,   mtn_mxcmbc */
+#define DI_MTN_1_CTRL4                    ((0x1743)) /* << 2) + 0xd0100000) */
+/* bit 31:24,   mtn_tcorey */
+/* bit 23:16,   mtn_tcorec */
+/* bit 15: 8,   mtn_minth */
+/* bit  7: 0,   mtn_maxth */
+#define DI_MTN_1_CTRL5                    ((0x1744)) /* << 2) + 0xd0100000) */
+/* bit 31:28,   mtn_m1b_extnd */
+/* bit 27:24,   mtn_m1b_errod */
+/* bit 19:18,   mtn_replace_cbyy */
+/* bit 17:16,   mtn_replace_ybyc */
+/* bit 15: 8,   mtn_core_ykinter */
+/* bit  7: 0,   mtn_core_ckinter */
+#define DI_MTN_1_CTRL6                    ((0x17a9)) /* << 2) + 0xd0100000) */
+/* bit 31:24,   mtn_m1b_extnd */
+/* bit 23:16,   mtn_m1b_errod */
+/* bit 15: 8,   mtn_core_ykinter */
+/* bit  7: 0,   mtn_core_ckinter */
+#define DI_MTN_1_CTRL7                    ((0x17aa)) /* << 2) + 0xd0100000) */
+/* bit 31:24,   mtn_core_mxcmby */
+/* bit 23:16,   mtn_core_mxcmbc */
+/* bit 15: 8,   mtn_core_y */
+/* bit  7: 0,   mtn_core_c */
+#define DI_MTN_1_CTRL8                    ((0x17ab)) /* << 2) + 0xd0100000) */
+/* bit 31:24,   mtn_fcore_ykinter */
+/* bit 23:16,   mtn_fcore_ckinter */
+/* bit 15: 8,   mtn_fcore_ykintra */
+/* bit  7: 0,   mtn_fcore_ckintra */
+#define DI_MTN_1_CTRL9                    ((0x17ac)) /* << 2) + 0xd0100000) */
+/* bit 31:24,   mtn_fcore_2yrate */
+/* bit 23:16,   mtn_fcore_2crate */
+/* bit 15: 8,   mtn_fcore_y */
+/* bit  7: 0,   mtn_fcore_c */
+#define DI_MTN_1_CTRL10                   ((0x17ad)) /* << 2) + 0xd0100000) */
+/* bit 27:24,   mtn_motfld0 */
+/* bit 19:16,   mtn_stlfld0 */
+/* bit 11: 8,   mtn_motfld1 */
+/* bit  3: 0,   mtn_stlfld1 */
+#define DI_MTN_1_CTRL11                   ((0x17ae)) /* << 2) + 0xd0100000) */
+/* bit 27:24,   mtn_smotevn */
+/* bit 20:16,   mtn_smotodd */
+/* bit 11: 8,   mtn_sstlevn */
+/* bit  4: 0,   mtn_sstlodd */
+#define DI_MTN_1_CTRL12                   ((0x17af)) /* << 2) + 0xd0100000) */
+/* bit 31:24,   mtn_mgain */
+/* bit 17:16,   mtn_mmode */
+/* bit 15: 8,   mtn_sthrd */
+/* bit  4: 0,   mtn_sgain */
+/* // DET 3D REG DEFINE BEGIN //// */
+/* // 8'h34~8'h3f */
+#define DET3D_MOTN_CFG                    ((0x1734)) /* << 2) + 0xd0100000) */
+/* Bit 16,	reg_det3d_intr_en	        Det3d interrupt enable */
+/* Bit 9:8,	reg_Det3D_Motion_Mode
+U2  Different mode for Motion Calculation of Luma and Chroma: */
+/* 0: MotY, 1: (2*MotY + (MotU + MotV))/4;
+2: Max(MotY, MotU,MotV); 3:Max(MotY, (MotU+MotV)/2) */
+/* Bit 7:4,	reg_Det3D_Motion_Core_Rate	U4  K Rate to Edge (HV) details
+for coring of Motion Calculations, normalized to 32 */
+/* Bit 3:0,	reg_Det3D_Motion_Core_Thrd
+U4  2X: static coring value for Motion Detection. */
+#define DET3D_CB_CFG                      ((0x1735)) /* << 2) + 0xd0100000) */
+/* Bit 7:4,	reg_Det3D_ChessBd_NHV_ofst
+U4,  Noise immune offset for NON-Horizotnal or vertical combing detection. */
+/* Bit 3:0,	reg_Det3D_ChessBd_HV_ofst
+U4,  Noise immune offset for Horizotnal or vertical combing detection. */
+#define DET3D_SPLT_CFG                    ((0x1736)) /* << 2) + 0xd0100000) */
+/* Bit 7:4,	reg_Det3D_SplitValid_ratio
+U4,  Ratio between max_value and the avg_value of
+the edge mapping for split line valid detection. */
+/* The smaller of this value, the easier of the split line detected. */
+/* Bit 3:0,	reg_Det3D_AvgIdx_ratio	    U4,Ratio to the avg_value of the
+edge mapping for split line position estimation. */
+/* The smaller of this value,
+the more samples will be added to the estimation. */
+#define DET3D_HV_MUTE                     ((0x1737)) /* << 2) + 0xd0100000) */
+/* Bit 23:20, reg_Det3D_Edge_Ver_Mute	U4  X2: Horizontal pixels to be mute
+from H/V Edge calculation Top and Bottom border part. */
+/* Bit 19:16, reg_Det3D_Edge_Hor_Mute	U4  X2: Horizontal pixels to be mute
+from H/V Edge calculation Left and right border part. */
+/* Bit 15:12, reg_Det3D_ChessBd_Ver_Mute	U4  X2: Horizontal pixels to
+be mute from ChessBoard statistics calculation in middle part */
+/* Bit 11:8,	 reg_Det3D_ChessBd_Hor_Mute	U4  X2: Horizontal pixels to
+be mute from ChessBoard statistics calculation in middle part */
+/* Bit 7:4,	 reg_Det3D_STA8X8_Ver_Mute	U4  1X: Vertical pixels to be
+mute from 8x8 statistics calculation in each block. */
+/* Bit 3:0,	 reg_Det3D_STA8X8_Hor_Mute	U4  1X: Horizontal pixels to
+be mute from 8x8 statistics calculation in each block. */
+#define DET3D_MAT_STA_P1M1                ((0x1738)) /* << 2) + 0xd0100000) */
+/* Bit 31:24, reg_Det3D_STA8X8_P1_K0_R8	U8  SAD to SAI ratio to decide P1,
+normalized to 256 (0.8) */
+/* Bit 23:16, reg_Det3D_STA8X8_P1_K1_R7	U8  SAD to ENG ratio to decide P1,
+normalized to 128 (0.5) */
+/* Bit 15:8,	 reg_Det3D_STA8X8_M1_K0_R6
+U8  SAD to SAI ratio to decide M1, normalized to 64  (1.1) */
+/* Bit 7:0,	 reg_Det3D_STA8X8_M1_K1_R6
+U8  SAD to ENG ratio to decide M1, normalized to 64  (0.8) */
+#define DET3D_MAT_STA_P1TH                ((0x1739)) /* << 2) + 0xd0100000) */
+/* Bit 23:16, reg_Det3D_STAYUV_P1_TH_L4	U8  SAD to ENG Thrd offset to
+decide P1, X16         (100) */
+/* Bit 15:8,	 reg_Det3D_STAEDG_P1_TH_L4	U8  SAD to ENG Thrd
+offset to decide P1, X16         (80) */
+/* Bit 7:0,	 reg_Det3D_STAMOT_P1_TH_L4	U8  SAD to ENG Thrd
+offset to decide P1, X16         (48) */
+#define DET3D_MAT_STA_M1TH                ((0x173a)) /* << 2) + 0xd0100000) */
+/* Bit 23:16, reg_Det3D_STAYUV_M1_TH_L4	U8  SAD to
+ENG Thrd offset to decide M1, X16         (100) */
+/* Bit 15:8,	 reg_Det3D_STAEDG_M1_TH_L4
+U8  SAD to ENG Thrd offset to decide M1, X16         (80) */
+/* Bit 7:0,	 reg_Det3D_STAMOT_M1_TH_L4
+U8  SAD to ENG Thrd offset to decide M1, X16         (64) */
+#define DET3D_MAT_STA_RSFT                ((0x173b)) /* << 2) + 0xd0100000) */
+/* Bit 5:4,	 reg_Det3D_STAYUV_RSHFT	    U2  YUV statistics SAD and SAI
+calculation result right shift bits to accommodate the 12bits clipping: */
+/* 0: mainly for images <=720x480: 1: mainly for images <=1366x768: 2: mainly
+for images <=1920X1080: 2; 3: other higher resolutions */
+/* Bit 3:2,	 reg_Det3D_STAEDG_RSHFT	    U2  Horizontal and Vertical Edge
+Statistics SAD and SAI calculation result right shift bits to
+accommodate the 12bits clipping: */
+/* 0: mainly for images <=720x480: 1: mainly for images <=1366x768:
+2: mainly for images <=1920X1080: 2; 3: other higher resolutions */
+/* Bit 1:0,	 reg_Det3D_STAMOT_RSHFT	    U2  Motion SAD and SAI
+calculation result right shift bits to accommodate the 12bits clipping: */
+/* 0: mainly for images <=720x480: 1: mainly for images <=1366x768:
+2: mainly for images <=1920X1080: 2; 3: other higher resolutions */
+#define DET3D_MAT_SYMTC_TH                ((0x173c)) /* << 2) + 0xd0100000) */
+/* Bit 31:24, reg_Det3D_STALUM_symtc_Th	  U8  threshold to decide
+if the Luma statistics is TB or LR symmetric. */
+/* Bit 23:16, reg_Det3D_STACHR_symtc_Th	  U8  threshold to decide
+if the Chroma (UV) statistics is TB or LR symmetric. */
+/* Bit 15:8,	 reg_Det3D_STAEDG_symtc_Th	  U8  threshold to
+decide if the Horizontal and Vertical Edge statistics is TB or LR symmetric. */
+/* Bit 7:0,	 reg_Det3D_STAMOT_symtc_Th	  U8  threshold to
+decide if the Motion statistics is TB or LR symmetric. */
+#define DET3D_RO_DET_CB_HOR               ((0x173d)) /* << 2) + 0xd0100000) */
+/* Bit 31:16, RO_Det3D_ChessBd_NHor_value    U16  X64: number of Pixels
+of Horizontally Surely NOT matching Chessboard pattern. */
+/* Bit 15:0,	 RO_Det3D_ChessBd_Hor_value	    U16  X64: number of
+Pixels of Horizontally Surely matching Chessboard pattern. */
+#define DET3D_RO_DET_CB_VER               ((0x173e)) /* << 2) + 0xd0100000) */
+/* Bit 31:16, RO_Det3D_ChessBd_NVer_value	U16  X64: number of
+Pixels of Vertically Surely NOT matching Chessboard pattern. */
+/* Bit 15:0,	 RO_Det3D_ChessBd_Ver_value	    U16  X64: number
+of Pixels of Vertically Surely matching Chessboard pattern. */
+#define DET3D_RO_SPLT_HT                  ((0x173f)) /* << 2) + 0xd0100000) */
+/* Bit 24,	 RO_Det3D_Split_HT_valid	U1  horizontal LR split border
+detected valid signal for top half picture */
+/* Bit 20:16, RO_Det3D_Split_HT_pxnum	U5  number of pixels included for the
+LR split position estimation for top half picture */
+/* Bit 9:0,	 RO_Det3D_Split_HT_idxX4	S10  X4: horizontal pixel
+shifts of LR split position to the (ColMax/2) for top half picture */
+/* // DET 3D REG DEFINE END //// */
+/* // NR2 REG DEFINE BEGIN//// */
+#define NR2_MET_NM_CTRL                   ((0x1745)) /* << 2) + 0xd0100000) */
+/* Bit 28,	   reg_NM_reset	     Reset to the status of the Loop filter. */
+/* Bit 27:24,   reg_NM_calc_length	  Length mode of the Noise
+measurement sample number for statistics. */
+/* 0:  256 samples;    1: 512 samples;    2: 1024 samples;
+X: 2^(8+x) samples */
+/* Bit 23:20,   reg_NM_inc_step	      Loop filter input gain increase step. */
+/* Bit 19:16,   reg_NM_dec_step	      Loop filter input gain decrease step. */
+/* Bit 15:8,	   reg_NM_YHPmot_thrd	  Luma channel HP portion motion
+for condition of pixels included in Luma Noise measurement. */
+/* Bit 7:0,	   reg_NM_CHPmot_thrd	  Chroma channel HP portion motion
+for condition of pixels included in Chroma Noise measurement. */
+#define NR2_MET_NM_YCTRL                  ((0x1746)) /* << 2) + 0xd0100000) */
+/* Bit 31:28,   reg_NM_YPLL_target	      Target rate of
+NM_Ynoise_thrd to mean of the Luma Noise */
+/* Bit 27:24,   reg_NM_YLPmot_thrd	      Luma channel LP
+portion motion for condition of pixels included in Luma Noise measurement. */
+/* Bit 23:16,   reg_NM_YHPmot_thrd_min	  Minimum threshold for
+Luma channel HP portion motion to decide whether the pixel
+will be included in Luma noise measurement. */
+/* Bit 15:8,	   reg_NM_YHPmot_thrd_max	  Maximum threshold for Luma
+channel HP portion motion to decide whether the pixel will be included in
+Luma noise measurement. */
+/* Bit 7:0,	   reg_NM_Ylock_rate	      Rate to decide whether the
+Luma noise measurement is lock or not. */
+#define NR2_MET_NM_CCTRL                  ((0x1747)) /* << 2) + 0xd0100000) */
+/* Bit 31:28,	reg_NM_CPLL_target
+Target rate of NM_Cnoise_thrd to mean of the Chroma Noise */
+/* Bit 27:24,	reg_NM_CLPmot_thrd	     Chroma channel LP portion motion
+for condition of pixels included in Chroma Noise measurement. */
+/* Bit 23:16,	reg_NM_CHPmot_thrd_min	 Minimum threshold for Chroma channel
+HP portion motion to decide whether the pixel will be included in Chroma noise
+measurement. */
+/* Bit 15:8,	    reg_NM_CHPmot_thrd_max	 Maximum threshold for Chroma
+channel HP portion motion to decide whether the pixel will be included in
+Chroma noise measurement. */
+/* Bit 7:0,	    reg_NM_Clock_rate	     Rate to decide whether the Chroma
+noise measurement is lock or not; */
+#define NR2_MET_NM_TNR                    ((0x1748)) /* << 2) + 0xd0100000) */
+/* Bit 25,	    ro_NM_TNR_Ylock	         Read-only register to tell
+ifLuma channel noise measurement is locked or not. */
+/* Bit 24,	    ro_NM_TNR_Clock	         Read-only register to tell
+if Chroma channel noise measurement is locked or not. */
+/* Bit 23:12,	ro_NM_TNR_Ylevel	     Read-only register to give Luma
+channel noise level. It was 16x of pixel difference in 8 bits of YHPmot. */
+/* Bit 11:0,	ro_NM_TNR_ClevelRead-only register to give Chroma channel noise
+level.It was 16x of pixel difference in 8 bits of CHPmot. */
+#define NR2_MET_NMFRM_TNR_YLEV            ((0x1749)) /* << 2) + 0xd0100000) */
+/* Bit 28:0,	ro_NMFrm_TNR_Ylevel	         Frame based Read-only register
+to give Luma channel noise level within one frame/field. */
+#define NR2_MET_NMFRM_TNR_YCNT            ((0x174a)) /* << 2) + 0xd0100000) */
+/* Bit 23:0,	ro_NMFrm_TNR_Ycount	         Number ofLuma channel pixels
+included in Frame/Field based noise level measurement. */
+#define NR2_MET_NMFRM_TNR_CLEV            ((0x174b)) /* << 2) + 0xd0100000) */
+/* Bit 28:0,	ro_NMFrm_TNR_Clevel	         Frame based Read-only register
+to give Chroma channel noise level within one frame/field. */
+#define NR2_MET_NMFRM_TNR_CCNT            ((0x174c)) /* << 2) + 0xd0100000) */
+/* Bit 23:0,	ro_NMFrm_TNR_Ccount	         Number of Chroma channel pixels
+included in Frame/Field based noise level measurement. */
+#define NR2_3DEN_MODE                     ((0x174d)) /* << 2) + 0xd0100000) */
+/* Bit 6:4,	Blend_3dnr_en_r */
+/* Bit 2:0,	Blend_3dnr_en_l */
+#define NR2_IIR_CTRL                      ((0x174e)) /* << 2) + 0xd0100000) */
+/* Bit 15:14, reg_LP_IIR_8bit_mode	LP IIR membitwidth mode:0: 10bits will
+be store in memory;1: 9bits will be store in memory; */
+/* 2: 8bits will be store in memory;3: 7bits will be store in memory; */
+/* Bit 13:12, reg_LP_IIR_mute_mode	Mode for the LP IIR mute, */
+/* Bit 11:8,reg_LP_IIR_mute_thrd Threshold of LP IIR mute to avoid ghost: */
+/* Bit 7:6,	 reg_HP_IIR_8bit_mode	IIR membitwidth mode:0: 10bits will be
+store in memory;1: 9bits will be store in memory; */
+/* 2: 8bits will be store in memory;3: 7bits will be store in memory; */
+/* Bit 5:4,	reg_HP_IIR_mute_mode	Mode for theLP IIR mute */
+/* Bit 3:0,reg_HP_IIR_mute_thrd	Threshold of HP IIR mute to avoid ghost */
+/*  */
+#define NR2_SW_EN                         ((0x174f)) /* << 2) + 0xd0100000) */
+/* Bit 17:8,	Clk_gate_ctrl */
+/* Bit 7,	Cfr_enable */
+/* Bit 5,	Det3d_en */
+/* Bit 4,	Nr2_proc_en */
+/* Bit 0,	Nr2_sw_en */
+#define NR2_FRM_SIZE                      ((0x1750)) /* << 2) + 0xd0100000) */
+/* Bit 27:16,  Frm_heigh	Frame/field height */
+/* Bit 11: 0,  Frm_width	Frame/field width */
+#define NR2_SNR_SAD_CFG                   ((0x1751)) /* << 2) + 0xd0100000) */
+/* Bit 12,	reg_MATNR_SNR_SAD_CenRPL	U1, Enable signal for Current
+pixel position SAD to be replaced by SAD_min.0: do not replace Current pixel
+position SAD by SAD_min;1: do replacements */
+/* Bit 11:8,	reg_MATNR_SNR_SAD_coring	Coring value of the intra-frame
+SAD. sum = (sum - reg_MATNR_SNR_SAD_coring);
+sum = (sum<0) ? 0: (sum>255)? 255: sum; */
+/* Bit 6:5,	reg_MATNR_SNR_SAD_WinMod	Unsigned, Intra-frame SAD
+matching window mode:0: 1x1; 1: [1 1 1] 2: [1 2 1]; 3: [1 2 2 2 1]; */
+/* Bit 4:0,	Sad_coef_num	            Sad coeffient */
+#define NR2_MATNR_SNR_OS                  ((0x1752)) /* << 2) + 0xd0100000) */
+/* Bit 7:4,	reg_MATNR_SNR_COS	    SNR Filter overshoot control
+margin for UV channel (X2 to u10 scale) */
+/* Bit 3:0,	reg_MATNR_SNR_YOS	    SNR Filter overshoot control
+margin for luma channel (X2 to u10 scale) */
+#define NR2_MATNR_SNR_NRM_CFG             ((0x1753)) /* << 2) + 0xd0100000) */
+/* Bit 23:16,	reg_MATNR_SNR_NRM_ofst	Edge based SNR
+boosting normalization offset to SAD_max ; */
+/* Bit 15:8,	    reg_MATNR_SNR_NRM_max
+Edge based SNR boosting normalization Max value */
+/* Bit 7:0,	    reg_MATNR_SNR_NRM_min
+Edge based SNR boosting normalization Min value */
+#define NR2_MATNR_SNR_NRM_GAIN            ((0x1754)) /* << 2) + 0xd0100000) */
+/* Bit 15:8,	reg_MATNR_SNR_NRM_Cgain	Edge based SNR boosting
+normalization Gain for Chrm channel (norm 32 as 1) */
+/* Bit 7:0,	reg_MATNR_SNR_NRM_Ygain	Edge based SNR boosting
+normalization Gain for Luma channel (norm 32 as 1) */
+#define NR2_MATNR_SNR_LPF_CFG             ((0x1755)) /* << 2) + 0xd0100000) */
+/* Bit 23:16,reg_MATNR_SNRLPF_SADmaxTH	U8,  Threshold to SADmax to use TNRLPF
+to replace SNRLPF. i.e.if (SAD_max<reg_MATNR_SNRLPF_SADmaxTH)
+SNRLPF_yuv[k] = TNRLPF_yuv[k]; */
+/* Bit 13:11,reg_MATNR_SNRLPF_Cmode
+LPF based SNR filtering mode on CHRM channel: */
+/* 0: gradient LPF [1 1]/2, 1: gradient LPF [2 1 1]/4;
+2: gradient LPF [3 3 2]/8; 3: gradient LPF [5 4 4 3]/16; */
+/* 4: TNRLPF;  5 : CurLPF3x3_yuv[];  6: CurLPF3o3_yuv[]  7: CurLPF3x5_yuv[] */
+/* Bit 10:8,	reg_MATNR_SNRLPF_Ymode
+LPF based SNR filtering mode on LUMA channel: */
+/* 0: gradient LPF //Bit [1 1]/2, 1: gradient LPF [2 1 1]/4;
+2: gradient LPF [3 3 2]/8;3: gradient LPF [5 4 4 3]/16; */
+/* 4: TNRLPF;               5 : CurLPF3x3_yuv[];
+6: CurLPF3o3_yuv[]         7: CurLPF3x5_yuv[] */
+/* Bit 7:4,	reg_MATNR_SNRLPF_SADmin3TH	Offset threshold to SAD_min to
+Discard SAD_min3 corresponding pixel in LPF SNR filtering. (X8 to u8 scale) */
+/* Bit 3:0,	reg_MATNR_SNRLPF_SADmin2TH	Offset threshold to SAD_min to
+Discard SAD_min2 corresponding pixel in LPF SNR filtering. (X8 to u8 scale) */
+#define NR2_MATNR_SNR_USF_GAIN           ((0x1756)) /* << 2) + 0xd0100000) */
+/* Bit 15:8,	reg_MATNR_SNR_USF_Cgain
+Un-sharp (HP) compensate back Chrm portion gain, (norm 64 as 1) */
+/* Bit 7:0,	reg_MATNR_SNR_USF_Ygain
+Un-sharp (HP) compensate back Luma portion gain, (norm 64 as 1) */
+#define NR2_MATNR_SNR_EDGE2B             ((0x1757)) /* << 2) + 0xd0100000) */
+/* Bit 15:8,	reg_MATNR_SNR_Edge2Beta_ofst	U8,
+Offset for Beta based on Edge. */
+/* Bit 7:0,	reg_MATNR_SNR_Edge2Beta_gain	U8.
+Gain to SAD_min for Beta based on Edge. (norm 16 as 1) */
+#define NR2_MATNR_BETA_EGAIN             ((0x1758)) /* << 2) + 0xd0100000) */
+/* Bit 15:8,	reg_MATNR_CBeta_Egain	U8,
+Gain to Edge based Beta for Chrm channel. (normalized to 32 as 1) */
+/* Bit 7:0,	reg_MATNR_YBeta_Egain	U8,
+Gain to Edge based Beta for Luma channel. (normalized to 32 as 1) */
+#define NR2_MATNR_BETA_BRT               ((0x1759)) /* << 2) + 0xd0100000) */
+/* Bit 31:28,	reg_MATNR_beta_BRT_limt_hi	U4,
+Beta adjustment based on Brightness high side Limit. (X16 to u8 scale) */
+/* Bit 27:24,	reg_MATNR_beta_BRT_slop_hi	U4,
+Beta adjustment based on Brightness high side slope. Normalized to 16 as 1 */
+/* Bit 23:16,	reg_MATNR_beta_BRT_thrd_hi	U8,
+Beta adjustment based on Brightness high threshold.(u8 scale) */
+/* Bit 15:12,	reg_MATNR_beta_BRT_limt_lo	U4,
+Beta adjustment based on Brightness low side Limit. (X16 to u8 scale) */
+/* Bit 11:8,	    reg_MATNR_beta_BRT_slop_lo	U4,
+Beta adjustment based on Brightness low side slope. Normalized to 16 as 1 */
+/* Bit 7:0,	    reg_MATNR_beta_BRT_thrd_lo	U8,
+Beta adjustment based on Brightness low threshold.(u8 scale) */
+#define NR2_MATNR_XBETA_CFG              ((0x175a)) /* << 2) + 0xd0100000) */
+/* Bit 19:18,	reg_MATNR_CBeta_use_mode	U2,
+Beta options (mux) from beta_motion and beta_edge for Chrm channel; */
+/* Bit 17:16,	reg_MATNR_YBeta_use_mode	U2,
+Beta options (mux) from beta_motion and beta_edge for Luma channel; */
+/* Bit 15: 8,	reg_MATNR_CBeta_Ofst	    U8,
+Offset to Beta for Chrm channel.(after beta_edge and beta_motion mux) */
+/* Bit  7: 0,	reg_MATNR_YBeta_Ofst	    U8,
+Offset to Beta for Luma channel.(after beta_edge and beta_motion mux) */
+#define NR2_MATNR_YBETA_SCL              ((0x175b)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_YBeta_scale_min	U8,
+Final step Beta scale low limit for Luma channel; */
+/* Bit 23:16,	reg_MATNR_YBeta_scale_max	U8,
+Final step Beta scale high limit for Luma channe; */
+/* Bit 15: 8,	reg_MATNR_YBeta_scale_gain	U8,
+Final step Beta scale Gain for Luma channel (normalized 32 to 1); */
+/* Bit 7 : 0,	reg_MATNR_YBeta_scale_ofst	S8,
+Final step Beta scale offset for Luma channel ; */
+#define NR2_MATNR_CBETA_SCL              ((0x175c)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_CBeta_scale_min
+Final step Beta scale low limit for Chrm channel.Similar to Y */
+/* Bit 23:16,	reg_MATNR_CBeta_scale_max	U8,
+Final step Beta scale high limit for Chrm channel.Similar to Y */
+/* Bit 15: 8,	reg_MATNR_CBeta_scale_gain	U8,
+Final step Beta scale Gain for Chrm channel Similar to Y */
+/* Bit  7: 0,	reg_MATNR_CBeta_scale_ofst	S8,
+Final step Beta scale offset for Chrm channel Similar to Y */
+#define NR2_SNR_MASK                     ((0x175d)) /* << 2) + 0xd0100000) */
+/* Bit 20:0,	SAD_MSK	                 Valid signal in the 3x7 SAD surface */
+#define NR2_SAD2NORM_LUT0                ((0x175e)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_SAD2Norm_LUT_3
+SAD convert normal LUT node 3 */
+/* Bit 23:16,	reg_MATNR_SAD2Norm_LUT_2
+SAD convert normal LUT node 2 */
+/* Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_1
+SAD convert normal LUT node 1 */
+/* Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_0
+SAD convert normal LUT node 0 */
+#define NR2_SAD2NORM_LUT1                ((0x175f)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_SAD2Norm_LUT_7
+SAD convert normal LUT node 7 */
+/* Bit 23:16,	reg_MATNR_SAD2Norm_LUT_6
+SAD convert normal LUT node 6 */
+/* Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_5
+SAD convert normal LUT node 5 */
+/* Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_4
+SAD convert normal LUT node 4 */
+#define NR2_SAD2NORM_LUT2                ((0x1760)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_SAD2Norm_LUT_11
+SAD convert normal LUT node 11 */
+/* Bit 23:16,	reg_MATNR_SAD2Norm_LUT_10
+SAD convert normal LUT node 10 */
+/* Bit 15: 8,	reg_MATNR_SAD2Norm_LUT_9
+SAD convert normal LUT node 9 */
+/* Bit  7: 0,	reg_MATNR_SAD2Norm_LUT_8
+SAD convert normal LUT node 8 */
+#define NR2_SAD2NORM_LUT3                ((0x1761)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_SAD2Norm_LUT_15 SAD convert normal LUT node 15 */
+/* Bit 23:16,	reg_MATNR_SAD2Norm_LUT_14 SAD convert normal LUT node 14 */
+/* Bit 15:8,	reg_MATNR_SAD2Norm_LUT_13 SAD convert normal LUT node 13 */
+/* Bit 7:0,	reg_MATNR_SAD2Norm_LUT_12 SAD convert normal LUT node 12 */
+#define NR2_EDGE2BETA_LUT0               ((0x1762)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_Edge2Beta_LUT_3 Edge convert beta LUT node 3 */
+/* Bit 23:16,	reg_MATNR_Edge2Beta_LUT_2 Edge convert beta LUT node 2 */
+/* Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_1 Edge convert beta LUT node 1 */
+/* Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_0 Edge convert beta LUT node 0 */
+#define NR2_EDGE2BETA_LUT1               ((0x1763)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_Edge2Beta_LUT_7 Edge convert beta LUT node 7 */
+/* Bit 23:16,	reg_MATNR_Edge2Beta_LUT_6 Edge convert beta LUT node 6 */
+/* Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_5 Edge convert beta LUT node 5 */
+/* Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_4 Edge convert beta LUT node 4 */
+#define NR2_EDGE2BETA_LUT2               ((0x1764)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_Edge2Beta_LUT_11 Edge convert beta LUT node 11 */
+/* Bit 23:16,	reg_MATNR_Edge2Beta_LUT_10 Edge convert beta LUT node 10 */
+/* Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_9  Edge convert beta LUT node 9 */
+/* Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_8  Edge convert beta LUT node 8 */
+#define NR2_EDGE2BETA_LUT3               ((0x1765)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_Edge2Beta_LUT_15 Edge convert beta LUT node 15 */
+/* Bit 23:16,	reg_MATNR_Edge2Beta_LUT_14 Edge convert beta LUT node 14 */
+/* Bit 15: 8,	reg_MATNR_Edge2Beta_LUT_13 Edge convert beta LUT node 13 */
+/* Bit  7: 0,	reg_MATNR_Edge2Beta_LUT_12 Edge convert beta LUT node 12 */
+#define NR2_MOTION2BETA_LUT0             ((0x1766)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_Mot2Beta_LUT_3 Motion convert beta LUT node 3 */
+/* Bit 23:16,	reg_MATNR_Mot2Beta_LUT_2 Motion convert beta LUT node 2 */
+/* Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_1 Motion convert beta LUT node 1 */
+/* Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_0 Motion convert beta LUT node 0 */
+#define NR2_MOTION2BETA_LUT1             ((0x1767)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_Mot2Beta_LUT_7 Motion convert beta LUT node 7 */
+/* Bit 23:16,	reg_MATNR_Mot2Beta_LUT_6 Motion convert beta LUT node 6 */
+/* Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_5 Motion convert beta LUT node 5 */
+/* Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_4 Motion convert beta LUT node 4 */
+#define NR2_MOTION2BETA_LUT2             ((0x1768)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_Mot2Beta_LUT_11 Motion convert beta LUT node 11 */
+/* Bit 23:16,	reg_MATNR_Mot2Beta_LUT_10 Motion convert beta LUT node 10 */
+/* Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_9  Motion convert beta LUT node 9 */
+/* Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_8  Motion convert beta LUT node 8 */
+#define NR2_MOTION2BETA_LUT3             ((0x1769)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_Mot2Beta_LUT_15 Motion convert beta LUT node 15 */
+/* Bit 23:16,	reg_MATNR_Mot2Beta_LUT_14 Motion convert beta LUT node 14 */
+/* Bit 15: 8,	reg_MATNR_Mot2Beta_LUT_13 Motion convert beta LUT node 13 */
+/* Bit  7: 0,	reg_MATNR_Mot2Beta_LUT_12 Motion convert beta LUT node 12 */
+#define NR2_MATNR_MTN_CRTL               ((0x176a)) /* << 2) + 0xd0100000) */
+/* Bit 25:24,	reg_MATNR_Vmtn_use_mode	    Motion_yuvV channel motion selection
+mode:0: Vmot;1:Ymot/2 + (Umot+Vmot)/4;
+2:Ymot/2 + max(Umot,Vmot)/2; 3: max(Ymot,Umot, Vmot) */
+/* Bit 21:20,	reg_MATNR_Umtn_use_mode	    Motion_yuvU channel motion selection
+mode:0:Umot;1:Ymot/2 + (Umot+Vmot)/4;
+2:Ymot/2 + max(Umot,Vmot)/2; 3: max(Ymot,Umot, Vmot) */
+/* Bit 17:16,	reg_MATNR_Ymtn_use_mode	 Motion_yuvLuma channel motion selection
+mode:0:  Ymot, 1: Ymot/2 + (Umot+Vmot)/4;
+2: Ymot/2 + max(Umot,Vmot)/2; 3:  max(Ymot,Umot, Vmot) */
+/* Bit 13:12,	reg_MATNR_mtn_txt_mode
+Texture detection mode for adaptive coring of HP motion */
+/* Bit  9: 8,	reg_MATNR_mtn_cor_mode
+Coring selection mode based on texture detection; */
+/* Bit  6: 4,	reg_MATNR_mtn_hpf_mode
+video mode of current and previous frame/field for MotHPF_yuv[k] calculation: */
+/* Bit  2: 0,	reg_MATNR_mtn_lpf_mode	LPF video mode of current and previous
+frame/field for MotLPF_yuv[k] calculation: */
+#define NR2_MATNR_MTN_CRTL2              ((0x176b)) /* << 2) + 0xd0100000) */
+/* Bit 18:16,	reg_MATNR_iir_BS_Ymode	    IIR TNR filter Band split filter
+mode for Luma LPF result generation (Cur and Prev); */
+/* Bit 15: 8,	reg_MATNR_mtnb_alpLP_Cgain	Scale of motion_brthp_uv to
+motion_brtlp_uv, normalized to 32 as 1 */
+/* Bit  7: 0,	reg_MATNR_mtnb_alpLP_Ygain	Scale of motion_brthp_y to
+motion_brtlp_y, normalized to 32 as 1 */
+#define NR2_MATNR_MTN_COR                ((0x176c)) /* << 2) + 0xd0100000) */
+/* Bit 15:12,	reg_MATNR_mtn_cor_Cofst	    Coring Offset for Chroma Motion. */
+/* Bit 11: 8,	reg_MATNR_mtn_cor_Cgain	    Gain to texture based coring for
+Chroma Motion. Normalized to 16 as 1 */
+/* Bit  7: 4,	reg_MATNR_mtn_cor_Yofst	    Coring Offset for Luma Motion. */
+/* Bit  3: 0,	reg_MATNR_mtn_cor_Ygain	    Gain to texture based coring for
+Luma Motion. Normalized to 16 as 1 */
+#define NR2_MATNR_MTN_GAIN               ((0x176d)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_mtn_hp_Cgain	Gain to MotHPF_yuv[k] Chrm channel for
+motion calculation, normalized to 64 as 1 */
+/* Bit 23:16,	reg_MATNR_mtn_hp_Ygain	Gain to MotHPF_yuv[k] Luma channel for
+motion calculation, normalized to 64 as 1 */
+/* Bit 15: 8,	reg_MATNR_mtn_lp_Cgain	Gain to MotLPF_yuv[k] Chrm channel for
+motion calculation, normalized to 32 as 1 */
+/* Bit  7: 0,	reg_MATNR_mtn_lp_Ygain	Gain to MotLPF_yuv[k] Luma channel for
+motion calculation, normalized to 32 as 1 */
+#define NR2_MATNR_DEGHOST                ((0x176e)) /* << 2) + 0xd0100000) */
+/* Bit 8,	reg_MATNR_DeGhost_En
+Enable signal for DeGhost function:0: disable; 1: enable */
+/* Bit 7:4,	reg_MATNR_DeGhost_COS
+DeGhost Overshoot margin for UV channel, (X2 to u10 scale) */
+/* Bit 3:0,	reg_MATNR_DeGhost_YOS
+DeGhost Overshoot margin for Luma channel, (X2 to u10 scale) */
+#define NR2_MATNR_ALPHALP_LUT0           ((0x176f)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_AlphaLP_LUT_3
+Matnr low-pass filter alpha LUT node 3 */
+/* Bit 23:16,	reg_MATNR_AlphaLP_LUT_2
+Matnr low-pass filter alpha LUT node 2 */
+/* Bit 15: 8,	reg_MATNR_AlphaLP_LUT_1
+Matnr low-pass filter alpha LUT node 1 */
+/* Bit  7: 0,	reg_MATNR_AlphaLP_LUT_0
+Matnr low-pass filter alpha LUT node 0 */
+#define NR2_MATNR_ALPHALP_LUT1           ((0x1770)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_AlphaLP_LUT_7
+Matnr low-pass filter alpha LUT node 7 */
+/* Bit 23:16,	reg_MATNR_AlphaLP_LUT_6
+Matnr low-pass filter alpha LUT node 6 */
+/* Bit 15: 8,	reg_MATNR_AlphaLP_LUT_5
+Matnr low-pass filter alpha LUT node 5 */
+/* Bit  7: 0,	reg_MATNR_AlphaLP_LUT_4
+Matnr low-pass filter alpha LUT node 4 */
+#define NR2_MATNR_ALPHALP_LUT2           ((0x1771)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_AlphaLP_LUT_11
+Matnr low-pass filter alpha LUT node 11 */
+/* Bit 23:16,	reg_MATNR_AlphaLP_LUT_10
+Matnr low-pass filter alpha LUT node 10 */
+/* Bit 15: 8,	reg_MATNR_AlphaLP_LUT_9
+Matnr low-pass filter alpha LUT node 9 */
+/* Bit  7: 0,	reg_MATNR_AlphaLP_LUT_8
+Matnr low-pass filter alpha LUT node 8 */
+#define NR2_MATNR_ALPHALP_LUT3           ((0x1772)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_AlphaLP_LUT_15
+Matnr low-pass filter alpha LUT node 15 */
+/* Bit 23:16,	reg_MATNR_AlphaLP_LUT_14
+Matnr low-pass filter alpha LUT node 14 */
+/* Bit 15: 8,	reg_MATNR_AlphaLP_LUT_13
+Matnr low-pass filter alpha LUT node 13 */
+/* Bit  7: 0,	reg_MATNR_AlphaLP_LUT_12
+Matnr low-pass filter alpha LUT node 12 */
+#define NR2_MATNR_ALPHAHP_LUT0           ((0x1773)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_AlphaHP_LUT_3
+Matnr high-pass filter alpha LUT node 3 */
+/* Bit 23:16,	reg_MATNR_AlphaHP_LUT_2
+Matnr high-pass filter alpha LUT node 2 */
+/* Bit 15: 8,	reg_MATNR_AlphaHP_LUT_1
+Matnr high-pass filter alpha LUT node 1 */
+/* Bit  7: 0,	reg_MATNR_AlphaHP_LUT_0
+Matnr high-pass filter alpha LUT node 0 */
+#define NR2_MATNR_ALPHAHP_LUT1           ((0x1774)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_AlphaHP_LUT_7
+Matnr high-pass filter alpha LUT node 7 */
+/* Bit 23:16,	reg_MATNR_AlphaHP_LUT_6
+Matnr high-pass filter alpha LUT node 6 */
+/* Bit 15: 8,	reg_MATNR_AlphaHP_LUT_5
+Matnr high-pass filter alpha LUT node 5 */
+/* Bit  7: 0,	reg_MATNR_AlphaHP_LUT_4
+Matnr high-pass filter alpha LUT node 4 */
+#define NR2_MATNR_ALPHAHP_LUT2           ((0x1775)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_AlphaHP_LUT_11
+Matnr high-pass filter alpha LUT node 11 */
+/* Bit 23:16,	reg_MATNR_AlphaHP_LUT_10
+Matnr high-pass filter alpha LUT node 10 */
+/* Bit 15: 8,	reg_MATNR_AlphaHP_LUT_9
+Matnr high-pass filter alpha LUT node 9 */
+/* Bit  7: 0,	reg_MATNR_AlphaHP_LUT_8
+Matnr high-pass filter alpha LUT node 8 */
+#define NR2_MATNR_ALPHAHP_LUT3           ((0x1776)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_MATNR_AlphaHP_LUT_15
+Matnr high-pass filter alpha LUT node 15 */
+/* Bit 23:16,	reg_MATNR_AlphaHP_LUT_14
+Matnr high-pass filter alpha LUT node 14 */
+/* Bit 15: 8,	reg_MATNR_AlphaHP_LUT_13
+Matnr high-pass filter alpha LUT node 13 */
+/* Bit  7: 0,	reg_MATNR_AlphaHP_LUT_12
+Matnr high-pass filter alpha LUT node 12 */
+#define NR2_MATNR_MTNB_BRT               ((0x1777)) /* << 2) + 0xd0100000) */
+/* Bit 31:28,	reg_MATNR_mtnb_BRT_limt_hi	Motion adjustment based on
+Brightness high side Limit. (X16 to u8 scale) */
+/* Bit 27:24,	reg_MATNR_mtnb_BRT_slop_hi	Motion adjustment based on
+Brightness high side slope. Normalized to 16 as 1 */
+/* Bit 23:16,	reg_MATNR_mtnb_BRT_thrd_hi	Motion adjustment based on
+Brightness high threshold.(u8 scale) */
+/* Bit 15:12,	reg_MATNR_mtnb_BRT_limt_lo	Motion adjustment based on
+Brightness low side Limit. (X16 to u8 scale) */
+/* Bit 11: 8,	reg_MATNR_mtnb_BRT_slop_lo	Motion adjustment based on
+Brightness low side slope. Normalized to 16 as 1 */
+/* Bit  7: 0,	reg_MATNR_mtnb_BRT_thrd_lo	Motion adjustment based on
+Brightness low threshold.(u8 scale) */
+#define NR2_CUE_MODE                     ((0x1778)) /* << 2) + 0xd0100000) */
+/* Bit 9,	Cue_enable_r	        Cue right half frame enable */
+/* Bit 8,	Cue_enable_l            Cue left half frame enable */
+/* Bit 6:4,	reg_CUE_CON_RPLC_mode	U3, CUE pixel chroma replace mode; */
+/* Bit 2:0,	reg_CUE_CHRM_FLT_mode	U3, CUE improvement filter mode, */
+#define NR2_CUE_CON_MOT_TH               ((0x1779)) /* << 2) + 0xd0100000) */
+/* Bit 31:24,	reg_CUE_CON_Cmot_thrd2	U8,  Motion Detection threshold of
+up/down two rows,  Chroma channel in Chroma Up-sampling Error (CUE)
+Detection (tighter). */
+/* Bit 23:16,	reg_CUE_CON_Ymot_thrd2	U8,  Motion Detection threshold of
+up/mid/down three rows,  Luma channel in Chroma Up-sampling Error (CUE)
+Detection (tighter). */
+/* Bit 15: 8,	reg_CUE_CON_Cmot_thrd	U8,  Motion Detection threshold of
+up/down two rows, Chroma channel in Chroma Up-sampling Error (CUE) Detection. */
+/* Bit  7: 0,	reg_CUE_CON_Ymot_thrd	U8,  Motion Detection threshold of
+up/mid/down three rows, Luma channel in
+Chroma Up-sampling Error (CUE) Detection. */
+#define NR2_CUE_CON_DIF0                 ((0x177a)) /* << 2) + 0xd0100000) */
+/* Bit 15:8,	reg_CUE_CON_difP1_thrd	    U8,  P1 field Intra-Field top/below
+line chroma difference threshold, */
+/* Bit 7:0,	reg_CUE_CON_difCur_thrd	    U8,  Current Field/Frame Intra-Field
+up/down line chroma difference threshold, */
+#define NR2_CUE_CON_DIF1                 ((0x177b)) /* << 2) + 0xd0100000) */
+/* Bit 19:16,	reg_CUE_CON_rate0	    U4,  The Krate to decide CUE by
+relationship between CUE_diflG and CUE_difEG */
+/* Bit 15: 8,	reg_CUE_CON_difEG_thrd	U8,  Theshold to the difference between
+current Field/Frame middle line to down line color channel(CUE_difEG). */
+/* Bit  7: 0,	reg_CUE_CON_diflG_thrd	U8,  Threshold to the difference between
+P1 field top line to current Field/Frame down line color channel (CUE_diflG). */
+#define NR2_CUE_CON_DIF2                 ((0x177c)) /* << 2) + 0xd0100000) */
+/* Bit 19:16,	reg_CUE_CON_rate1	    U4,  The Krate to decide CUE by
+relationship between CUE_difnC and CUE_difEC */
+/* Bit 15: 8,	reg_CUE_CON_difEC_thrd	U8,  Theshold to the difference between
+current Field/Frame middle line to up line color channel(CUE_difEC). */
+/* Bit  7: 0,	reg_CUE_CON_difnC_thrd	U8,  Threshold to the difference between
+P1 field bot line to current Field/Frame up line color channel (CUE_difnC). */
+#define NR2_CUE_CON_DIF3                 ((0x177d)) /* << 2) + 0xd0100000) */
+/* Bit 19:16,	reg_CUE_CON_rate2	    U4,  The Krate to decide CUE by
+relationship between CUE_difP1 and CUE_difEP1 */
+/* Bit 15: 8,	reg_CUE_CON_difEP1_thrd	U8,  Inter-Field top/below line to
+current field/frame middle line chroma difference (CUE_difEP1) threshold. */
+/* Bit  7: 0,	reg_CUE_CON_difP1_thrd2	U8,  P1 field Intra-Field top/below line
+chroma difference threshold (tighter), */
+#define NR2_CUE_PRG_DIF                  ((0x177e)) /* << 2) + 0xd0100000) */
+/* Bit 20,	    reg_CUE_PRG_Enable	    Enable bit for progressive video CUE
+detection.If interlace input video, */
+/* Bit 19:16,	reg_CUE_PRG_rate	    U3,  The Krate to decide CUE by
+relationship between CUE_difCur and (CUE_difEC+CUE_difEG) */
+/* Bit 15: 8,	reg_CUE_PRG_difCEG_thrd	U8, Current Frame Intra-Field up-mid and
+mid-down line chroma difference threshold
+for progressive video CUE detection, */
+/* Bit  7: 0,	reg_CUE_PRG_difCur_thrd	U8,  Current Frame Intra-Field up/down
+line chroma difference threshold, */
+#define NR2_CONV_MODE                    ((0x177f)) /* << 2) + 0xd0100000) */
+/* Bit 3:2,	Conv_c444_mode
+The format convert mode about 422 to 444 when data read out line buffer */
+/* Bit 1:0,	Conv_c422_mode
+the format convert mode about 444 to 422 when data write to line buffer */
+/* // NR2 REG DEFINE END //// */
+/* // DET 3D REG DEFINE BEGIN //// */
+/* //  8'h80~8'h8f */
+#define DET3D_RO_SPLT_HB                 ((0x1780)) /* << 2) + 0xd0100000) */
+/* Bit 24,	    RO_Det3D_Split_HB_valid
+U1   horizontal LR split border detected valid signal for top half picture */
+/* Bit 20:16,	RO_Det3D_Split_HB_pxnum	    U5   number of pixels included for
+the LR split position estimation for top half picture */
+/* Bit  9: 0,	RO_Det3D_Split_HB_idxX4	    S10  X4: horizontal pixel shifts of
+LR split position to the (ColMax/2) for top half picture */
+#define DET3D_RO_SPLT_VL                 ((0x1781)) /* << 2) + 0xd0100000) */
+/* Bit 24,	    RO_Det3D_Split_VL_valid	    U1   horizontal LR split
+border detected valid signal for top half picture */
+/* Bit 20:16,	RO_Det3D_Split_VL_pxnum	    U5   number of pixels included for
+the LR split position estimation for top half picture */
+/* Bit  9: 0,	RO_Det3D_Split_VL_idxX4	    S10  X4: horizontal pixel shifts of
+LR split position to the (ColMax/2) for top half picture */
+#define DET3D_RO_SPLT_VR                 ((0x1782)) /* << 2) + 0xd0100000) */
+/* Bit 24   ,	RO_Det3D_Split_VR_valid	    U1   horizontal LR split border
+detected valid signal for top half picture */
+/* Bit 20:16,	RO_Det3D_Split_VR_pxnum	    U5   number of pixels included for
+the LR split position estimation for top half picture */
+/* Bit  9: 0,	RO_Det3D_Split_VR_idxX4	    S10  X4: horizontal pixel shifts of
+LR split position to the (ColMax/2) for top half picture */
+#define DET3D_RO_MAT_LUMA_LR             ((0x1783)) /* << 2) + 0xd0100000) */
+/* Bit 15:0,	RO_Luma_LR_score	 S2*8  LUMA statistics left right
+decision score for each band (8bands vertically), */
+/* it can be -1/0/1:-1: most likely not LR symmetric 0: not sure
+1: most likely LR symmetric */
+/* Bit 7:0,	RO_Luma_LR_symtc	 U1*8  Luma statistics left
+right pure symmetric for each band (8bands vertically), */
+/* it can be 0/1: 0: not sure 1: most likely LR is pure symmetric */
+/* Bit 4:0,	RO_Luma_LR_sum	     S5  Total score of 8x8 Luma
+statistics for LR like decision, */
+/* the larger this score, the more confidence that this is a LR 3D video.
+It is sum of  RO_Luma_LR_score[0~7] */
+#define DET3D_RO_MAT_LUMA_TB             ((0x1784)) /* << 2) + 0xd0100000) */
+/* Bit 15:0,	RO_Luma_TB_score	 S2*8  LUMA statistics Top/Bottom
+decision score for each band (8bands Horizontally), */
+/* Bit 7:0,	RO_Luma_TB_symtc	 Luma statistics Top/Bottompure
+symmetric for each band (8bands Horizontally), */
+/* Bit 4:0,	RO_Luma_TB_sum
+Total score of 8x8 Luma statistics for TB like decision, */
+#define DET3D_RO_MAT_CHRU_LR             ((0x1785)) /* << 2) + 0xd0100000) */
+/* Bit 15:0,	RO_ChrU_LR_score	S2*8  LUMA statistics left right
+decision score for each band (8bands vertically), */
+/* Bit 7:0,	RO_ChrU_LR_symtc	CHRU statistics left right pure
+symmetric for each band (8bands vertically), */
+/* Bit 4:0,	RO_ChrU_LR_sum
+Total score of 8x8 ChrU statistics for LR like decision, */
+#define DET3D_RO_MAT_CHRU_TB             ((0x1786)) /* << 2) + 0xd0100000) */
+/* Bit 15:0,	RO_ChrU_TB_score	S2*8  CHRU statistics Top/Bottom
+decision score for each band (8bands Horizontally) */
+/* Bit 7:0,	RO_ChrU_TB_symtc	CHRU statistics Top/Bottompure symmetric
+for each band (8bands Horizontally) */
+/* Bit 4:0,	RO_ChrU_TB_sum
+Total score of 8x8 ChrU statistics for TB like decision */
+#define DET3D_RO_MAT_CHRV_LR             ((0x1787)) /* << 2) + 0xd0100000) */
+/* Bit 15:0,	RO_ChrV_LR_score	S2*8  CHRUstatistics left right decision
+score for each band (8bands vertically) */
+/* Bit 7:0,	RO_ChrV_LR_symtc	CHRV statistics left right pure
+symmetric for each band (8bands vertically) */
+/* Bit 4:0,	RO_ChrV_LR_sum
+Total score of 8x8 ChrV statistics for LR like decision */
+#define DET3D_RO_MAT_CHRV_TB             ((0x1788)) /* << 2) + 0xd0100000) */
+/* Bit 15:0,	RO_ChrV_TB_score	CHRV statistics Top/Bottom decision
+score for each band (8bands Horizontally) */
+/* Bit 7:0,	RO_ChrV_TB_symtc	CHRV statistics Top/Bottompure
+symmetric for each band (8bands Horizontally) */
+/* Bit 4:0,	RO_ChrV_TB_sum	    Total score of 8x8 ChrV statistics
+for TB like decision */
+#define DET3D_RO_MAT_HEDG_LR             ((0x1789)) /* << 2) + 0xd0100000) */
+/* Bit 15:0,	RO_Hedg_LR_score	Horizontal Edge statistics left right
+decision score for each band (8bands vertically) */
+/* Bit 7:0,	RO_Hedg_LR_symtc	Horizontal Edge statistics left right
+pure symmetric for each band (8bands vertically) */
+/* Bit 4:0,	RO_Hedg_LR_sum	    Total score of 8x8 Hedg statistics for
+LR like decision */
+#define DET3D_RO_MAT_HEDG_TB             ((0x178a)) /* << 2) + 0xd0100000) */
+/* Bit 15:0,	RO_Hedg_TB_score	Horizontal Edge statistics Top/Bottom
+decision score for each band (8bands Horizontally) */
+/* Bit 7:0,	RO_Hedg_TB_symtc	Horizontal Edge statistics
+Top/Bottompure symmetric for each band (8bands Horizontally) */
+/* Bit 4:0,	RO_Hedg_TB_sum
+Total score of 8x8 Hedg statistics for TB like decision */
+#define DET3D_RO_MAT_VEDG_LR             ((0x178b)) /* << 2) + 0xd0100000) */
+/* Bit 15:0,	RO_Vedg_LR_score	Vertical Edge statistics left right
+decision score for each band (8bands vertically) */
+/* Bit 7:0,	RO_Vedg_LR_symtc	Vertical Edge statistics left right
+pure symmetric for each band (8bands vertically) */
+/* Bit 4:0,	RO_Vedg_LR_sum
+Total score of 8x8 Vedg statistics for LR like decision */
+#define DET3D_RO_MAT_VEDG_TB             ((0x178c)) /* << 2) + 0xd0100000) */
+/* Bit 15:0,	RO_Vedg_TB_score	Vertical Edge statistics Top/Bottom
+decision score for each band (8bands Horizontally) */
+/* Bit 7:0,	RO_Vedg_TB_symtc	Vertical Edge statistics Top/Bottompure
+symmetric for each band (8bands Horizontally) */
+/* Bit 4:0,	RO_Vedg_TB_sum
+Total score of 8x8 Vedg statistics for TB like decision */
+#define DET3D_RO_MAT_MOTN_LR             ((0x178d)) /* << 2) + 0xd0100000) */
+/* Bit 15:0,	RO_Motn_LR_score	Motion statistics left right decision
+score for each band (8bands vertically) */
+/* Bit 7:0,	RO_Motn_LR_symtc	Motion statistics left right pure
+symmetric for each band (8bands vertically) */
+/* Bit 4:0,	RO_Motn_LR_sum	    Total score of 8x8 Motion statistics for
+LR like decision */
+#define DET3D_RO_MAT_MOTN_TB             ((0x178e)) /* << 2) + 0xd0100000) */
+/* Bit 15:0,	RO_Motn_TB_score	Motion statistics Top/Bottom decision
+score for each band (8bands Horizontally) */
+/* Bit 7:0,	RO_Motn_TB_symtc	Motion statistics Top/Bottompure
+symmetric for each band (8bands Horizontally) */
+/* Bit 4:0,	RO_Motn_TB_sum
+Total score of 8x8 Motion statistics for TB like decision */
+#define DET3D_RO_FRM_MOTN                ((0x178f)) /* << 2) + 0xd0100000) */
+/* Bit 15:0,	RO_Det3D_Frame_Motion	U16  frame based motion value sum for
+still image decision in FW. */
+/* / mat ram read enter addr */
+#define DET3D_RAMRD_ADDR_PORT            ((0x179a)) /* << 2) + 0xd0100000) */
+#define DET3D_RAMRD_DATA_PORT            ((0x179b)) /* << 2) + 0xd0100000) */
+#define NR2_CFR_PARA_CFG0                ((0x179c)) /* << 2) + 0xd0100000) */
+/* Bit 8,	reg_CFR_CurDif_luma_mode	Current Field Top/Bot line Luma
+difference calculation mode */
+/* Bit 7:6,	reg_MACFR_frm_phase	        U2  This will be a field based
+phase register that need to be set by FW phase to phase: */
+/* this will be calculated based on dbdr_phase of the
+specific line of this frame. */
+/* u1: dbdr_phase=1, center line is DB in current line;  dbdr_phase=2, center
+line is Dr in current line; */
+/* Bit 5:4,	reg_CFR_CurDif_tran_mode	U2  Current Field Top/Bot line
+Luma/Chroma transition level calculation mode, */
+/* Bit 3:2,	reg_CFR_alpha_mode	        U2  Alpha selection mode for
+CFR block from curAlp and motAlp i.e. 0: motAlp; 1: (motAlp+curAlp)/2;
+2: min(motAlp,curAlp); 3: max(motAlp,curAlp); */
+/* Bit 1:0,	reg_CFR_Motion_Luma_mode	U2  LumaMotion Calculation
+mode for MA-CFR. 0: top/bot Lumma motion;   1: middle Luma Motion
+2: top/bot + middle motion; 3: max(top/tot motion, middle motion) */
+#define NR2_CFR_PARA_CFG1                ((0x179d)) /* << 2) + 0xd0100000) */
+/* Bit 23:16,	reg_CFR_alpha_gain	    gain to map muxed curAlp and motAlp
+to alpha that will be used for final blending. */
+/* Bit 15: 8,	reg_CFR_Motion_ofst	    Offset to Motion to calculate the
+motAlp, e,g:motAlp= reg_CFR_Motion_ofst- Motion;This register can be seen as
+the level of motion that we consider it at moving. */
+/* Bit  7: 0,	reg_CFR_CurDif_gain
+gain to CurDif to map to alpha, normalized to 32; */
+/* // DET 3D REG DEFINE END //// */
+#define DI_NR_1_CTRL0                    ((0x1794)) /* << 2) + 0xd0100000) */
+#define DI_NR_1_CTRL1                    ((0x1795)) /* << 2) + 0xd0100000) */
+#define DI_NR_1_CTRL2                    ((0x1796)) /* << 2) + 0xd0100000) */
+#define DI_NR_1_CTRL3                    ((0x1797)) /* << 2) + 0xd0100000) */
+#define DI_CONTWR_X                      ((0x17a0)) /* << 2) + 0xd0100000) */
+#define DI_CONTWR_Y                      ((0x17a1)) /* << 2) + 0xd0100000) */
+#define DI_CONTWR_CTRL                   ((0x17a2)) /* << 2) + 0xd0100000) */
+#define DI_CONTPRD_X                     ((0x17a3)) /* << 2) + 0xd0100000) */
+#define DI_CONTPRD_Y                     ((0x17a4)) /* << 2) + 0xd0100000) */
+#define DI_CONTP2RD_X                    ((0x17a5)) /* << 2) + 0xd0100000) */
+#define DI_CONTP2RD_Y                    ((0x17a6)) /* << 2) + 0xd0100000) */
+#define DI_CONTRD_CTRL                   ((0x17a7)) /* << 2) + 0xd0100000) */
+#define DI_NRWR_X                        ((0x17c0)) /* << 2) + 0xd0100000) */
+#define DI_NRWR_Y                        ((0x17c1)) /* << 2) + 0xd0100000) */
+/* bit 31:30				nrwr_words_lim */
+/* bit 29				nrwr_rev_y */
+/* bit 28:16				nrwr_start_y */
+/* bit 15				nrwr_ext_en */
+/* bit 14		Nrwr bit10 mode */
+/* bit 12:0				nrwr_end_y */
+#define DI_NRWR_CTRL                     ((0x17c2)) /* << 2) + 0xd0100000) */
+/* bit 31				pending_ddr_wrrsp_diwr */
+/* bit 30				nrwr_reg_swap */
+/* bit 29:26				nrwr_burst_lim */
+/* bit 25				nrwr_canvas_syncen */
+/* bit 24				nrwr_no_clk_gate */
+/* bit 23:22				nrwr_rgb_mode  0:422 to one canvas;
+					1:4:4:4 to one canvas; */
+/* bit 21:20				nrwr_hconv_mode */
+/* bit 19:18				nrwr_vconv_mode */
+/* bit 17				nrwr_swap_cbcr */
+/* bit 16				nrwr_urgent */
+/* bit 15:8				nrwr_canvas_index_chroma */
+/* bit 7:0				nrwr_canvas_index_luma */
+#define DI_MTNWR_X                       ((0x17c3)) /* << 2) + 0xd0100000) */
+#define DI_MTNWR_Y                       ((0x17c4)) /* << 2) + 0xd0100000) */
+#define DI_MTNWR_CTRL                    ((0x17c5)) /* << 2) + 0xd0100000) */
+#define DI_DIWR_X                        ((0x17c6)) /* << 2) + 0xd0100000) */
+#define DI_DIWR_Y                        ((0x17c7)) /* << 2) + 0xd0100000) */
+/* bit 31:30				diwr_words_lim */
+/* bit 29				diwr_rev_y */
+/* bit 28:16				diwr_start_y */
+/* bit 15				diwr_ext_en */
+/* bit 12:0				diwr_end_y */
+#define DI_DIWR_CTRL                     ((0x17c8)) /* << 2) + 0xd0100000) */
+/* bit 31				pending_ddr_wrrsp_diwr */
+/* bit 30				diwr_reg_swap */
+/* bit 29:26				diwr_burst_lim */
+/* bit 25				diwr_canvas_syncen */
+/* bit 24				diwr_no_clk_gate */
+/* bit 23:22				diwr_rgb_mode  0:422 to one canvas;
+1:4:4:4 to one canvas; */
+/* bit 21:20				diwr_hconv_mode */
+/* bit 19:18				diwr_vconv_mode */
+/* bit 17				diwr_swap_cbcr */
+/* bit 16				diwr_urgent */
+/* bit 15:8				diwr_canvas_index_chroma */
+/* bit 7:0				diwr_canvas_index_luma */
+/* `define DI_MTNCRD_X               8'hc9 */
+/* `define DI_MTNCRD_Y               8'hca */
+#define DI_MTNPRD_X                      ((0x17cb)) /* << 2) + 0xd0100000) */
+#define DI_MTNPRD_Y                      ((0x17cc)) /* << 2) + 0xd0100000) */
+#define DI_MTNRD_CTRL                    ((0x17cd)) /* << 2) + 0xd0100000) */
+#define DI_INP_GEN_REG                   ((0x17ce)) /* << 2) + 0xd0100000) */
+#define DI_INP_CANVAS0                   ((0x17cf)) /* << 2) + 0xd0100000) */
+#define DI_INP_LUMA_X0                   ((0x17d0)) /* << 2) + 0xd0100000) */
+#define DI_INP_LUMA_Y0                   ((0x17d1)) /* << 2) + 0xd0100000) */
+#define DI_INP_CHROMA_X0                 ((0x17d2)) /* << 2) + 0xd0100000) */
+#define DI_INP_CHROMA_Y0                 ((0x17d3)) /* << 2) + 0xd0100000) */
+#define DI_INP_RPT_LOOP                  ((0x17d4)) /* << 2) + 0xd0100000) */
+#define DI_INP_LUMA0_RPT_PAT             ((0x17d5)) /* << 2) + 0xd0100000) */
+#define DI_INP_CHROMA0_RPT_PAT           ((0x17d6)) /* << 2) + 0xd0100000) */
+#define DI_INP_DUMMY_PIXEL               ((0x17d7)) /* << 2) + 0xd0100000) */
+#define DI_INP_LUMA_FIFO_SIZE            ((0x17d8)) /* << 2) + 0xd0100000) */
+#define DI_INP_RANGE_MAP_Y               ((0x17ba)) /* << 2) + 0xd0100000) */
+#define DI_INP_RANGE_MAP_CB              ((0x17bb)) /* << 2) + 0xd0100000) */
+#define DI_INP_RANGE_MAP_CR              ((0x17bc)) /* << 2) + 0xd0100000) */
+#define DI_INP_GEN_REG2                  ((0x1791)) /* << 2) + 0xd0100000) */
+#define DI_INP_FMT_CTRL                  ((0x17d9)) /* << 2) + 0xd0100000) */
+#define DI_INP_FMT_W                     ((0x17da)) /* << 2) + 0xd0100000) */
+#define DI_MEM_GEN_REG                   ((0x17db)) /* << 2) + 0xd0100000) */
+#define DI_MEM_CANVAS0                   ((0x17dc)) /* << 2) + 0xd0100000) */
+#define DI_MEM_LUMA_X0                   ((0x17dd)) /* << 2) + 0xd0100000) */
+#define DI_MEM_LUMA_Y0                   ((0x17de)) /* << 2) + 0xd0100000) */
+#define DI_MEM_CHROMA_X0                 ((0x17df)) /* << 2) + 0xd0100000) */
+#define DI_MEM_CHROMA_Y0                 ((0x17e0)) /* << 2) + 0xd0100000) */
+#define DI_MEM_RPT_LOOP                  ((0x17e1)) /* << 2) + 0xd0100000) */
+#define DI_MEM_LUMA0_RPT_PAT             ((0x17e2)) /* << 2) + 0xd0100000) */
+#define DI_MEM_CHROMA0_RPT_PAT           ((0x17e3)) /* << 2) + 0xd0100000) */
+#define DI_MEM_DUMMY_PIXEL               ((0x17e4)) /* << 2) + 0xd0100000) */
+#define DI_MEM_LUMA_FIFO_SIZE            ((0x17e5)) /* << 2) + 0xd0100000) */
+#define DI_MEM_RANGE_MAP_Y               ((0x17bd)) /* << 2) + 0xd0100000) */
+#define DI_MEM_RANGE_MAP_CB              ((0x17be)) /* << 2) + 0xd0100000) */
+#define DI_MEM_RANGE_MAP_CR              ((0x17bf)) /* << 2) + 0xd0100000) */
+#define DI_MEM_GEN_REG2                  ((0x1792)) /* << 2) + 0xd0100000) */
+#define DI_MEM_FMT_CTRL                  ((0x17e6)) /* << 2) + 0xd0100000) */
+#define DI_MEM_FMT_W                     ((0x17e7)) /* << 2) + 0xd0100000) */
+#define DI_IF1_GEN_REG                   ((0x17e8)) /* << 2) + 0xd0100000) */
+#define DI_IF1_CANVAS0                   ((0x17e9)) /* << 2) + 0xd0100000) */
+#define DI_IF1_LUMA_X0                   ((0x17ea)) /* << 2) + 0xd0100000) */
+#define DI_IF1_LUMA_Y0                   ((0x17eb)) /* << 2) + 0xd0100000) */
+#define DI_IF1_CHROMA_X0                 ((0x17ec)) /* << 2) + 0xd0100000) */
+#define DI_IF1_CHROMA_Y0                 ((0x17ed)) /* << 2) + 0xd0100000) */
+#define DI_IF1_RPT_LOOP                  ((0x17ee)) /* << 2) + 0xd0100000) */
+#define DI_IF1_LUMA0_RPT_PAT             ((0x17ef)) /* << 2) + 0xd0100000) */
+#define DI_IF1_CHROMA0_RPT_PAT           ((0x17f0)) /* << 2) + 0xd0100000) */
+#define DI_IF1_DUMMY_PIXEL               ((0x17f1)) /* << 2) + 0xd0100000) */
+#define DI_IF1_LUMA_FIFO_SIZE            ((0x17f2)) /* << 2) + 0xd0100000) */
+#define DI_IF1_RANGE_MAP_Y               ((0x17fc)) /* << 2) + 0xd0100000) */
+#define DI_IF1_RANGE_MAP_CB              ((0x17fd)) /* << 2) + 0xd0100000) */
+#define DI_IF1_RANGE_MAP_CR              ((0x17fe)) /* << 2) + 0xd0100000) */
+#define DI_IF1_GEN_REG2                  ((0x1790)) /* << 2) + 0xd0100000) */
+#define DI_IF1_FMT_CTRL                  ((0x17f3)) /* << 2) + 0xd0100000) */
+#define DI_IF1_FMT_W                     ((0x17f4)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_GEN_REG                 ((0x17f5)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_CANVAS0                 ((0x17f6)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_LUMA_X0                 ((0x17f7)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_LUMA_Y0                 ((0x17f8)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_CHROMA_X0               ((0x17f9)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_CHROMA_Y0               ((0x17fa)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_RPT_LOOP                ((0x17fb)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_LUMA0_RPT_PAT           ((0x17b0)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_CHROMA0_RPT_PAT         ((0x17b1)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_DUMMY_PIXEL             ((0x17b2)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_LUMA_FIFO_SIZE          ((0x17b3)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_RANGE_MAP_Y             ((0x17b4)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_RANGE_MAP_CB            ((0x17b5)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_RANGE_MAP_CR            ((0x17b6)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_GEN_REG2                ((0x17b7)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_FMT_CTRL                ((0x17b8)) /* << 2) + 0xd0100000) */
+#define DI_CHAN2_FMT_W                   ((0x17b9)) /* << 2) + 0xd0100000) */
+#define DI_CANVAS_URGENT0                ((0x170a)) /* << 2) + 0xd0100000) */
+#define DI_CANVAS_URGENT1                ((0x170b)) /* << 2) + 0xd0100000) */
+#define DI_CANVAS_URGENT2                ((0x170e)) /* << 2) + 0xd0100000) */
 
-#define DI_MTN_1_CTRL1					0x1740
-		/* 0xd0105d00 */
-#define DI_MTN_1_CTRL2					0x1741
-		/* 0xd0105d04 */
-#define DI_MTN_1_CTRL3					0x1742
-		/* 0xd0105d08 */
-#define DI_MTN_1_CTRL4					0x1743
-		/* 0xd0105d0c */
-#define DI_MTN_1_CTRL5					0x1744
-		/* 0xd0105d10 */
-/* nr */
-#define NR2_MET_NM_CTRL					0x1745
-		/* 0xd0105d14 */
-#define NR2_MET_NM_YCTRL				0x1746
-		/* 0xd0105d18 */
-#define NR2_MET_NM_CCTRL				0x1747
-		/* 0xd0105d1c */
-#define NR2_MET_NM_TNR					0x1748
-		/* 0xd0105d20 */
-#define NR2_MET_NMFRM_TNR_YLEV			0x1749
-		/* 0xd0105d24 */
-#define NR2_MET_NMFRM_TNR_YCNT			0x174a
-		/* 0xd0105d28 */
-#define NR2_MET_NMFRM_TNR_CLEV			0x174b
-		/* 0xd0105d2c */
-#define NR2_MET_NMFRM_TNR_CCNT			0x174c
-		/* 0xd0105d30 */
-#define NR2_3DEN_MODE					0x174d
-		/* 0xd0105d34 */
-#define NR2_IIR_CTRL					0x174e
-		/* 0xd0105d38 */
-#define NR2_SW_EN						0x174f
-		/* 0xd0105d3c */
-#define NR2_FRM_SIZE					0x1750
-		/* 0xd0105d40 */
-#define NR2_SNR_SAD_CFG					0x1751
-		/* 0xd0105d44 */
-#define NR2_MATNR_SNR_OS				0x1752
-		/* 0xd0105d48 */
-#define NR2_MATNR_SNR_NRM_CFG			0x1753
-		/* 0xd0105d4c */
-#define NR2_MATNR_SNR_NRM_GAIN			0x1754
-		/* 0xd0105d50 */
-#define NR2_MATNR_SNR_LPF_CFG			0x1755
-		/* 0xd0105d54 */
-#define NR2_MATNR_SNR_USF_GAIN			0x1756
-		/* 0xd0105d58 */
-#define NR2_MATNR_SNR_EDGE2B			0x1757
-		/* 0xd0105d5c */
-#define NR2_MATNR_BETA_EGAIN			0x1758
-		/* 0xd0105d60 */
-#define NR2_MATNR_BETA_BRT				0x1759
-		/* 0xd0105d64 */
-#define NR2_MATNR_XBETA_CFG				0x175a
-		/* 0xd0105d68 */
-#define NR2_MATNR_YBETA_SCL				0x175b
-		/* 0xd0105d6c */
-#define NR2_MATNR_CBETA_SCL				0x175c
-		/* 0xd0105d70 */
-#define NR2_SNR_MASK					0x175d
-		/* 0xd0105d74 */
-#define NR2_SAD2NORM_LUT0				0x175e
-		/* 0xd0105d78 */
-#define NR2_SAD2NORM_LUT1				0x175f
-		/* 0xd0105d7c */
-#define NR2_SAD2NORM_LUT2				0x1760
-		/* 0xd0105d80 */
-#define NR2_SAD2NORM_LUT3				0x1761
-		/* 0xd0105d84 */
-#define NR2_EDGE2BETA_LUT0				0x1762
-		/* 0xd0105d88 */
-#define NR2_EDGE2BETA_LUT1				0x1763
-		/* 0xd0105d8c */
-#define NR2_EDGE2BETA_LUT2				0x1764
-		/* 0xd0105d90 */
-#define NR2_EDGE2BETA_LUT3				0x1765
-		/* 0xd0105d94 */
-#define NR2_MOTION2BETA_LUT0			0x1766
-		/* 0xd0105d98 */
-#define NR2_MOTION2BETA_LUT1			0x1767
-		/* 0xd0105d9c */
-#define NR2_MOTION2BETA_LUT2			0x1768
-		/* 0xd0105da0 */
-#define NR2_MOTION2BETA_LUT3			0x1769
-		/* 0xd0105da4 */
-#define NR2_MATNR_MTN_CRTL				0x176a
-		/* 0xd0105da8 */
-#define NR2_MATNR_MTN_CRTL2				0x176b
-		/* 0xd0105dac */
-#define NR2_MATNR_MTN_COR				0x176c
-		/* 0xd0105db0 */
-#define NR2_MATNR_MTN_GAIN				0x176d
-		/* 0xd0105db4 */
-#define NR2_MATNR_DEGHOST				0x176e
-		/* 0xd0105dd8 */
-#define NR2_MATNR_ALPHALP_LUT0			0x176f
-		/* 0xd0105dbc */
-#define NR2_MATNR_ALPHALP_LUT1			0x1770
-		/* 0xd0105dc0 */
-#define NR2_MATNR_ALPHALP_LUT2			0x1771
-		/* 0xd0105dc4 */
-#define NR2_MATNR_ALPHALP_LUT3			0x1772
-		/* 0xd0105dc8 */
-#define NR2_MATNR_ALPHAHP_LUT0			0x1773
-		/* 0xd0105dcc */
-#define NR2_MATNR_ALPHAHP_LUT1			0x1774
-		/* 0xd0105dd0 */
-#define NR2_MATNR_ALPHAHP_LUT2			0x1775
-		/* 0xd0105dd4 */
-#define NR2_MATNR_ALPHAHP_LUT3			0x1776
-		/* 0xd0105dd8 */
-#define NR2_MATNR_MTNB_BRT				0x1777
-		/* 0xd0105ddc */
-#define NR2_CUE_MODE					0x1778
-		/* 0xd0105de0 */
-#define NR2_CUE_CON_MOT_TH				0x1779
-		/* 0xd0105de4 */
-#define NR2_CUE_CON_DIF0				0x177a
-		/* 0xd0105de8 */
-#define NR2_CUE_CON_DIF1				0x177b
-		/* 0xd0105dec */
-#define NR2_CUE_CON_DIF2				0x177c
-		/* 0xd0105df0 */
-#define NR2_CUE_CON_DIF3				0x177d
-		/* 0xd0105df4 */
-#define NR2_CUE_PRG_DIF					0x177e
-		/* 0xd0105df8 */
-#define NR2_CONV_MODE					0x177f
-		/* 0xd0105dfc */
-/* 3d detecton */
-#define DET3D_RO_SPLT_HB				0x1780
-		/* 0xd0105e00 */
-#define DET3D_RO_SPLT_VL				0x1781
-		/* 0xd0105e04 */
-#define DET3D_RO_SPLT_VR				0x1782
-		/* 0xd0105e08 */
-#define DET3D_RO_MAT_LUMA_LR			0x1783
-		/* 0xd0105e0c */
-#define DET3D_RO_MAT_LUMA_TB			0x1784
-		/* 0xd0105e10 */
-#define DET3D_RO_MAT_CHRU_LR			0x1785
-		/* 0xd0105e14 */
-#define DET3D_RO_MAT_CHRU_TB			0x1786
-		/* 0xd0105e18 */
-#define DET3D_RO_MAT_CHRV_LR			0x1787
-		/* 0xd0105e1c */
-#define DET3D_RO_MAT_CHRV_TB			0x1788
-		/* 0xd0105e20 */
-#define DET3D_RO_MAT_HEDG_LR			0x1789
-		/* 0xd0105e24 */
-#define DET3D_RO_MAT_HEDG_TB			0x178a
-		/* 0xd0105e28 */
-#define DET3D_RO_MAT_VEDG_LR			0x178b
-		/* 0xd0105e2c */
-#define DET3D_RO_MAT_VEDG_TB			0x178c
-		/* 0xd0105e30 */
-#define DET3D_RO_MAT_MOTN_LR			0x178d
-		/* 0xd0105e34 */
-#define DET3D_RO_MAT_MOTN_TB			0x178e
-		/* 0xd0105e38 */
-#define DET3D_RO_FRM_MOTN				0x178f
-		/* 0xd0105e3c */
+#define VD1_IF0_GEN_REG				    0x1a50
+/* ((0x1a50  << 2) + 0xd0100000) */
+#define VD1_IF0_LUMA_FIFO_SIZE          0x1a63
+/* ((0x1a63  << 2) + 0xd0100000) */
 
-#define DI_IF1_GEN_REG2					0x1790
-		/* 0xd0105e40 */
-#define DI_INP_GEN_REG2					0x1791
-		/* 0xd0105e44 */
-#define DI_MEM_GEN_REG2					0x1792
-		/* 0xd0105e48 */
-#define DI_EI_CTRL10					0x1793
-		/* 0xd0105e4c */
-#define DI_NR_1_CTRL0					0x1794
-		/* 0xd0105e50 */
-#define DI_NR_1_CTRL1					0x1795
-		/* 0xd0105e54 */
-#define DI_NR_1_CTRL2					0x1796
-		/* 0xd0105e58 */
-#define DI_NR_1_CTRL3					0x1797
-		/* 0xd0105e5c */
-#define DI_EI_XWIN0						0x1798
-		/* 0xd0105e60 */
-#define DI_EI_XWIN1						0x1799
-		/* 0xd0105e64 */
-#define DET3D_RAMRD_ADDR_PORT			0x179a
-		/* 0xd0105e40 */
-#define DET3D_RAMRD_DATA_PORT			0x179b
-		/* 0xd0105e44 */
-#define NR2_CFR_PARA_CFG0				0x179c
-		/* 0xd0105e48 */
-#define NR2_CFR_PARA_CFG1				0x179d
-		/* 0xd0105e4c */
-#define DI_EI_CTRL11					0x179e
-		/* 0xd0105e78 */
-#define DI_EI_CTRL12					0x179f
-		/* 0xd0105e7c */
-/* di mif ctrl */
-#define DI_CONTWR_X						0x17a0
-		/* 0xd0105e80 */
-#define DI_CONTWR_Y						0x17a1
-		/* 0xd0105e84 */
-#define DI_CONTWR_CTRL					0x17a2
-		/* 0xd0105e88 */
-#define DI_CONTPRD_X					0x17a3
-		/* 0xd0105e8c */
-#define DI_CONTPRD_Y					0x17a4
-		/* 0xd0105e90 */
-#define DI_CONTP2RD_X					0x17a5
-		/* 0xd0105e94 */
-#define DI_CONTP2RD_Y					0x17a6
-		/* 0xd0105e98 */
-#define DI_CONTRD_CTRL					0x17a7
-		/* 0xd0105e9c */
+#define VIU_VD1_FMT_CTRL			    0x1a68
+/* ((0x1a68  << 2) + 0xd0100000) */
+/* Bit 31    it true, disable clock, otherwise enable clock        */
+/* Bit 30    soft rst bit */
+/* Bit 28    if true, horizontal formatter use repeating to */
+/* generete pixel, otherwise use bilinear interpolation */
+/* Bit 27:24 horizontal formatter initial phase */
+/* Bit 23    horizontal formatter repeat pixel 0 enable */
+/* Bit 22:21 horizontal Y/C ratio, 00: 1:1, 01: 2:1, 10: 4:1 */
+/* Bit 20    horizontal formatter enable */
+/* Bit 19    if true, always use phase0 while vertical formater, */
+/* meaning always repeat data, no interpolation */
+/* Bit 18    if true, disable vertical formatter chroma repeat last line */
+/* Bit 17    veritcal formatter dont need repeat */
+/* line on phase0, 1: enable, 0: disable */
+/* Bit 16    veritcal formatter repeat line 0 enable */
+/* Bit 15:12 vertical formatter skip line num at the beginning */
+/* Bit 11:8  vertical formatter initial phase */
+/* Bit 7:1   vertical formatter phase step (3.4) */
+/* Bit 0     vertical formatter enable */
+#define VIU_VD1_FMT_W				    0x1a69
+/* ((0x1a69  << 2) + 0xd0100000) */
+/* Bit 27:16  horizontal formatter width */
+/* Bit 11:0   vertical formatter width */
 
-#define DI_EI_CTRL13					0x17a8
-		/* 0xd0105ea0 */
-#define DI_MTN_1_CTRL6					0x17a9
-		/* 0xd0105ea4 */
-#define DI_MTN_1_CTRL7					0x17aa
-		/* 0xd0105ea8 */
-#define DI_MTN_1_CTRL8					0x17ab
-		/* 0xd0105eac */
-#define DI_MTN_1_CTRL9					0x17ac
-		/* 0xd0105eb0 */
-#define DI_MTN_1_CTRL10					0x17ad
-		/* 0xd0105eb4 */
-#define DI_MTN_1_CTRL11					0x17ae
-		/* 0xd0105eb8 */
-#define DI_MTN_1_CTRL12					0x17af
-		/* 0xd0105ebc */
 
-#define DI_CHAN2_LUMA0_RPT_PAT			0x17b0
-		/* 0xd0105ec0 */
-#define DI_CHAN2_CHROMA0_RPT_PAT		0x17b1
-		/* 0xd0105ec4 */
-#define DI_CHAN2_DUMMY_PIXEL			0x17b2
-		/* 0xd0105ec8 */
-#define DI_CHAN2_LUMA_FIFO_SIZE			0x17b3
-		/* 0xd0105ecc */
-#define DI_CHAN2_RANGE_MAP_Y			0x17b4
-		/* 0xd0105ed0 */
-#define DI_CHAN2_RANGE_MAP_CB			0x17b5
-		/* 0xd0105ed4 */
-#define DI_CHAN2_RANGE_MAP_CR			0x17b6
-		/* 0xd0105ed8 */
-#define DI_CHAN2_GEN_REG2				0x17b7
-		/* 0xd0105edc */
-#define DI_CHAN2_FMT_CTRL				0x17b8
-		/* 0xd0105ee0 */
-#define DI_CHAN2_FMT_W					0x17b9
-		/* 0xd0105ee4 */
-#define DI_INP_RANGE_MAP_Y				0x17ba
-		/* 0xd0105ee8 */
-#define DI_INP_RANGE_MAP_CB				0x17bb
-		/* 0xd0105eec */
-#define DI_INP_RANGE_MAP_CR				0x17bc
-		/* 0xd0105ef0 */
-#define DI_MEM_RANGE_MAP_Y				0x17bd
-		/* 0xd0105ef4 */
-#define DI_MEM_RANGE_MAP_CB				0x17be
-		/* 0xd0105ef8 */
-#define DI_MEM_RANGE_MAP_CR				0x17bf
-		/* 0xd0105efc */
-#define DI_NRWR_X						0x17c0
-		/* 0xd0105f00 */
-#define DI_NRWR_Y						0x17c1
-		/* 0xd0105f04 */
-#define DI_NRWR_CTRL					0x17c2
-		/* 0xd0105f08 */
-#define DI_MTNWR_X						0x17c3
-		/* 0xd0105f0c */
-#define DI_MTNWR_Y						0x17c4
-		/* 0xd0105f10 */
-#define DI_MTNWR_CTRL					0x17c5
-		/* 0xd0105f14 */
-#define DI_DIWR_X						0x17c6
-		/* 0xd0105f18 */
-#define DI_DIWR_Y						0x17c7
-		/* 0xd0105f1c */
-#define DI_DIWR_CTRL					0x17c8
-		/* 0xd0105f20 */
-#define DI_MTNPRD_X						0x17cb
-		/* 0xd0105f2c */
-#define DI_MTNPRD_Y						0x17cc
-		/* 0xd0105f30 */
-#define DI_MTNRD_CTRL					0x17cd
-		/* 0xd0105f34 */
-#define DI_INP_GEN_REG					0x17ce
-		/* 0xd0105f38 */
-#define DI_INP_CANVAS0					0x17cf
-		/* 0xd0105f3c */
-#define DI_INP_LUMA_X0					0x17d0
-		/* 0xd0105f40 */
-#define DI_INP_LUMA_Y0					0x17d1
-		/* 0xd0105f44 */
-#define DI_INP_CHROMA_X0				0x17d2
-		/* 0xd0105f48 */
-#define DI_INP_CHROMA_Y0				0x17d3
-		/* 0xd0105f4c */
-#define DI_INP_RPT_LOOP					0x17d4
-		/* 0xd0105f50 */
-#define DI_INP_LUMA0_RPT_PAT			0x17d5
-		/* 0xd0105f54 */
-#define DI_INP_CHROMA0_RPT_PAT			0x17d6
-		/* 0xd0105f58 */
-#define DI_INP_DUMMY_PIXEL				0x17d7
-		/* 0xd0105f5c */
-#define DI_INP_LUMA_FIFO_SIZE			0x17d8
-		/* 0xd0105f60 */
-#define DI_INP_FMT_CTRL					0x17d9
-		/* 0xd0105f64 */
-#define DI_INP_FMT_W					0x17da
-		/* 0xd0105f68 */
-#define DI_MEM_GEN_REG					0x17db
-		/* 0xd0105f6c */
-#define DI_MEM_CANVAS0					0x17dc
-		/* 0xd0105f70 */
-#define DI_MEM_LUMA_X0					0x17dd
-		/* 0xd0105f74 */
-#define DI_MEM_LUMA_Y0					0x17de
-		/* 0xd0105f78 */
-#define DI_MEM_CHROMA_X0				0x17df
-		/* 0xd0105f7c */
-#define DI_MEM_CHROMA_Y0				0x17e0
-		/* 0xd0105f80 */
-#define DI_MEM_RPT_LOOP					0x17e1
-		/* 0xd0105f84 */
-#define DI_MEM_LUMA0_RPT_PAT			0x17e2
-		/* 0xd0105f88 */
-#define DI_MEM_CHROMA0_RPT_PAT			0x17e3
-		/* 0xd0105f8c */
-#define DI_MEM_DUMMY_PIXEL				0x17e4
-		/* 0xd0105f90 */
-#define DI_MEM_LUMA_FIFO_SIZE			0x17e5
-		/* 0xd0105f94 */
-#define DI_MEM_FMT_CTRL					0x17e6
-		/* 0xd0105f98 */
-#define DI_MEM_FMT_W					0x17e7
-		/* 0xd0105f9c */
-#define DI_IF1_GEN_REG					0x17e8
-		/* 0xd0105fa0 */
-#define DI_IF1_CANVAS0					0x17e9
-		/* 0xd0105fa4 */
-#define DI_IF1_LUMA_X0					0x17ea
-		/* 0xd0105fa8 */
-#define DI_IF1_LUMA_Y0					0x17eb
-		/* 0xd0105fac */
-#define DI_IF1_CHROMA_X0				0x17ec
-		/* 0xd0105fb0 */
-#define DI_IF1_CHROMA_Y0				0x17ed
-		/* 0xd0105fb4 */
-#define DI_IF1_RPT_LOOP					0x17ee
-		/* 0xd0105fb8 */
-#define DI_IF1_LUMA0_RPT_PAT			0x17ef
-		/* 0xd0105fbc */
-#define DI_IF1_CHROMA0_RPT_PAT			0x17f0
-		/* 0xd0105fc0 */
-#define DI_IF1_DUMMY_PIXEL				0x17f1
-		/* 0xd0105fc4 */
-#define DI_IF1_LUMA_FIFO_SIZE			0x17f2
-		/* 0xd0105fc8 */
-#define DI_IF1_FMT_CTRL					0x17f3
-		/* 0xd0105fcc */
-#define DI_IF1_FMT_W					0x17f4
-		/* 0xd0105fd0 */
-#define DI_CHAN2_GEN_REG				0x17f5
-		/* 0xd0105fd4 */
-#define DI_CHAN2_CANVAS0				0x17f6
-		/* 0xd0105fd8 */
-#define DI_CHAN2_LUMA_X0				0x17f7
-		/* 0xd0105fdc */
-#define DI_CHAN2_LUMA_Y0				0x17f8
-		/* 0xd0105fe0 */
-#define DI_CHAN2_CHROMA_X0				0x17f9
-		/* 0xd0105fe4 */
-#define DI_CHAN2_CHROMA_Y0				0x17fa
-		/* 0xd0105fe8 */
-#define DI_CHAN2_RPT_LOOP				0x17fb
-		/* 0xd0105fec */
-#define DI_IF1_RANGE_MAP_Y				0x17fc
-		/* 0xd0105fcc */
-#define DI_IF1_RANGE_MAP_CB				0x17fd
-		/* 0xd0105fd0 */
-#define DI_IF1_RANGE_MAP_CR				0x17fe
-		/* 0xd0105fd4 */
+#define VD1_IF0_GEN_REG2		0x1a6d
+#define VD2_IF0_GEN_REG2		0x1a8d
 
 #define VD1_IF0_GEN_REG3                0x1aa7
 		/* 0xd0106a9c */
+/*bit9:8	bit mode: 0 = 8bits, 1=10bits 422,  2 = 10bits 444 */
 #define DI_IF1_GEN_REG3                 0x20a7
 		/* 0xd010829c */
+/*bit9:8	bit mode: 0 = 8bits, 1=10bits 422,  2 = 10bits 444 */
 #define DI_INP_GEN_REG3                 0x20a8
 		/* 0xd01082a0 */
+/*bit9:8	bit mode: 0 = 8bits, 1=10bits 422,  2 = 10bits 444 */
 #define DI_MEM_GEN_REG3                 0x20a9
 		/* 0xd01082a4 */
+/*bit9:8	bit mode: 0 = 8bits, 1=10bits 422,  2 = 10bits 444 */
 #define DI_CHAN2_GEN_REG3               0x20aa
 		/* 0xd01082a8 */
-/* dnr */
-#define DNR_CTRL						0x2d00
-#define DNR_HVSIZE						0x2d01
-#define DNR_DBLK_BLANK_NUM				0x2d02
-#define DNR_BLK_OFFST					0x2d03
-#define DNR_GBS							0x2d04
-#define DNR_HBOFFST_STAT				0x2d05
-#define DNR_VBOFFST_STAT				0x2d06
-#define DNR_GBS_STAT					0x2d07
-#define DNR_STAT_X_START_END			0x2d08
-#define DNR_STAT_Y_START_END			0x2d09
-#define DNR_LUMA						0x2d0a
-#define DNR_DB_YEDGE_THD				0x2d0b
-#define DNR_DB_CEDGE_THD				0x2d0c
-#define DNR_DB_HGAP						0x2d0d
-#define DNR_DB_HBS						0x2d0e
-#define DNR_DB_HACT						0x2d0f
-#define DNR_DB_YHDELTA_GAIN				0x2d10
-#define DNR_DB_YHDELTA2_GAIN			0x2d11
-#define DNR_DB_CHDELTA_GAIN				0x2d12
-#define DNR_DB_CHDELTA2_GAIN			0x2d13
-#define DNR_DB_YC_VEDGE_THD				0x2d14
-#define DNR_DB_VBS_MISC					0x2d15
-#define DNR_DB_YVDELTA_GAIN				0x2d16
-#define DNR_DB_CVDELTA_GAIN				0x2d17
-#define DNR_RO_GBS_STAT_LR				0x2d18
-#define DNR_RO_GBS_STAT_LL				0x2d19
-#define DNR_RO_GBS_STAT_RR				0x2d1a
-#define DNR_RO_GBS_STAT_DIF				0x2d1b
-#define DNR_RO_GBS_STAT_CNT				0x2d1c
-#define DNR_RO_HBOF_STAT_CNT_0			0x2d1d
-#define DNR_RO_HBOF_STAT_CNT_1			0x2d1e
-#define DNR_RO_HBOF_STAT_CNT_2			0x2d1f
-#define DNR_RO_HBOF_STAT_CNT_3			0x2d20
-#define DNR_RO_HBOF_STAT_CNT_4			0x2d21
-#define DNR_RO_HBOF_STAT_CNT_5			0x2d22
-#define DNR_RO_HBOF_STAT_CNT_6			0x2d23
-#define DNR_RO_HBOF_STAT_CNT_7			0x2d24
-#define DNR_RO_HBOF_STAT_CNT_8			0x2d25
-#define DNR_RO_HBOF_STAT_CNT_9			0x2d26
-#define DNR_RO_HBOF_STAT_CNT_10			0x2d27
-#define DNR_RO_HBOF_STAT_CNT_11			0x2d28
-#define DNR_RO_HBOF_STAT_CNT_12			0x2d29
-#define DNR_RO_HBOF_STAT_CNT_13			0x2d2a
-#define DNR_RO_HBOF_STAT_CNT_14			0x2d2b
-#define DNR_RO_HBOF_STAT_CNT_15			0x2d2c
-#define DNR_RO_HBOF_STAT_CNT_16			0x2d2d
-#define DNR_RO_HBOF_STAT_CNT_17			0x2d2e
-#define DNR_RO_HBOF_STAT_CNT_18			0x2d2f
-#define DNR_RO_HBOF_STAT_CNT_19			0x2d30
-#define DNR_RO_HBOF_STAT_CNT_20			0x2d31
-#define DNR_RO_HBOF_STAT_CNT_21			0x2d32
-#define DNR_RO_HBOF_STAT_CNT_22			0x2d33
-#define DNR_RO_HBOF_STAT_CNT_23			0x2d34
-#define DNR_RO_HBOF_STAT_CNT_24			0x2d35
-#define DNR_RO_HBOF_STAT_CNT_25			0x2d36
-#define DNR_RO_HBOF_STAT_CNT_26			0x2d37
-#define DNR_RO_HBOF_STAT_CNT_27			0x2d38
-#define DNR_RO_HBOF_STAT_CNT_28			0x2d39
-#define DNR_RO_HBOF_STAT_CNT_29			0x2d3a
-#define DNR_RO_HBOF_STAT_CNT_30			0x2d3b
-#define DNR_RO_HBOF_STAT_CNT_31			0x2d3c
-#define DNR_RO_VBOF_STAT_CNT_0			0x2d3d
-#define DNR_RO_VBOF_STAT_CNT_1			0x2d3e
-#define DNR_RO_VBOF_STAT_CNT_2			0x2d3f
-#define DNR_RO_VBOF_STAT_CNT_3			0x2d40
-#define DNR_RO_VBOF_STAT_CNT_4			0x2d41
-#define DNR_RO_VBOF_STAT_CNT_5			0x2d42
-#define DNR_RO_VBOF_STAT_CNT_6			0x2d43
-#define DNR_RO_VBOF_STAT_CNT_7			0x2d44
-#define DNR_RO_VBOF_STAT_CNT_8			0x2d45
-#define DNR_RO_VBOF_STAT_CNT_9			0x2d46
-#define DNR_RO_VBOF_STAT_CNT_10			0x2d47
-#define DNR_RO_VBOF_STAT_CNT_11			0x2d48
-#define DNR_RO_VBOF_STAT_CNT_12			0x2d49
-#define DNR_RO_VBOF_STAT_CNT_13			0x2d4a
-#define DNR_RO_VBOF_STAT_CNT_14			0x2d4b
-#define DNR_RO_VBOF_STAT_CNT_15			0x2d4c
-#define DNR_RO_VBOF_STAT_CNT_16			0x2d4d
-#define DNR_RO_VBOF_STAT_CNT_17			0x2d4e
-#define DNR_RO_VBOF_STAT_CNT_18			0x2d4f
-#define DNR_RO_VBOF_STAT_CNT_19			0x2d50
-#define DNR_RO_VBOF_STAT_CNT_20			0x2d51
-#define DNR_RO_VBOF_STAT_CNT_21			0x2d52
-#define DNR_RO_VBOF_STAT_CNT_22			0x2d53
-#define DNR_RO_VBOF_STAT_CNT_23			0x2d54
-#define DNR_RO_VBOF_STAT_CNT_24			0x2d55
-#define DNR_RO_VBOF_STAT_CNT_25			0x2d56
-#define DNR_RO_VBOF_STAT_CNT_26			0x2d57
-#define DNR_RO_VBOF_STAT_CNT_27			0x2d58
-#define DNR_RO_VBOF_STAT_CNT_28			0x2d59
-#define DNR_RO_VBOF_STAT_CNT_29			0x2d5a
-#define DNR_RO_VBOF_STAT_CNT_30			0x2d5b
-#define DNR_RO_VBOF_STAT_CNT_31			0x2d5c
-#define VPU_VD1_MMC_CTRL				0x2703
-#define VPU_VD2_MMC_CTRL				0x2704
-#define VPU_DI_IF1_MMC_CTRL				0x2705
-#define VPU_DI_MEM_MMC_CTRL				0x2706
-#define VPU_DI_INP_MMC_CTRL				0x2707
-#define VPU_DI_MTNRD_MMC_CTRL			0x2708
-#define VPU_DI_CHAN2_MMC_CTRL			0x2709
-#define VPU_DI_MTNWR_MMC_CTRL			0x270a
-#define VPU_DI_NRWR_MMC_CTRL			0x270b
-#define VPU_DI_DIWR_MMC_CTRL			0x270c
+/* dnr  Base Addr: 0xd0100000 */
+#define DNR_CTRL                         ((0x2d00))
+/* Bit 31:17,        reserved */
+/* Bit 16,            reg_dnr_en,
+dnr enable                  . unsigned  , default = 1 */
+/* Bit 15,            reg_dnr_db_vdbstep                          ,
+vdb step, 0: 4, 1: 8        . unsigned  , default = 1 */
+/* Bit 14,            reg_dnr_db_vdbprten                         ,
+vdb protectoin enable       . unsigned  , default = 1 */
+/* Bit 13,            reg_dnr_gbs_difen                           ,
+enable dif (between LR and LL/RR) condition for gbs stat..
+unsigned  , default = 0 */
+/* Bit 12,            reg_dnr_luma_en                             ,
+enable ycbcr2luma module    . unsigned  , default = 1 */
+/* Bit 11:10,        reg_dnr_db_mod                              ,
+deblocking mode, 0: disable, 1: horizontal deblocking, 2: vertical
+deblocking, 3: horizontal & vertical deblocking. unsigned  , default = 3 */
+/* Bit  9,            reg_dnr_db_chrmen                           ,
+enable chroma deblocking    . unsigned  , default = 1 */
+/* Bit  8,            reg_dnr_hvdif_mod                           ,
+0: calc. difs by original Y, 1: by new luma. unsigned  , default = 1 */
+/* Bit  7,            reserved */
+/* Bit  6: 4,        reg_dnr_demo_lften                          ,
+b0: Y b1:U b2:V             . unsigned  , default = 7 */
+/* Bit  3,            reserved */
+/* Bit  2: 0,        reg_dnr_demo_rgten                          ,
+b0: Y b1:U b2:V             . unsigned  , default = 7 */
+#define DNR_HVSIZE                       ((0x2d01))
+/* Bit 31:29,        reserved */
+/* Bit 28:16,        reg_dnr_hsize                               ,
+hsize                       . unsigned  , default = 0 */
+/* Bit 15:13,        reserved */
+/* Bit 12: 0,        reg_dnr_vsize                               ,
+vsize                       . unsigned  , default = 0 */
+#define DNR_DBLK_BLANK_NUM                         ((0x2d02))
+/* Bit 31:16,        reserved */
+/* Bit 15: 8,        reg_dblk_hblank_num                         ,
+deblock hor blank num       . unsigned  , default = 16 */
+/* Bit  7: 0,        reg_dblk_vblank_num                         ,
+deblock ver blank num       . unsigned  , default = 45 */
+#define DNR_BLK_OFFST                              ((0x2d03))
+/* Bit 31: 7,        reserved */
+/* Bit  6: 4,        reg_dnr_hbofst                              ,
+horizontal block offset may provide by software calc.. unsigned  ,
+default = 0 */
+/* Bit  3,            reserved */
+/* Bit  2: 0,        reg_dnr_vbofst                              ,
+vertical block offset may provide by software calc.. unsigned  , default = 0 */
+#define DNR_GBS                                    ((0x2d04))
+/* Bit 31: 2,        reserved */
+/* Bit  1: 0,        reg_dnr_gbs                                 ,
+global block strength may update by software calc.. unsigned  , default = 0 */
+#define DNR_HBOFFST_STAT                           ((0x2d05))
+/* Bit 31:24,        reg_dnr_hbof_difthd                         ,
+dif threshold (>=) between LR and LL/RR. unsigned  , default = 2 */
+/* Bit 23:16,        reg_dnr_hbof_edgethd                        ,
+edge threshold (<=) for LR  . unsigned  , default = 32 */
+/* Bit 15: 8,        reg_dnr_hbof_flatthd                        ,
+flat threshold (>=) for LR  . unsigned  , default = 0 */
+/* Bit  7,            reserved */
+/* Bit  6: 4,        reg_dnr_hbof_delta                          ,
+delta for weighted bin accumulator. unsigned  , default = 1 */
+/* Bit  3,            reserved */
+/* Bit  2: 0,        reg_dnr_hbof_statmod                        ,
+statistic mode for horizontal block offset, 0: count flags for 8-bin,
+1: count LRs for 8-bin, 2: count difs for 8-bin,
+3: count weighted flags for 8-bin, 4: count flags for first 32-bin,
+5: count LRs for first 32-bin, 6 or 7: count difs for first 32-bin.
+unsigned  , default = 2 */
+#define DNR_VBOFFST_STAT                           ((0x2d06))
+/* Bit 31:24,        reg_dnr_vbof_difthd                         ,
+dif threshold (>=) between Up and Dw. unsigned  , default = 1 */
+/* Bit 23:16,        reg_dnr_vbof_edgethd                        ,
+edge threshold (<=) for Up/Dw. unsigned  , default = 16 */
+/* Bit 15: 8,        reg_dnr_vbof_flatthd                        ,
+flat threshold (>=) for Up/Dw. unsigned  , default = 0 */
+/* Bit  7,            reserved */
+/* Bit  6: 4,        reg_dnr_vbof_delta                          ,
+delta for weighted bin accumulator. unsigned  , default = 1 */
+/* Bit  3,            reserved */
+/* Bit  2: 0,        reg_dnr_vbof_statmod                        ,
+statistic mode for vertical block offset, 0: count flags for 8-bin,
+1: count Ups for 8-bin, 2: count difs for 8-bin, 3: count weighted
+flags for 8-bin, 4: count flags for first 32-bin, 5: count Ups for
+first 32-bin, 6 or 7: count difs for first 32-bin. unsigned  , default = 2 */
+#define DNR_GBS_STAT                               ((0x2d07))
+/* Bit 31:24,        reg_dnr_gbs_edgethd                         ,
+edge threshold (<=) for LR  . unsigned  , default = 32 */
+/* Bit 23:16,        reg_dnr_gbs_flatthd                         ,
+flat threshold (>=) for LR  . unsigned  , default = 0 */
+/* Bit 15: 8,        reg_dnr_gbs_varthd                          ,
+variation threshold (<=) for Lvar/Rvar. unsigned  , default = 16 */
+/* Bit  7: 0,        reg_dnr_gbs_difthd                          ,
+dif threshold (>=) between LR and LL/RR. unsigned  , default = 2 */
+#define DNR_STAT_X_START_END                       ((0x2d08))
+/* Bit 31:30,        reserved */
+/* Bit 29:16,        reg_dnr_stat_xst    . unsigned  , default = 24 */
+/* Bit 15:14,        reserved */
+/* Bit 13: 0,        reg_dnr_stat_xed    . unsigned  , default = HSIZE - 25 */
+#define DNR_STAT_Y_START_END                       ((0x2d09))
+/* Bit 31:30,        reserved */
+/* Bit 29:16,        reg_dnr_stat_yst    . unsigned  , default = 24 */
+/* Bit 15:14,        reserved */
+/* Bit 13: 0,        reg_dnr_stat_yed    . unsigned  , default = VSIZE - 25 */
+#define DNR_LUMA                                   ((0x2d0a))
+/* Bit 31:27,        reserved */
+/* Bit 26:24,        reg_dnr_luma_sqrtshft                       ,
+left shift for fast squart of chroma, [0, 4]. unsigned  , default = 2 */
+/* Bit 23:21,        reserved */
+/* Bit 20:16,        reg_dnr_luma_sqrtoffst                      ,
+offset for fast squart of chroma. signed    , default = 0 */
+/* Bit 15,            reserved */
+/* Bit 14:12,        reg_dnr_luma_wcmod                          ,
+theta related to warm/cool segment line, 0: 0, 1: 45, 2: 90, 3: 135,
+4: 180, 5: 225, 6: 270, 7: 315. . unsigned  , default = 3 */
+/* Bit 11: 8,        reg_dnr_luma_cshft                          ,
+shift for calc. delta part, 0~8,  . unsigned  , default = 8 */
+/* Bit  7: 6,        reserved */
+/* Bit  5: 0,        reg_dnr_luma_cgain                          ,
+final gain for delta part, 32 normalized to "1". unsigned  , default = 4 */
+#define DNR_DB_YEDGE_THD                           ((0x2d0b))
+/* Bit 31:24,        reg_dnr_db_yedgethd0                        ,
+edge threshold0 for luma    . unsigned  , default = 12 */
+/* Bit 23:16,        reg_dnr_db_yedgethd1                        ,
+edge threshold1 for luma    . unsigned  , default = 15 */
+/* Bit 15: 8,        reg_dnr_db_yedgethd2                        ,
+edge threshold2 for luma    . unsigned  , default = 18 */
+/* Bit  7: 0,        reg_dnr_db_yedgethd3                        ,
+edge threshold3 for luma    . unsigned  , default = 25 */
+#define DNR_DB_CEDGE_THD                           ((0x2d0c))
+/* Bit 31:24,        reg_dnr_db_cedgethd0                        ,
+edge threshold0 for chroma  . unsigned  , default = 12 */
+/* Bit 23:16,        reg_dnr_db_cedgethd1                        ,
+edge threshold1 for chroma  . unsigned  , default = 15 */
+/* Bit 15: 8,        reg_dnr_db_cedgethd2                        ,
+edge threshold2 for chroma  . unsigned  , default = 18 */
+/* Bit  7: 0,        reg_dnr_db_cedgethd3                        ,
+edge threshold3 for chroma  . unsigned  , default = 25 */
+#define DNR_DB_HGAP                                ((0x2d0d))
+/* Bit 31:24,        reserved */
+/* Bit 23:16,        reg_dnr_db_hgapthd                          ,
+horizontal gap thd (<=) for very sure blockiness . unsigned  , default = 8 */
+/* Bit 15: 8,        reg_dnr_db_hgapdifthd                       ,
+dif thd between hgap and lft/rgt hdifs. unsigned  , default = 1 */
+/* Bit  7: 1,        reserved */
+/* Bit  0,            reg_dnr_db_hgapmod                          ,
+horizontal gap calc. mode, 0: just use current col x,
+1: find max between (x-1, x, x+1) . unsigned  , default = 0 */
+#define DNR_DB_HBS                                 ((0x2d0e))
+/* Bit 31: 6,        reserved */
+/* Bit  5: 4,        reg_dnr_db_hbsup                            ,
+horizontal bs up value      . unsigned  , default = 1 */
+/* Bit  3: 2,        reg_dnr_db_hbsmax                           ,
+max value of hbs for global control. unsigned  , default = 3 */
+/* Bit  1: 0,        reg_dnr_db_hgbsthd                          ,
+gbs thd (>=) for hbs calc.  . unsigned  , default = 1 */
+#define DNR_DB_HACT                                ((0x2d0f))
+/* Bit 31:16,        reserved */
+/* Bit 15: 8,        reg_dnr_db_hactthd0                         ,
+thd0 of hact, for block classification. unsigned  , default = 10 */
+/* Bit  7: 0,        reg_dnr_db_hactthd1                         ,
+thd1 of hact, for block classification. unsigned  , default = 32 */
+#define DNR_DB_YHDELTA_GAIN                        ((0x2d10))
+/* Bit 31:27,        reserved */
+/* Bit 26:24,        reg_dnr_db_yhdeltagain1                     ,
+(p1-q1) gain for Y's delta calc. when bs=1, normalized 8 as "1" .
+unsigned  , default = 2 */
+/* Bit 23,            reserved */
+/* Bit 22:20,        reg_dnr_db_yhdeltagain2                     ,
+(p1-q1) gain for Y's delta calc. when bs=2, normalized 8 as "1" .
+unsigned  , default = 0 */
+/* Bit 19,            reserved */
+/* Bit 18:16,        reg_dnr_db_yhdeltagain3                     ,
+(p1-q1) gain for Y's delta calc. when bs=3, normalized 8 as "1" .
+unsigned  , default = 0 */
+/* Bit 15,            reserved */
+/* Bit 14: 8,        reg_dnr_db_yhdeltaadjoffst                  ,
+offset for adjust Y's hdelta (-64, 63). signed    , default = 0 */
+/* Bit  7: 6,        reserved */
+/* Bit  5: 0,        reg_dnr_db_yhdeltaadjgain                   ,
+gain for adjust Y's hdelta, normalized 32 as "1" . unsigned  , default = 32 */
+#define DNR_DB_YHDELTA2_GAIN                       ((0x2d11))
+/* Bit 31:30,        reserved */
+/* Bit 29:24,        reg_dnr_db_yhdelta2gain2                    ,
+gain for bs=2's adjust Y's hdelta2, normalized 64 as "1" .
+unsigned  , default = 8 */
+/* Bit 23:21,        reserved */
+/* Bit 20:16,        reg_dnr_db_yhdelta2offst2                   ,
+offset for bs=2's adjust Y's hdelta2 (-16, 15). signed    , default = 0 */
+/* Bit 15:14,        reserved */
+/* Bit 13: 8,        reg_dnr_db_yhdelta2gain3                    ,
+gain for bs=3's adjust Y's hdelta2, normalized 64 as "1" .
+unsigned , default = 4 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_db_yhdelta2offst3                   ,
+offset for bs=3's adjust Y's hdelta2 (-16, 15). signed    , default = 0 */
+#define DNR_DB_CHDELTA_GAIN                        ((0x2d12))
+/* Bit 31:27,        reserved */
+/* Bit 26:24,        reg_dnr_db_chdeltagain1                     ,
+(p1-q1) gain for UV's delta calc. when bs=1, normalized 8 as "1".
+unsigned  , default = 2 */
+/* Bit 23,            reserved */
+/* Bit 22:20,        reg_dnr_db_chdeltagain2                     ,
+(p1-q1) gain for UV's delta calc. when bs=2,
+normalized 8 as "1". unsigned  , default = 0 */
+/* Bit 19,            reserved */
+/* Bit 18:16,        reg_dnr_db_chdeltagain3                     ,
+(p1-q1) gain for UV's delta calc. when bs=3, normalized 8 as "1".
+unsigned  , default = 0 */
+/* Bit 15,            reserved */
+/* Bit 14: 8,        reg_dnr_db_chdeltaadjoffst                  ,
+offset for adjust UV's hdelta (-64, 63). signed    , default = 0 */
+/* Bit  7: 6,        reserved */
+/* Bit  5: 0,        reg_dnr_db_chdeltaadjgain                   ,
+gain for adjust UV's hdelta, normalized 32 as "1". unsigned  , default = 32 */
+#define DNR_DB_CHDELTA2_GAIN                       ((0x2d13))
+/* Bit 31:30,        reserved */
+/* Bit 29:24,        reg_dnr_db_chdelta2gain2                    ,
+gain for bs=2's adjust UV's hdelta2, normalized 64 as "1" .
+unsigned  , default = 8 */
+/* Bit 23:21,        reserved */
+/* Bit 20:16,        reg_dnr_db_chdelta2offst2                   ,
+offset for bs=2's adjust UV's hdelta2 (-16, 15). signed    , default = 0 */
+/* Bit 15:14,        reserved */
+/* Bit 13: 8,        reg_dnr_db_chdelta2gain3                    ,
+gain for bs=2's adjust UV's hdelta2, normalized 64 as "1" .
+unsigned , default = 4 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_db_chdelta2offst3                   ,
+offset for bs=2's adjust UV's hdelta2 (-16, 15). signed    , default = 0 */
+#define DNR_DB_YC_VEDGE_THD                        ((0x2d14))
+/* Bit 31:16,        reserved */
+/* Bit 15: 8,        reg_dnr_db_yvedgethd                        ,
+special Y's edge thd for vdb. unsigned  , default = 12 */
+/* Bit  7: 0,        reg_dnr_db_cvedgethd                        ,
+special UV's edge thd for vdb. unsigned  , default = 12 */
+#define DNR_DB_VBS_MISC                            ((0x2d15))
+/* Bit 31:24,        reg_dnr_db_vgapthd                          ,
+vertical gap thd (<=) for very sure blockiness . unsigned  , default = 8 */
+/* Bit 23:16,        reg_dnr_db_vactthd                          ,
+thd of vact, for block classification . unsigned  , default = 10 */
+/* Bit 15: 8,        reg_dnr_db_vgapdifthd                       ,
+dif thd between vgap and vact. unsigned  , default = 4 */
+/* Bit  7: 4,        reserved */
+/* Bit  3: 2,        reg_dnr_db_vbsmax                           ,
+max value of vbs for global control. unsigned  , default = 2 */
+/* Bit  1: 0,        reg_dnr_db_vgbsthd                          ,
+gbs thd (>=) for vbs calc.  . unsigned  , default = 1 */
+#define DNR_DB_YVDELTA_GAIN                        ((0x2d16))
+/* Bit 31:30,        reserved */
+/* Bit 29:24,        reg_dnr_db_yvdeltaadjgain                   ,
+gain for adjust Y's vdelta, normalized 32 as "1". unsigned  , default = 32 */
+/* Bit 23,            reserved */
+/* Bit 22:16,        reg_dnr_db_yvdeltaadjoffst                  ,
+offset for adjust Y's vdelta (-64, 63). signed    , default = 0 */
+/* Bit 15:14,        reserved */
+/* Bit 13: 8,        reg_dnr_db_yvdelta2gain                     ,
+gain for adjust Y's vdelta2, normalized 64 as "1". unsigned  , default = 8 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_db_yvdelta2offst                    ,
+offset for adjust Y's vdelta2 (-16, 15). signed    , default = 0 */
+#define DNR_DB_CVDELTA_GAIN                        ((0x2d17))
+/* Bit 31:30,        reserved */
+/* Bit 29:24,        reg_dnr_db_cvdeltaadjgain                   ,
+gain for adjust UV's vdelta, normalized 32 as "1". unsigned  , default = 32 */
+/* Bit 23,            reserved */
+/* Bit 22:16,        reg_dnr_db_cvdeltaadjoffst                  ,
+offset for adjust UV's vdelta (-64, 63). signed    , default = 0 */
+/* Bit 15:14,        reserved */
+/* Bit 13: 8,        reg_dnr_db_cvdelta2gain                     ,
+gain for adjust UV's vdelta2, normalized 64 as "1". unsigned  , default = 8 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_db_cvdelta2offst                    ,
+offset for adjust UV's vdelta2 (-16, 15). signed    , default = 0 */
+#define DNR_RO_GBS_STAT_LR                         ((0x2d18))
+/* Bit 31: 0,        ro_gbs_stat_lr
+. unsigned  , default = 0 */
+#define DNR_RO_GBS_STAT_LL                         ((0x2d19))
+/* Bit 31: 0,        ro_gbs_stat_ll
+. unsigned  , default = 0 */
+#define DNR_RO_GBS_STAT_RR                         ((0x2d1a))
+/* Bit 31: 0,        ro_gbs_stat_rr
+. unsigned  , default = 0 */
+#define DNR_RO_GBS_STAT_DIF                        ((0x2d1b))
+/* Bit 31: 0,        ro_gbs_stat_dif
+. unsigned  , default = 0 */
+#define DNR_RO_GBS_STAT_CNT                        ((0x2d1c))
+/* Bit 31: 0,        ro_gbs_stat_cnt
+. unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_0                     ((0x2d1d))
+/* Bit 31: 0,        ro_hbof_stat_cnt0
+. unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_1                     ((0x2d1e))
+/* Bit 31: 0,        ro_hbof_stat_cnt1
+. unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_2                     ((0x2d1f))
+/* Bit 31: 0,        ro_hbof_stat_cnt2
+. unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_3                     ((0x2d20))
+/* Bit 31: 0,        ro_hbof_stat_cnt3  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_4                     ((0x2d21))
+/* Bit 31: 0,        ro_hbof_stat_cnt4  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_5                     ((0x2d22))
+/* Bit 31: 0,        ro_hbof_stat_cnt5  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_6                     ((0x2d23))
+/* Bit 31: 0,        ro_hbof_stat_cnt6  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_7                     ((0x2d24))
+/* Bit 31: 0,        ro_hbof_stat_cnt7  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_8                     ((0x2d25))
+/* Bit 31: 0,        ro_hbof_stat_cnt8  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_9                     ((0x2d26))
+/* Bit 31: 0,        ro_hbof_stat_cnt9  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_10                    ((0x2d27))
+/* Bit 31: 0,        ro_hbof_stat_cnt10 . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_11                    ((0x2d28))
+/* Bit 31: 0,        ro_hbof_stat_cnt11 . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_12                    ((0x2d29))
+/* Bit 31: 0,        ro_hbof_stat_cnt12 . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_13                    ((0x2d2a))
+/* Bit 31: 0,        ro_hbof_stat_cnt13 . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_14                    ((0x2d2b))
+/* Bit 31: 0,        ro_hbof_stat_cnt14  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_15                    ((0x2d2c))
+/* Bit 31: 0,        ro_hbof_stat_cnt15  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_16                    ((0x2d2d))
+/* Bit 31: 0,        ro_hbof_stat_cnt16  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_17                    ((0x2d2e))
+/* Bit 31: 0,        ro_hbof_stat_cnt17  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_18                    ((0x2d2f))
+/* Bit 31: 0,        ro_hbof_stat_cnt18  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_19                    ((0x2d30))
+/* Bit 31: 0,        ro_hbof_stat_cnt19  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_20                    ((0x2d31))
+/* Bit 31: 0,        ro_hbof_stat_cnt20  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_21                    ((0x2d32))
+/* Bit 31: 0,        ro_hbof_stat_cnt21  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_22                    ((0x2d33))
+/* Bit 31: 0,        ro_hbof_stat_cnt22  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_23                    ((0x2d34))
+/* Bit 31: 0,        ro_hbof_stat_cnt23  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_24                    ((0x2d35))
+/* Bit 31: 0,        ro_hbof_stat_cnt24  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_25                    ((0x2d36))
+/* Bit 31: 0,        ro_hbof_stat_cnt25  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_26                    ((0x2d37))
+/* Bit 31: 0,        ro_hbof_stat_cnt26  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_27                    ((0x2d38))
+/* Bit 31: 0,        ro_hbof_stat_cnt27  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_28                    ((0x2d39))
+/* Bit 31: 0,        ro_hbof_stat_cnt28  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_29                    ((0x2d3a))
+/* Bit 31: 0,        ro_hbof_stat_cnt29  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_30                    ((0x2d3b))
+/* Bit 31: 0,        ro_hbof_stat_cnt30  . unsigned  , default = 0 */
+#define DNR_RO_HBOF_STAT_CNT_31                    ((0x2d3c))
+/* Bit 31: 0,        ro_hbof_stat_cnt31  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_0                     ((0x2d3d))
+/* Bit 31: 0,        ro_vbof_stat_cnt0  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_1                     ((0x2d3e))
+/* Bit 31: 0,        ro_vbof_stat_cnt1  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_2                     ((0x2d3f))
+/* Bit 31: 0,        ro_vbof_stat_cnt2  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_3                     ((0x2d40))
+/* Bit 31: 0,        ro_vbof_stat_cnt3  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_4                     ((0x2d41))
+/* Bit 31: 0,        ro_vbof_stat_cnt4  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_5                     ((0x2d42))
+/* Bit 31: 0,        ro_vbof_stat_cnt5  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_6                     ((0x2d43))
+/* Bit 31: 0,        ro_vbof_stat_cnt6  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_7                     ((0x2d44))
+/* Bit 31: 0,        ro_vbof_stat_cnt7  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_8                     ((0x2d45))
+/* Bit 31: 0,        ro_vbof_stat_cnt8  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_9                     ((0x2d46))
+/* Bit 31: 0,        ro_vbof_stat_cnt9  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_10                    ((0x2d47))
+/* Bit 31: 0,        ro_vbof_stat_cnt10  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_11                    ((0x2d48))
+/* Bit 31: 0,        ro_vbof_stat_cnt11  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_12                    ((0x2d49))
+/* Bit 31: 0,        ro_vbof_stat_cnt12  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_13                    ((0x2d4a))
+/* Bit 31: 0,        ro_vbof_stat_cnt13  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_14                    ((0x2d4b))
+/* Bit 31: 0,        ro_vbof_stat_cnt14  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_15                    ((0x2d4c))
+/* Bit 31: 0,        ro_vbof_stat_cnt15  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_16                    ((0x2d4d))
+/* Bit 31: 0,        ro_vbof_stat_cnt16  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_17                    ((0x2d4e))
+/* Bit 31: 0,        ro_vbof_stat_cnt17  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_18                    ((0x2d4f))
+/* Bit 31: 0,        ro_vbof_stat_cnt18  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_19                    ((0x2d50))
+/* Bit 31: 0,        ro_vbof_stat_cnt19  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_20                    ((0x2d51))
+/* Bit 31: 0,        ro_vbof_stat_cnt20  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_21                    ((0x2d52))
+/* Bit 31: 0,        ro_vbof_stat_cnt21  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_22                    ((0x2d53))
+/* Bit 31: 0,        ro_vbof_stat_cnt22  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_23                    ((0x2d54))
+/* Bit 31: 0,        ro_vbof_stat_cnt23  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_24                    ((0x2d55))
+/* Bit 31: 0,        ro_vbof_stat_cnt24  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_25                    ((0x2d56))
+/* Bit 31: 0,        ro_vbof_stat_cnt25  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_26                    ((0x2d57))
+/* Bit 31: 0,        ro_vbof_stat_cnt26  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_27                    ((0x2d58))
+/* Bit 31: 0,        ro_vbof_stat_cnt27  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_28                    ((0x2d59))
+/* Bit 31: 0,        ro_vbof_stat_cnt28  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_29                    ((0x2d5a))
+/* Bit 31: 0,        ro_vbof_stat_cnt29  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_30                    ((0x2d5b))
+/* Bit 31: 0,        ro_vbof_stat_cnt30  . unsigned  , default = 0 */
+#define DNR_RO_VBOF_STAT_CNT_31                    ((0x2d5c))
+/* Bit 31: 0,        ro_vbof_stat_cnt31  . unsigned  , default = 0 */
+#define DNR_DM_CTRL                                ((0x2d60))
+/* Bit 31:13,        reserved */
+/* Bit 12,            reg_dnr_dm_fedgeflg_en                      ,
+enable edge flag calc. of each frame. unsigned  , default = 1 */
+/* Bit 11,            reg_dnr_dm_fedgeflg_cl                      ,
+clear frame edge flag if needed. unsigned  , default = 1 */
+/* Bit 10,            reg_dnr_dm_fedgeflg_df                      ,
+user defined edge when reg_dnr_dm_fedgeflg_en=0, default = 1 */
+/* Bit  9,            reg_dnr_dm_en                               ,
+enable demosquito function  . unsigned  , default = 1 */
+/* Bit  8,            reg_dnr_dm_chrmen                           ,
+enable chrome processing for demosquito. unsigned  , default = 1 */
+/* Bit  7: 6,        reg_dnr_dm_level                            ,
+demosquito level            . unsigned  , default = 3 */
+/* Bit  5: 4,        reg_dnr_dm_leveldw0                         ,
+level down when gbs is small. unsigned  , default = 1 */
+/* Bit  3: 2,        reg_dnr_dm_leveldw1                         ,
+level down for no edge/flat blocks. unsigned  , default = 1 */
+/* Bit  1: 0,        reg_dnr_dm_gbsthd                           ,
+small/large threshold for gbs (<=). unsigned  , default = 0 */
+#define DNR_DM_NR_BLND                             ((0x2d61))
+/* Bit 31:25,        reserved */
+/* Bit 24,            reg_dnr_dm_defalpen                         ,
+enable user define alpha for dm & nr blend. unsigned  , default = 0 */
+/* Bit 23:16,        reg_dnr_dm_defalp                           ,
+user define alpha for dm & nr blend if enable. unsigned  , default = 0 */
+/* Bit 15:14,        reserved */
+/* Bit 13: 8,        reg_dnr_dm_alpgain                          ,
+gain for nr/dm alpha, normalized 32 as "1". unsigned  , default = 32 */
+/* Bit  7: 0,        reg_dnr_dm_alpoffst                         ,
+(-128, 127), offset for nr/dm alpha. signed    , default = 0 */
+#define DNR_DM_RNG_THD                             ((0x2d62))
+/* Bit 31:24,        reserved */
+/* Bit 23:16,        reg_dnr_dm_rngminthd  . unsigned  , default = 2 */
+/* Bit 15: 8,        reg_dnr_dm_rngmaxthd  . unsigned  , default = 64 */
+/* Bit  7: 0,        reg_dnr_dm_rngdifthd  . unsigned  , default = 4 */
+#define DNR_DM_RNG_GAIN_OFST                       ((0x2d63))
+/* Bit 31:14,        reserved */
+/* Bit 13: 8,        reg_dnr_dm_rnggain                          ,
+normalized 16 as "1"        . unsigned  , default = 16 */
+/* Bit  7: 6,        reserved */
+/* Bit  5: 0,        reg_dnr_dm_rngofst  . unsigned  , default = 0 */
+#define DNR_DM_DIR_MISC                            ((0x2d64))
+/* Bit 31:30,        reserved */
+/* Bit 29,            reg_dnr_dm_diralpen     . unsigned  , default = 1 */
+/* Bit 28:24,        reg_dnr_dm_diralpgain    . unsigned  , default = 0 */
+/* Bit 23:22,        reserved */
+/* Bit 21:16,        reg_dnr_dm_diralpofst    . unsigned  , default = 0 */
+/* Bit 15:13,        reserved */
+/* Bit 12: 8,        reg_dnr_dm_diralpmin     . unsigned  , default = 0 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_dm_diralpmax     . unsigned  , default = 31 */
+#define DNR_DM_COR_DIF                             ((0x2d65))
+/* Bit 31: 4,        reserved */
+/* Bit  3: 1,        reg_dnr_dm_cordifshft    . unsigned  , default = 3 */
+/* Bit  0,            reg_dnr_dm_cordifmod                        ,
+0:use max dir dif as cordif, 1: use max3x3 - min3x3 as cordif.
+unsigned  , default = 1 */
+#define DNR_DM_FLT_THD                             ((0x2d66))
+/* Bit 31:24,        reg_dnr_dm_fltthd00                         ,
+block flat threshold0 for block average difference when gbs is small,
+for flat block detection. unsigned  , default = 4 */
+/* Bit 23:16,        reg_dnr_dm_fltthd01                         ,
+block flat threshold1 for block average difference when gbs is small,
+for flat block detection. unsigned  , default = 6 */
+/* Bit 15: 8,        reg_dnr_dm_fltthd10                         ,
+block flat threshold0 for block average difference when gbs is large,
+for flat block detection. unsigned  , default = 9 */
+/* Bit  7: 0,        reg_dnr_dm_fltthd11                         ,
+block flat threshold1 for block average difference when gbs is large,
+for flat block detection. unsigned  , default = 12 */
+#define DNR_DM_VAR_THD                             ((0x2d67))
+/* Bit 31:24,        reg_dnr_dm_varthd00                         ,
+block variance threshold0 (>=) when gbs is small, for flat block
+detection. unsigned  , default = 2 */
+/* Bit 23:16,        reg_dnr_dm_varthd01                         ,
+block variance threshold1 (<=) when gbs is small, for flat block
+detection. unsigned  , default = 15 */
+/* Bit 15: 8,        reg_dnr_dm_varthd10                         ,
+block variance threshold0 (>=) when gbs is large, for flat block
+detection. unsigned  , default = 3 */
+/* Bit  7: 0,        reg_dnr_dm_varthd11                         ,
+block variance threshold1 (<=) when gbs is large, for flat block
+detection. unsigned  , default = 24 */
+#define DNR_DM_EDGE_DIF_THD                        ((0x2d68))
+/* Bit 31:24,        reg_dnr_dm_edgethd0                         ,
+block edge threshold (<=) when gbs is small, for flat block detection.
+unsigned  , default = 32 */
+/* Bit 23:16,        reg_dnr_dm_edgethd1                         ,
+block edge threshold (<=) when gbs is large, for flat block detection.
+unsigned  , default = 48 */
+/* Bit 15: 8,        reg_dnr_dm_difthd0                          ,
+block dif threshold (<=) when gbs is small, for flat block detection.
+unsigned  , default = 48 */
+/* Bit  7: 0,        reg_dnr_dm_difthd1                          ,
+block dif threshold (<=) when gbs is large, for flat block detection.
+unsigned  , default = 64 */
+#define DNR_DM_AVG_THD                             ((0x2d69))
+/* Bit 31:16,        reserved */
+/* Bit 15: 8,        reg_dnr_dm_avgthd0                          ,
+block average threshold (>=), for flat block detection.
+unsigned ,default = 160 */
+/* Bit  7: 0,        reg_dnr_dm_avgthd1                          ,
+block average threshold (<=), for flat block detection. unsigned
+, default = 128 */
+#define DNR_DM_AVG_VAR_DIF_THD                     ((0x2d6a))
+/* Bit 31:16,        reserved */
+/* Bit 15: 8,        reg_dnr_dm_avgdifthd                        ,
+block average dif threshold (<) between cur and up block, for flat
+block detection. unsigned  , default = 12 */
+/* Bit  7: 0,        reg_dnr_dm_vardifthd                        ,
+block variance dif threshold (>=) between cur and up block, for flat
+block detection. unsigned  , default = 1 */
+#define DNR_DM_VAR_EDGE_DIF_THD2                   ((0x2d6b))
+/* Bit 31:24,        reserved */
+/* Bit 23:16,        reg_dnr_dm_varthd2, block variance threshold (>=),
+for edge block detection.unsigned, default = 24 */
+/* Bit 15: 8,        reg_dnr_dm_edgethd2                         ,
+block edge threshold (>=), for edge block detection. unsigned  , default = 40 */
+/* Bit  7: 0,        reg_dnr_dm_difthd2                          ,
+block dif threshold (>=), for edge block detection. unsigned  , default = 80 */
+#define DNR_DM_DIF_FLT_MISC                        ((0x2d6c))
+/* Bit 31:28,        reg_dnr_dm_ldifoob                          ,
+pre-defined large dif when pixel out of blocks. unsigned  , default = 0 */
+/* Bit 27:24,        reg_dnr_dm_bdifoob                          ,
+pre-defined block dif when pixel out of blocks;. unsigned  , default = 0 */
+/* Bit 23:16,        reg_dnr_dm_fltalp                           ,
+pre-defined alpha for dm and nr blending, when block is flat
+with mos.. unsigned  , default = 200 */
+/* Bit 15:12,        reserved */
+/* Bit 11: 8,        reg_dnr_dm_fltminbdif                       ,
+pre-defined min block dif for dm filter,
+when block is flat with mos.. unsigned  , default = 12 */
+/* Bit  7,            reserved */
+/* Bit  6: 2,        reg_dnr_dm_difnormgain                      ,
+gain for pixel dif normalization for dm filter,
+normalized 16 as "1". unsigned  , default = 16 */
+/* Bit  1,            reg_dnr_dm_difnormen                        ,
+enable pixel dif normalization for dm filter. unsigned  , default = 1 */
+/* Bit  0,            reg_dnr_dm_difupden                         ,
+enable block dif update using max of left, cur, right difs.
+unsigned  , default = 0 */
+#define DNR_DM_SDIF_LUT0_2                         ((0x2d6d))
+/* Bit 31:21,        reserved */
+/* Bit 20:16,        reg_dnr_dm_sdiflut0                         ,
+normally 0-16               . unsigned  , default = 16 */
+/* Bit 15:13,        reserved */
+/* Bit 12: 8,        reg_dnr_dm_sdiflut1                         ,
+normally 0-16               . unsigned  , default = 14 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_dm_sdiflut2                         ,
+normally 0-16               . unsigned  , default = 13 */
+#define DNR_DM_SDIF_LUT3_5                         ((0x2d6e))
+/* Bit 31:21,        reserved */
+/* Bit 20:16,        reg_dnr_dm_sdiflut3                         ,
+normally 0-16               . unsigned  , default = 10 */
+/* Bit 15:13,        reserved */
+/* Bit 12: 8,        reg_dnr_dm_sdiflut4                         ,
+normally 0-16               . unsigned  , default = 7 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_dm_sdiflut5                         ,
+normally 0-16               . unsigned  , default = 5 */
+#define DNR_DM_SDIF_LUT6_8                         ((0x2d6f))
+/* Bit 31:21,        reserved */
+/* Bit 20:16,        reg_dnr_dm_sdiflut6                         ,
+normally 0-16               . unsigned  , default = 3 */
+/* Bit 15:13,        reserved */
+/* Bit 12: 8,        reg_dnr_dm_sdiflut7                         ,
+normally 0-16               . unsigned  , default = 1 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_dm_sdiflut8                         ,
+normally 0-16               . unsigned  , default = 0 */
+#define DNR_DM_LDIF_LUT0_2                         ((0x2d70))
+/* Bit 31:21,        reserved */
+/* Bit 20:16,        reg_dnr_dm_ldiflut0                         ,
+normally 0-16               . unsigned  , default = 0 */
+/* Bit 15:13,        reserved */
+/* Bit 12: 8,        reg_dnr_dm_ldiflut1                         ,
+normally 0-16               . unsigned  , default = 4 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_dm_ldiflut2                         ,
+normally 0-16               . unsigned  , default = 12 */
+#define DNR_DM_LDIF_LUT3_5                         ((0x2d71))
+/* Bit 31:21,        reserved */
+/* Bit 20:16,        reg_dnr_dm_ldiflut3                         ,
+normally 0-16               . unsigned  , default = 14 */
+/* Bit 15:13,        reserved */
+/* Bit 12: 8,        reg_dnr_dm_ldiflut4                         ,
+normally 0-16               . unsigned  , default = 15 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_dm_ldiflut5                         ,
+normally 0-16               . unsigned  , default = 16 */
+#define DNR_DM_LDIF_LUT6_8                         ((0x2d72))
+/* Bit 31:21,        reserved */
+/* Bit 20:16,        reg_dnr_dm_ldiflut6                         ,
+normally 0-16               . unsigned  , default = 16 */
+/* Bit 15:13,        reserved */
+/* Bit 12: 8,        reg_dnr_dm_ldiflut7                         ,
+normally 0-16               . unsigned  , default = 16 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_dm_ldiflut8                         ,
+normally 0-16               . unsigned  , default = 16 */
+#define DNR_DM_DIF2NORM_LUT0_2                     ((0x2d73))
+/* Bit 31:21,        reserved */
+/* Bit 20:16,        reg_dnr_dm_dif2normlut0                     ,
+normally 0-16               . unsigned  , default = 16 */
+/* Bit 15:13,        reserved */
+/* Bit 12: 8,        reg_dnr_dm_dif2normlut1                     ,
+normally 0-16               . unsigned  , default = 5 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_dm_dif2normlut2                     ,
+normally 0-16               . unsigned  , default = 3 */
+#define DNR_DM_DIF2NORM_LUT3_5                     ((0x2d74))
+/* Bit 31:21,        reserved */
+/* Bit 20:16,        reg_dnr_dm_dif2normlut3                     ,
+normally 0-16               . unsigned  , default = 2 */
+/* Bit 15:13,        reserved */
+/* Bit 12: 8,        reg_dnr_dm_dif2normlut4                     ,
+normally 0-16               . unsigned  , default = 2 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_dm_dif2normlut5                     ,
+normally 0-16               . unsigned  , default = 1 */
+#define DNR_DM_DIF2NORM_LUT6_8                     ((0x2d75))
+/* Bit 31:21,        reserved */
+/* Bit 20:16,        reg_dnr_dm_dif2normlut6                     ,
+normally 0-16               . unsigned  , default = 1 */
+/* Bit 15:13,        reserved */
+/* Bit 12: 8,        reg_dnr_dm_dif2normlut7                     ,
+normally 0-16               . unsigned  , default = 1 */
+/* Bit  7: 5,        reserved */
+/* Bit  4: 0,        reg_dnr_dm_dif2normlut8                     ,
+normally 0-16               . unsigned  , default = 1 */
+#define DNR_DM_GMS_THD                             ((0x2d76))
+/* Bit 31:16,        reserved */
+/* Bit 15: 8,        reg_gms_stat_thd0  . unsigned  , default = 0 */
+/* Bit  7: 0,        reg_gms_stat_thd1  . unsigned  , default = 128 */
+#define DNR_RO_DM_GMS_STAT_CNT                     ((0x2d77))
+/* Bit 31: 0,        ro_dm_gms_stat_cnt  . unsigned  , default = 0 */
+#define DNR_RO_DM_GMS_STAT_MS                      ((0x2d78))
+/* Bit 31: 0,        ro_dm_gms_stat_ms  . unsigned  , default = 0 */
+/* txl added */
+#define DECOMB_DET_VERT_CON0				(0x2d80)
+#define DECOMB_DET_VERT_CON1				(0x2d81)
+#define DECOMB_DET_EDGE_CON0				(0x2d82)
+#define DECOMB_DET_EDGE_CON1				(0x2d83)
+#define DECOMB_PARA							(0x2d84)
+#define DECOMB_BLND_CON0					(0x2d85)
+#define DECOMB_BLND_CON1					(0x2d86)
+#define DECOMB_YC_THRD						(0x2d87)
+#define DECOMB_MTN_GAIN_OFST				(0x2d88)
+#define DECOMB_CMB_SEL_GAIN_OFST			(0x2d89)
+#define DECOMB_WIND00						(0x2d8a)
+#define DECOMB_WIND01						(0x2d8b)
+#define DECOMB_WIND10						(0x2d8c)
+#define DECOMB_WIND11						(0x2d8d)
+#define DECOMB_MODE							(0x2d8e)
+#define DECOMB_FRM_SIZE						(0x2d8f)
+#define DECOMB_HV_BLANK						(0x2d90)
+#define NR2_POLAR3_MODE						(0x2d98)
+#define NR2_POLAR3_THRD						(0x2d99)
+#define NR2_POLAR3_PARA0					(0x2d9a)
+#define NR2_POLAR3_PARA1					(0x2d9b)
+#define NR2_POLAR3_CTRL						(0x2d9c)
+#define NR2_RO_POLAR3_NUMOFPIX				(0x2d9d)
+#define NR2_RO_POLAR3_SMOOTHMV				(0x2d9e)
+#define NR2_RO_POLAR3_M1					(0x2d9f)
+#define NR2_RO_POLAR3_P1					(0x2da0)
+#define NR2_RO_POLAR3_M2					(0x2da1)
+#define NR2_RO_POLAR3_P2					(0x2da2)
+#define NR2_RO_POLAR3_32					(0x2da3)
+/* txl end */
 
+
+#define VPU_VD1_MMC_CTRL					(0x2703)
+#define VPU_VD2_MMC_CTRL					(0x2704)
+#define VPU_DI_IF1_MMC_CTRL					(0x2705)
+#define VPU_DI_MEM_MMC_CTRL					(0x2706)
+#define VPU_DI_INP_MMC_CTRL					(0x2707)
+#define VPU_DI_MTNRD_MMC_CTRL				(0x2708)
+#define VPU_DI_CHAN2_MMC_CTRL				(0x2709)
+#define VPU_DI_MTNWR_MMC_CTRL				(0x270a)
+#define VPU_DI_NRWR_MMC_CTRL				(0x270b)
+#define VPU_DI_DIWR_MMC_CTRL				(0x270c)
+
+#define MCDI_PD_22_CHK_WND0_X				(0x2f59)
+#define MCDI_PD_22_CHK_WND0_Y				(0x2f5a)
+#define MCDI_PD_22_CHK_WND1_X				(0x2f5b)
+#define MCDI_PD_22_CHK_WND1_Y				(0x2f5c)
 /* mc di */
-#define MCDI_HV_SIZEIN					0x2f00
-#define MCDI_HV_BLKSIZEIN				0x2f01
-#define MCDI_BLKTOTAL					0x2f02
-#define MCDI_MOTINEN					0x2f03
-#define MCDI_CTRL_MODE					0x2f04
-#define MCDI_UNI_MVDST					0x2f05
-#define MCDI_BI_MVDST					0x2f06
-#define MCDI_SAD_GAIN					0x2f07
-#define MCDI_TXT_THD					0x2f08
-#define MCDI_FLT_MODESEL				0x2f09
-#define MCDI_CHK_EDGE_THD				0x2f0a
-#define MCDI_CHK_EDGE_GAIN_OFFST		0x2f0b
-#define MCDI_LMV_RT						0x2f0c
-#define MCDI_LMV_GAINTHD				0x2f0d
-#define MCDI_RPTMV_THD0					0x2f0e
-#define MCDI_RPTMV_THD1					0x2f0f
-#define MCDI_RPTMV_THD2					0x2f10
-#define MCDI_RPTMV_SAD					0x2f11
-#define MCDI_RPTMV_FLG					0x2f12
-#define MCDI_RPTMV_GAIN					0x2f13
-#define MCDI_GMV_RT						0x2f14
-#define MCDI_GMV_GAIN					0x2f15
-#define MCDI_HOR_SADOFST				0x2f16
-#define MCDI_REF_MV_NUM					0x2f17
-#define MCDI_REF_BADW_THD_GAIN			0x2f18
-#define MCDI_REF_BADW_SUM_GAIN			0x2f19
-#define MCDI_REF_BS_THD_GAIN			0x2f1a
-#define MCDI_REF_ERR_GAIN0				0x2f1b
-#define MCDI_REF_ERR_GAIN1				0x2f1c
-#define MCDI_REF_ERR_FRQ_CHK			0x2f1d
-#define MCDI_QME_LPF_MSK				0x2f1e
-#define MCDI_REL_DIF_THD_02				0x2f1f
-#define MCDI_REL_DIF_THD_34				0x2f20
-#define MCDI_REL_BADW_GAIN_OFFST_01		0x2f21
-#define MCDI_REL_BADW_GAIN_OFFST_23		0x2f22
-#define MCDI_REL_BADW_THD_GAIN_OFFST	0x2f23
-#define MCDI_REL_BADW_THD_MIN_MAX		0x2f24
-#define MCDI_REL_SAD_GAIN_OFFST_01		0x2f25
-#define MCDI_REL_SAD_GAIN_OFFST_23		0x2f26
-#define MCDI_REL_SAD_THD_GAIN_OFFST		0x2f27
-#define MCDI_REL_SAD_THD_MIN_MAX		0x2f28
-#define MCDI_REL_DET_GAIN_00			0x2f29
-#define MCDI_REL_DET_GAIN_01			0x2f2a
-#define MCDI_REL_DET_GAIN_10			0x2f2b
-#define MCDI_REL_DET_GAIN_11			0x2f2c
-#define MCDI_REL_DET_GAIN_20			0x2f2d
-#define MCDI_REL_DET_GAIN_21			0x2f2e
-#define MCDI_REL_DET_GMV_DIF_CHK		0x2f2f
-#define MCDI_REL_DET_LMV_DIF_CHK		0x2f30
-#define MCDI_REL_DET_FRQ_CHK			0x2f31
-#define MCDI_REL_DET_PD22_CHK			0x2f32
-#define MCDI_REL_DET_RPT_CHK_ROW		0x2f33
-#define MCDI_REL_DET_RPT_CHK_GAIN_QMV	0x2f34
-#define MCDI_REL_DET_RPT_CHK_THD_0		0x2f35
-#define MCDI_REL_DET_RPT_CHK_THD_1		0x2f36
-#define MCDI_REL_DET_LPF_DIF_THD		0x2f37
-#define MCDI_REL_DET_LPF_MSK_04_12		0x2f39
-#define MCDI_REL_DET_LPF_MSK_13_21		0x2f3a
-#define MCDI_REL_DET_LPF_MSK_22_30		0x2f3b
-#define MCDI_REL_DET_LPF_MSK_31_34		0x2f3c
-#define MCDI_REL_DET_MIN				0x2f3d
-#define MCDI_REL_DET_LUT_0_3			0x2f3e
-#define MCDI_REL_DET_LUT_4_7			0x2f3f
-#define MCDI_REL_DET_LUT_8_11			0x2f40
-#define MCDI_REL_DET_LUT_12_15			0x2f41
-#define MCDI_REL_DET_COL_CFD_THD		0x2f42
-#define MCDI_REL_DET_COL_CFD_AVG_LUMA	0x2f43
-#define MCDI_REL_DET_BAD_THD_0			0x2f44
-#define MCDI_REL_DET_BAD_THD_1			0x2f45
-#define MCDI_PD22_CHK_THD				0x2f46
-#define MCDI_PD22_CHK_GAIN_OFFST_0		0x2f47
-#define MCDI_PD22_CHK_GAIN_OFFST_1		0x2f48
-#define MCDI_LMV_LOCK_CNT_THD_GAIN		0x2f49
-#define MCDI_LMV_LOCK_ABS_DIF_THD		0x2f4a
-#define MCDI_LMV_LOCK_ROW				0x2f4b
-#define MCDI_LMV_LOCK_RT_MODE			0x2f4c
-#define MCDI_GMV_LOCK_CNT_THD_GAIN		0x2f4d
-#define MCDI_GMV_LOCK_ABS_DIF_THD		0x2f4e
-#define MCDI_HIGH_VERT_FRQ_DIF_THD		0x2f4f
-#define MCDI_HIGH_VERT_FRQ_DIF_DIF_THD	0x2f50
-#define MCDI_HIGH_VERT_FRQ_RT_GAIN		0x2f51
-#define MCDI_MOTION_PARADOX_THD			0x2f52
-#define MCDI_MOTION_PARADOX_RT			0x2f53
-#define MCDI_MOTION_REF_THD				0x2f54
-#define MCDI_REL_COL_REF_RT				0x2f55
-#define MCDI_PD22_CHK_THD_RT			0x2f56
-#define MCDI_CHAR_DET_DIF_THD			0x2f57
-#define MCDI_CHAR_DET_CNT_THD			0x2f58
-#define MCDI_FIELD_MV					0x2f60
-#define MCDI_FIELD_HVF_PRDX_CNT			0x2f61
-#define MCDI_FIELD_LUMA_AVG_SUM_0		0x2f62
-#define MCDI_FIELD_LUMA_AVG_SUM_1		0x2f63
-#define MCDI_YCBCR_BLEND_CRTL			0x2f64
-#define MCDI_MCVECWR_CANVAS_SIZE		0x2f65
-#define MCDI_MCVECRD_CANVAS_SIZE		0x2f66
-#define MCDI_MCINFOWR_CANVAS_SIZE		0x2f67
-#define MCDI_MCINFORD_CANVAS_SIZE		0x2f68
-#define MCDI_MCVECWR_X					0x2f92
-#define MCDI_MCVECWR_Y					0x2f93
-#define MCDI_MCVECWR_CTRL				0x2f94
-#define MCDI_MCVECRD_X					0x2f95
-#define MCDI_MCVECRD_Y					0x2f96
-#define MCDI_MCVECRD_CTRL				0x2f97
-#define MCDI_MCINFOWR_X					0x2f98
-#define MCDI_MCINFOWR_Y					0x2f99
-#define MCDI_MCINFOWR_CTRL				0x2f9a
-#define MCDI_MCINFORD_X					0x2f9b
-#define MCDI_MCINFORD_Y					0x2f9c
-#define MCDI_MCINFORD_CTRL				0x2f9d
-#define MCDI_MC_CRTL					0x2f70
-#define MCDI_MC_LPF_MSK_0				0x2f71
-#define MCDI_MC_LPF_MSK_1				0x2f72
-#define MCDI_MC_LPF_MSK_2				0x2f73
-#define MCDI_MC_LPF_MSK_3				0x2f74
-#define MCDI_MC_LPF_MSK_4				0x2f75
-#define MCDI_MC_REL_GAIN_OFFST_0		0x2f76
-#define MCDI_MC_REL_GAIN_OFFST_1		0x2f77
-#define MCDI_MC_COL_CFD_0				0x2f78
-#define MCDI_MC_COL_CFD_1				0x2f79
-#define MCDI_MC_COL_CFD_2				0x2f7a
-#define MCDI_MC_COL_CFD_3				0x2f7b
-#define MCDI_MC_COL_CFD_4				0x2f7c
-#define MCDI_MC_COL_CFD_5				0x2f7d
-#define MCDI_MC_COL_CFD_6				0x2f7e
-#define MCDI_MC_COL_CFD_7				0x2f7f
-#define MCDI_MC_COL_CFD_8				0x2f80
-#define MCDI_MC_COL_CFD_9				0x2f81
-#define MCDI_MC_COL_CFD_10				0x2f82
-#define MCDI_MC_COL_CFD_11				0x2f83
-#define MCDI_MC_COL_CFD_12				0x2f84
-#define MCDI_MC_COL_CFD_13				0x2f85
-#define MCDI_MC_COL_CFD_14				0x2f86
-#define MCDI_MC_COL_CFD_15				0x2f87
-#define MCDI_MC_COL_CFD_16				0x2f88
-#define MCDI_MC_COL_CFD_17				0x2f89
-#define MCDI_MC_COL_CFD_18				0x2f8a
-#define MCDI_MC_COL_CFD_19				0x2f8b
-#define MCDI_MC_COL_CFD_20				0x2f8c
-#define MCDI_MC_COL_CFD_21				0x2f8d
-#define MCDI_MC_COL_CFD_22				0x2f8e
-#define MCDI_MC_COL_CFD_23				0x2f8f
-#define MCDI_MC_COL_CFD_24				0x2f90
-#define MCDI_MC_COL_CFD_25				0x2f91
-#define MCDI_RO_FLD_LUMA_AVG_SUM		0x2fa0
-#define MCDI_RO_GMV_VLD_CNT				0x2fa1
-#define MCDI_RO_RPT_FLG_CNT				0x2fa2
-#define MCDI_RO_FLD_BAD_SAD_CNT			0x2fa3
-#define MCDI_RO_FLD_BAD_BADW_CNT		0x2fa4
-#define MCDI_RO_FLD_BAD_REL_CNT			0x2fa5
-#define MCDI_RO_FLD_MTN_CNT				0x2fa6
-#define MCDI_RO_FLD_VLD_CNT				0x2fa7
-#define MCDI_RO_FLD_PD_22_PRE_CNT		0x2fa8
-#define MCDI_RO_FLD_PD_22_FOR_CNT		0x2fa9
-#define MCDI_RO_FLD_PD_22_FLT_CNT		0x2faa
-#define MCDI_RO_HIGH_VERT_FRQ_FLG		0x2fab
-#define MCDI_RO_GMV_LOCK_FLG			0x2fac
-#define MCDI_RO_RPT_MV					0x2fad
-#define MCDI_RO_MOTION_PARADOX_FLG		0x2fae
-#define MCDI_RO_PD_22_FLG				0x2faf
-#define MCDI_RO_COL_CFD_0				0x2fb0
-#define MCDI_RO_COL_CFD_1				0x2fb1
-#define MCDI_RO_COL_CFD_2				0x2fb2
-#define MCDI_RO_COL_CFD_3				0x2fb3
-#define MCDI_RO_COL_CFD_4				0x2fb4
-#define MCDI_RO_COL_CFD_5				0x2fb5
-#define MCDI_RO_COL_CFD_6				0x2fb6
-#define MCDI_RO_COL_CFD_7				0x2fb7
-#define MCDI_RO_COL_CFD_8				0x2fb8
-#define MCDI_RO_COL_CFD_9				0x2fb9
-#define MCDI_RO_COL_CFD_10				0x2fba
-#define MCDI_RO_COL_CFD_11				0x2fbb
-#define MCDI_RO_COL_CFD_12				0x2fbc
-#define MCDI_RO_COL_CFD_13				0x2fbd
-#define MCDI_RO_COL_CFD_14				0x2fbe
-#define MCDI_RO_COL_CFD_15				0x2fbf
-#define MCDI_RO_COL_CFD_16				0x2fc0
-#define MCDI_RO_COL_CFD_17				0x2fc1
-#define MCDI_RO_COL_CFD_18				0x2fc2
-#define MCDI_RO_COL_CFD_19				0x2fc3
-#define MCDI_RO_COL_CFD_20				0x2fc4
-#define MCDI_RO_COL_CFD_21				0x2fc5
-#define MCDI_RO_COL_CFD_22				0x2fc6
-#define MCDI_RO_COL_CFD_23				0x2fc7
-#define MCDI_RO_COL_CFD_24				0x2fc8
-#define MCDI_RO_COL_CFD_25				0x2fc9
+/* //=================================================================//// */
+/* // memc di core 0 */
+/* //=================================================================//// */
+#define MCDI_HV_SIZEIN                             ((0x2f00))
+/* Bit 31:29, reserved */
+/* Bit 28:16, reg_mcdi_hsize
+image horizontal size (number of cols)   default=1024 */
+/* Bit 15:13, reserved */
+/* Bit 12: 0, reg_mcdi_vsize
+image vertical size   (number of rows)   default=1024 */
+#define MCDI_HV_BLKSIZEIN                          ((0x2f01))
+/* Bit    31, reg_mcdi_vrev					 default = 0 */
+/* Bit    30, reg_mcdi_hrev					 default = 0 */
+/* Bit 29:28, reserved */
+/* Bit 27:16, reg_mcdi_blkhsize
+image horizontal blk size (number of cols)   default=1024 */
+/* Bit 15:13, reserved */
+/* Bit 11: 0, reg_mcdi_blkvsize
+image vertical blk size   (number of rows)   default=1024 */
+#define MCDI_BLKTOTAL                              ((0x2f02))
+/* Bit 31:24, reserved */
+/* Bit 23: 0, reg_mcdi_blktotal */
+#define MCDI_MOTINEN                               ((0x2f03))
+/* Bit 31: 2, reserved */
+/* Bit     1, reg_mcdi_motionrefen.
+enable motion refinement of MA, default = 1 */
+/* Bit     0, reg_mcdi_motionparadoxen.
+enable motion paradox detection, default = 1 */
+#define MCDI_CTRL_MODE                             ((0x2f04))
+/* Bit 31:28, reserved */
+/* Bit 27:26, reg_mcdi_lmvlocken
+0:disable, 1: use max Lmv, 2: use no-zero Lmv,
+lmv lock enable mode, default = 2 */
+/* Bit 25,    reg_mcdi_reldetrptchken */
+/* 0: unable; 1: enable, enable repeat pattern
+check (not repeat mv detection) in rel det part, default = 1 */
+/* Bit 24,    reg_mcdi_reldetgmvpd22chken */
+/* 0: unable; 1: enable, enable pull-down 22 mode
+check in gmv lock mode for rel det, default = 1 */
+/* Bit 23,    reg_mcdi_pd22chken */
+/* 0: unable; 1: enable, enable pull-down 22
+mode check (lock) function, default = 1 */
+/* Bit 22,    reg_mcdi_reldetlpfen */
+/* 0: unable; 1: enable, enable det value lpf, default = 1 */
+/* Bit 21,    reg_mcdi_reldetlmvpd22chken */
+/* 0: unable; 1: enable, enable pull-down 22
+mode check in lmv lock mode for rel det, default = 1 */
+/* Bit 20,    reg_mcdi_reldetlmvdifchken */
+/* 0: unable; 1: enable, enable lmv dif check
+in lmv lock mode for rel det, default = 1 */
+/* Bit 19,    reg_mcdi_reldetgmvdifchken */
+/* 0: unable; 1: enable, enable lmv dif check in
+lmv lock mode for rel det, default = 1 */
+/* Bit 18,    reg_mcdi_reldetpd22chken */
+/* 0: unable; 1: enable, enable pull-down 22
+mode check for rel det refinement, default = 1 */
+/* Bit 17,    reg_mcdi_reldetfrqchken */
+/* 0: unable; 1: enable, enable mv frequency check in rel det, default = 1 */
+/* Bit 16,    reg_mcdi_qmeen */
+/* 0: unable; 1: enable, enable quarter motion estimation, defautl = 1 */
+/* Bit 15,    reg_mcdi_refrptmven */
+/* 0: unable; 1: enable, use repeat mv in refinement, default = 1 */
+/* Bit 14,    reg_mcdi_refgmven */
+/* 0: unable; 1: enable, use gmv in refinement, default = 1 */
+/* Bit 13,    reg_mcdi_reflmven */
+/* 0: unable; 1: enable, use lmvs in refinement, default = 1 */
+/* Bit 12,    reg_mcdi_refnmven */
+/* 0: unable; 1: enable, use neighoring mvs in refinement, default = 1 */
+/* Bit 11,    reserved */
+/* Bit 10,    reg_mcdi_referrfrqchken */
+/* 0: unable; 1: enable, enable mv frquency
+check while finding min err in ref, default = 1 */
+/* Bit 9,     reg_mcdi_refen */
+/* 0: unable; 1: enable, enable mv refinement, default = 1 */
+/* Bit 8,     reg_mcdi_horlineen */
+/* 0: unable; 1: enable,enable horizontal lines
+detection by sad map, default = 1 */
+/* Bit 7,     reg_mcdi_highvertfrqdeten */
+/* 0: unable; 1: enable, enable high vertical
+frequency pattern detection, default = 1 */
+/* Bit 6,     reg_mcdi_gmvlocken */
+/* 0: unable; 1: enable, enable gmv lock mode, default = 1 */
+/* Bit 5,     reg_mcdi_rptmven */
+/* 0: unable; 1: enable, enable repeat pattern detection, default = 1 */
+/* Bit 4,     reg_mcdi_gmven */
+/* 0: unable; 1: enable, enable global motion estimation, default = 1 */
+/* Bit 3,     reg_mcdi_lmven */
+/* 0: unable; 1: enable, enable line mv estimation for hme, default = 1 */
+/* Bit 2,     reg_mcdi_chkedgeen */
+/* 0: unable; 1: enable, enable check edge function, default = 1 */
+/* Bit 1,     reg_mcdi_txtdeten */
+/* 0: unable; 1: enable, enable texture detection, default = 1 */
+/* Bit 0,     reg_mcdi_memcen */
+/* 0: unable; 1: enable, enable of memc di, default = 1 */
+#define MCDI_UNI_MVDST                             ((0x2f05))
+/* Bit 31:20, reserved */
+/* Bit 19:17, reg_mcdi_unimvdstabsseg0
+segment0 for uni-mv abs, default = 1 */
+/* Bit 16:12, reg_mcdi_unimvdstabsseg1
+segment1 for uni-mv abs, default = 15 */
+/* Bit 11: 8, reg_mcdi_unimvdstabsdifgain0
+2/2, gain0 of uni-mv abs dif for segment0, normalized 2 to '1', default = 2 */
+/* Bit  7: 5, reg_mcdi_unimvdstabsdifgain1
+2/2, gain1 of uni-mv abs dif for segment1, normalized 2 to '1', default = 2 */
+/* Bit  4: 2, reg_mcdi_unimvdstabsdifgain2
+2/2, gain2 of uni-mv abs dif beyond segment1,normalized 2 to '1', default = 2 */
+/* Bit  1: 0, reg_mcdi_unimvdstsgnshft
+shift for neighboring distance of uni-mv, default = 0 */
+#define MCDI_BI_MVDST                              ((0x2f06))
+/* Bit 31:20, reserved */
+/* Bit 19:17, reg_mcdi_bimvdstabsseg0
+segment0 for bi-mv abs, default = 1 */
+/* Bit 16:12, reg_mcdi_bimvdstabsseg1
+segment1 for bi-mv abs, default = 9 */
+/* Bit 11: 8, reg_mcdi_bimvdstabsdifgain0
+6/2, gain0 of bi-mv abs dif for segment0, normalized 2 to '1', default = 6 */
+/* Bit  7: 5, reg_mcdi_bimvdstabsdifgain1
+3/2, gain1 of bi-mvabs dif for segment1, normalized 2 to '1', default = 3 */
+/* Bit  4: 2, reg_mcdi_bimvdstabsdifgain2
+2/2, gain2 of bi-mvabs dif beyond segment1, normalized 2 to '1', default = 2 */
+/* Bit  1: 0, reg_mcdi_bimvdstsgnshft
+shift for neighboring distance of bi-mv, default = 0 */
+#define MCDI_SAD_GAIN                              ((0x2f07))
+/* Bit 31:19, reserved */
+/* Bit 18:17, reg_mcdi_unisadcorepxlgain
+uni-sad core pixels gain, default = 3 */
+/* Bit 16,    reg_mcdi_unisadcorepxlnormen
+enable uni-sad core pixels normalization, default = 0 */
+/* Bit 15:11, reserved */
+/* Bit 10: 9, reg_mcdi_bisadcorepxlgain
+bi-sad core pixels gain, default = 3 */
+/* Bit  8,    reg_mcdi_bisadcorepxlnormen
+enable bi-sad core pixels normalization, default = 1 */
+/* Bit  7: 3, reserved */
+/* Bit  2: 1, reg_mcdi_biqsadcorepxlgain
+bi-qsad core pixels gain, default = 3 */
+/* Bit  0,    reg_mcdi_biqsadcorepxlnormen
+enable bi-qsad core pixels normalization, default = 1 */
+#define MCDI_TXT_THD                               ((0x2f08))
+/* Bit 31:24, reserved */
+/* Bit 23:16, reg_mcdi_txtminmaxdifthd,
+min max dif threshold (>=) for texture detection, default = 24 */
+/* Bit 15: 8, reg_mcdi_txtmeandifthd,
+mean dif threshold (<) for texture detection, default = 9 */
+/* Bit  7: 3, reserved */
+/* Bit  2: 0, reg_mcdi_txtdetthd,
+texture detecting threshold, 0~4, default = 2 */
+#define MCDI_FLT_MODESEL                           ((0x2f09))
+/* Bit 31	 reserved */
+/* Bit 30:28, reg_mcdi_flthorlineselmode
+mode for horizontal line detecting flat calculation,default = 1,same as below */
+/* Bit 27	 reserved */
+/* Bit 26:24, reg_mcdi_fltgmvselmode
+mode for gmv flat calculation, default = 4, same as below */
+/* Bit 23,	 reserved */
+/* Bit 22:20, reg_mcdi_fltsadselmode
+mode for sad flat calculation, default = 2, same as below */
+/* Bit 19,	 reserved */
+/* Bit 18:16, reg_mcdi_fltbadwselmode
+mode for badw flat calculation, default = 3, same as below */
+/* Bit 15,	 reserved */
+/* Bit 14:12, reg_mcdi_fltrptmvselmode
+mode for repeat mv flat calculation, default = 4, same as below */
+/* Bit 11,	 reserved */
+/* Bit 10: 8, reg_mcdi_fltbadrelselmode
+mode for bad rel flat calculation, default = 4, same as below */
+/* Bit  7,	 reserved */
+/* Bit  6: 4, reg_mcdi_fltcolcfdselmode
+mode for col cfd flat calculation, default = 2, same as below */
+/* Bit  3,	 reserved */
+/* Bit  2: 0, reg_mcdi_fltpd22chkselmode
+mode for pd22 check flat calculation, default = 2, #
+0:cur dif h, 1: cur dif v, 2: pre dif h, 3: pre dif v,
+4: cur flt, 5: pre flt, 6: cur+pre, 7: max all(cur,pre) */
+#define MCDI_CHK_EDGE_THD                          ((0x2f0a))
+/* Bit 23:28, reserved. */
+/* Bit 27:24, reg_mcdi_chkedgedifsadthd.
+thd (<=) for sad dif check, 0~8, default = 1 */
+/* Bit 23:16, reserved. */
+/* Bit 15:12, reg_mcdi_chkedgemaxedgethd.
+max drt of edge, default = 15 */
+/* Bit 11: 8, reg_mcdi_chkedgeminedgethd.
+min drt of edge, default = 2 */
+/* Bit     7, reserved. */
+/* Bit  6: 0, reg_mcdi_chkedgevdifthd.
+thd for vertical dif in check edge, default = 14 */
+#define MCDI_CHK_EDGE_GAIN_OFFST                   ((0x2f0b))
+/* Bit 31:24, reserved. */
+/* Bit 23:20, reg_mcdi_chkedgedifthd1.
+thd1 for edge dif check (<=), default = 4 */
+/* Bit 19:16, reg_mcdi_chkedgedifthd0.
+thd0 for edge dif check (>=), default = 15 */
+/* Bit   :15, reserved. */
+/* Bit 14:10, reg_mcdi_chkedgechklen.
+total check length for edge check, 1~24 (>0), default = 24 */
+/* Bit  9: 8, reg_mcdi_chkedgeedgesel.
+final edge select mode, 0: original start edge, 1: lpf start edge,
+2: orignal start+end edge, 3: lpf start+end edge, default = 1 */
+/* Bit  7: 3, reg_mcdi_chkedgesaddstgain.
+distance gain for sad calc while getting edges, default = 4 */
+/* Bit     2, reg_mcdi_chkedgechkmode.
+edge used in check mode, 0: original edge, 1: lpf edge, defautl = 1 */
+/* Bit     1, reg_mcdi_chkedgestartedge.
+edge mode for start edge, 0: original edge, 1: lpf edge, defautl = 0 */
+/* Bit     0, reg_mcdi_chkedgeedgelpf.
+edge lpf mode, 0:[0,2,4,2,0], 1:[1,2,2,2,1], default = 0 */
+#define MCDI_LMV_RT                                ((0x2f0c))
+/* BIt 31:15, reserved */
+/* Bit 14:12, reg_mcdi_lmvvalidmode
+valid mode for lmv calc., 100b:use char det, 010b: use flt,001b: use hori flg */
+/* Bit 11:10, reg_mcdi_lmvgainmvmode
+four modes of mv selection for lmv weight calucluation, default = 1 */
+/* 0: cur(x-3), lst(x-1,x,x+1); 1: cur(x-4,x-3), lst(x,x+1);
+2: cur(x-5,x-4,x-3), lst(x-1,x,x+1,x+2,x+3);
+3: cur(x-6,x-5,x-4,x-3), lst(x-1,x,x+1,x+2); */
+/* Bit  9,    reg_mcdi_lmvinitmode
+initial lmvs at first row of input field, 0: intial value = 0;
+1: inital = 32 (invalid), default = 0 */
+/* Bit  8,    reserved */
+/* Bit  7: 4, reg_mcdi_lmvrt0      ratio of max mv, default = 5 */
+/* Bit  3: 0, reg_mcdi_lmvrt1      ratio of second max mv, default = 5 */
+#define MCDI_LMV_GAINTHD                           ((0x2f0d))
+/* Bit 31:24, reg_mcdi_lmvvxmaxgain    max gain of lmv weight, default = 96 */
+/* Bit 23,    reserved */
+/* Bit 22:20, reg_mcdi_lmvdifthd0
+dif threshold 0 (<) for small lmv, default = 1 */
+/* Bit 19:17, reg_mcdi_lmvdifthd1
+dif threshold 1 (<) for median lmv, default = 2 */
+/* Bit 16:14, reg_mcdi_lmvdifthd2
+dif threshold 2 (<) for large lmv, default = 3 */
+/* Bit 13: 8, reg_mcdi_lmvnumlmt
+least/limit number of (total number - max0), default = 20 */
+/* Bit  7: 0, reg_mcdi_lmvfltthd
+flt cnt thd (<) for lmv, default = 9 */
+#define MCDI_RPTMV_THD0                            ((0x2f0e))
+/* Bit 31:25, reg_mcdi_rptmvslpthd2
+slope thd (>=) between i and i+3/i-3 (i+4/i-4), default = 64 */
+/* Bit 24:20, reg_mcdi_rptmvslpthd1
+slope thd (>=) between i and i+2/i-2, default = 4 */
+/* Bit 19:10, reg_mcdi_rptmvampthd2
+amplitude thd (>=) between max and min, when count cycles, default = 300 */
+/* Bit  9: 0, reg_mcdi_rptmvampthd1
+amplitude thd (>=) between average of max and min, default = 400 */
+#define MCDI_RPTMV_THD1                            ((0x2f0f))
+/* Bit 31:28, reserved */
+/* Bit 27:25, reg_mcdi_rptmvcyccntthd
+thd (>=) of total cycles count, default = 2 */
+/* Bit 24:21, reg_mcdi_rptmvcycdifthd
+dif thd (<) of cycles length, default = 3 */
+/* Bit 20:18, reg_mcdi_rptmvcycvldthd
+thd (>) of valid cycles number, default = 1 */
+/* Bit 17:15, reg_mcdi_rptmvhalfcycminthd
+min length thd (>=) of half cycle, default = 2 */
+/* Bit 14:11, reg_mcdi_rptmvhalfcycdifthd
+neighboring half cycle length dif thd (<), default = 5 */
+/* Bit 10: 8, reg_mcdi_rptmvminmaxcntthd
+least number of valid max and min, default = 2 */
+/* Bit  7: 5, reg_mcdi_rptmvcycminthd
+min length thd (>=) of cycles, default = 2 */
+/* Bit  4: 0, reg_mcdi_rptmvcycmaxthd
+max length thd (<) of cycles, default = 17 */
+#define MCDI_RPTMV_THD2                            ((0x2f10))
+/* Bit 31:24, reserved */
+/* Bit 23:16, reg_mcdi_rptmvhdifthd0
+higher hdif thd (>=) (vertical edge) for rpt detection, default = 8 */
+/* Bit 15: 8, reg_mcdi_rptmvhdifthd1
+hdif thd (>=) (slope edge) for rpt detection, default = 4 */
+/* Bit  7: 0, reg_mcdi_rptmvvdifthd
+vdif thd (>=) (slope edge) for rpt detection, default = 1 */
+#define MCDI_RPTMV_SAD                             ((0x2f11))
+/* Bit 31:26, reserved */
+/* Bit 25:16, reg_mcdi_rptmvsaddifthdgain
+7x3x(16/16), gain for sad dif thd in rpt mv detection,
+0~672, normalized 16 as '1', default = 336 */
+/* Bit 15:10, reserved */
+/* Bit  9: 0, reg_mcdi_rptmvsaddifthdoffst
+offset for sad dif thd in rpt mv detection, -512~511, default = 16 */
+#define MCDI_RPTMV_FLG                             ((0x2f12))
+/* Bit 31:18,  reserved */
+/* Bit 17:16,  reg_mcdi_rptmvmode
+select mode of mvs for repeat motion estimation, 0: hmv,
+1: qmv/2, 2 or 3: qmv/4, default = 2 */
+/* Bit 15: 8,  reg_mcdi_rptmvflgcntthd
+thd (>=) of min count number for rptmv of whole field,
+for rptmv estimation, default = 64 */
+/* Bit  7: 5,  reserved */
+/* Bit  4: 0,  reg_mcdi_rptmvflgcntrt
+4/32, ratio for repeat mv flag count, normalized 32 as '1', set 31 to 32, */
+#define MCDI_RPTMV_GAIN                            ((0x2f13))
+/* Bit 31:24, reg_mcdi_rptmvlftgain
+up repeat mv gain for hme, default = 96 */
+/* Bit 23:16, reg_mcdi_rptmvuplftgain
+up left repeat mv gain for hme, default = 32 */
+/* Bit 15: 8, reg_mcdi_rptmvupgain
+up repeat mv gain for hme, default = 64 */
+/* Bit  7: 0, reg_mcdi_rptmvuprightgain
+up right repeat mv gain for hme, default = 32 */
+#define MCDI_GMV_RT                                ((0x2f14))
+/* Bit 31,    reserved */
+/* Bit 30:24, reg_mcdi_gmvmtnrt0
+ratio 0 for motion senario, set 127 to 128, normalized 128 as '1',default =32 */
+/* Bit 23,    reserved */
+/* Bit 22:16, reg_mcdi_gmvmtnrt1
+ratio 1 for motion senario, set 127 to 128 normalized 128 as '1',default = 56 */
+/* Bit 15,    reserved */
+/* Bit 14: 8, reg_mcdi_gmvstlrt0
+ratio 0 for still senario, set 127 to 128,normalized 128 as '1', default = 56 */
+/* Bit  7,    reserved */
+/* Bit  6: 0, reg_mcdi_gmvstlrt1
+ratio 1 for still senario, set 127 to 128, normalized 128 as '1',default = 80 */
+#define MCDI_GMV_GAIN                              ((0x2f15))
+/* Bit 31:25, reg_mcdi_gmvzeromvlockrt0
+ratio 0 for locking zero mv, set 127 to 128,
+normalized 128 as '1', default = 100 */
+/* Bit 24:18, reg_mcdi_gmvzeromvlockrt1
+ratio 1 for locking zero mv, set 127 to 128,
+normalized 128 as '1', default = 112 */
+/* Bit 17:16, reg_mcdi_gmvvalidmode
+valid mode for gmv calc., 10b: use flt, 01b: use hori flg, default = 3 */
+/* Bit 15: 8, reg_mcdi_gmvvxgain
+gmv's vx gain when gmv locked for hme, default = 0 */
+/* Bit  7: 0, reg_mcdi_gmvfltthd
+flat thd (<) for gmv calc. default = 3 */
+#define MCDI_HOR_SADOFST                           ((0x2f16))
+/* Bit 31:25, reserved */
+/* Bit 24:16, reg_mcdi_horsaddifthdgain
+21*1/8, gain/divisor for sad dif threshold in hor line detection,
+normalized 8 as '1', default = 21 */
+/* Bit 15: 8, reg_mcdi_horsaddifthdoffst
+offset for sad dif threshold in hor line detection, -128~127, default = 0 */
+/* Bit  7: 0, reg_mcdi_horvdifthd
+threshold (>=) of vertical dif of next block for
+horizontal line detection, default = 24 */
+#define MCDI_REF_MV_NUM                            ((0x2f17))
+/* Bit 31: 2, reserved */
+/* Bit  1: 0, reg_mcdi_refmcmode.         motion compensated mode used in
+refinement, 0: pre, 1: next, 2: (pre+next)/2, default = 0 */
+#define MCDI_REF_BADW_THD_GAIN                     ((0x2f18))
+/* Bit 31:28, reserved */
+/* Bit 27:24, reg_mcdi_refbadwcnt2gain.
+gain for badwv count num==3, default = 6 */
+/* Bit 23:20, reg_mcdi_refbadwcnt1gain.
+gain for badwv count num==2, default = 3 */
+/* Bit 19:16, reg_mcdi_refbadwcnt0gain.
+gain for badwv count num==1, default = 1 */
+/* Bit 15:12, reg_mcdi_refbadwthd3.
+threshold 3 for detect badweave with largest average luma, default = 4 */
+/* Bit 11: 8, reg_mcdi_refbadwthd2.
+threshold 2 for detect badweave with third smallest average luma, default = 3 */
+/* Bit  7: 4, reg_mcdi_refbadwthd1.
+threshold 1 for detect badweave with second smallest average luma,default = 2 */
+/* Bit  3: 0, reg_mcdi_refbadwthd0.
+threshold 0 for detect badweave with smallest average luma, default = 1 */
+#define MCDI_REF_BADW_SUM_GAIN                     ((0x2f19))
+/* Bit 31:13, reserved */
+/* Bit 12: 8, reg_mcdi_refbadwsumgain0.
+sum gain for r channel, 0~16, default = 8 */
+/* Bit  7: 5, reserved */
+/* Bit     4, reg_mcdi_refbadwcalcmode.
+mode for badw calculation, 0:sum, 1:max, default = 0 */
+/* Bit  3: 0, reserved */
+#define MCDI_REF_BS_THD_GAIN                       ((0x2f1a))
+/* Bit 31:28, reg_mcdi_refbsudgain1.
+up & down block stregth gain1, normalized to 8 as '1', default = 2 */
+/* Bit 27:24, reg_mcdi_refbsudgain0.
+up & down block stregth gain0, normalized to 8 as '1', default = 4 */
+/* Bit 23:19, reserved */
+/* Bit 18:16, reg_mcdi_refbslftgain.
+left block strength gain, default = 0 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_refbsthd1.
+threshold 1 for detect block stregth in refinment, default = 16 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_refbsthd0.
+threshold 0 for detect block stregth in refinment, default = 8 */
+#define MCDI_REF_ERR_GAIN0                         ((0x2f1b))
+/* Bit    31, reserved */
+/* Bit 30:24, reg_mcdi_referrnbrdstgain.
+neighoring mv distances gain for err calc. in ref,
+normalized to 8 as '1', default = 48 */
+/* Bit 23:20, reserved */
+/* Bit 19:16, reg_mcdi_referrbsgain.
+bs gain for err calc. in ref, normalized to 8 as '1', default = 4 */
+/* Bit    15, reserved */
+/* Bit 14: 8, reg_mcdi_referrbadwgain.
+badw gain for err calc. in ref, normalized to 8 as '1', default = 64 */
+/* Bit  7: 4, reserved */
+/* Bit  3: 0, reg_mcdi_referrsadgain.
+sad gain for err calc. in ref, normalized to 8 as '1', default = 4 */
+#define MCDI_REF_ERR_GAIN1                         ((0x2f1c))
+/* Bit 31:20, reserved */
+/* Bit 19:16, reg_mcdi_referrchkedgegain.
+check edge gain for err calc. in ref, normalized to 8 as '1', default = 4 */
+/* Bit 15:12, reserved */
+/* Bit 11: 8, reg_mcdi_referrlmvgain.
+(locked) lmv gain for err calc. in ref, normalized to 8 as '1', default = 0 */
+/* Bit  7: 4, reserved */
+/* Bit  3: 0, reg_mcdi_referrgmvgain.
+(locked) gmv gain for err calc. in ref, normalized to 8 as '1', default = 0 */
+#define MCDI_REF_ERR_FRQ_CHK                       ((0x2f1d))
+/* Bit 31:28, reserved */
+/* Bit 27:24, reg_mcdi_referrfrqgain.
+gain for mv frquency, normalized to 4 as '1', default = 10 */
+/* Bit 23:21, reserved */
+/* Bit 20:16, reg_mcdi_referrfrqmax.
+max gain for mv frquency check, default = 31 */
+/* Bit    15, reserved */
+/* Bit 14:12, reg_mcdi_ref_errfrqmvdifthd2.
+mv dif threshold 2 (<) for mv frquency check, default = 3 */
+/* Bit    11, reserved */
+/* Bit 10: 8, reg_mcdi_ref_errfrqmvdifthd1.
+mv dif threshold 1 (<) for mv frquency check, default = 2 */
+/* Bit     7, reserved */
+/* Bit  6: 4, reg_mcdi_ref_errfrqmvdifthd0.
+mv dif threshold 0 (<) for mv frquency check, default = 1 */
+/* Bit  3: 0, reserved */
+#define MCDI_QME_LPF_MSK                           ((0x2f1e))
+/* Bit 31:28, reserved */
+/* Bit 27:24, reg_mcdi_qmechkedgelpfmsk0.
+lpf mask0 for chk edge in qme, 0~8, msk1 = (8-msk0),
+normalized to 8 as '1', default = 7 */
+/* Bit 23:20, reserved */
+/* Bit 19:16, reg_mcdi_qmebslpfmsk0.
+lpf mask0 for bs in qme, 0~8, msk1 = (8-msk0),
+normalized to 8 as '1', default = 7 */
+/* Bit 15:12, reserved */
+/* Bit 11: 8, reg_mcdi_qmebadwlpfmsk0.
+lpf mask0 for badw in qme, 0~8, msk1 = (8-msk0),
+normalized to 8 as '1', default = 7 */
+/* Bit  7: 4, reserved */
+/* Bit  3: 0, reg_mcdi_qmesadlpfmsk0.
+lpf mask0 for sad in qme, 0~8, msk1 = (8-msk0),
+normalized to 8 as '1', default = 7 */
+#define MCDI_REL_DIF_THD_02                        ((0x2f1f))
+/* Bit 31:24, reserved. */
+/* Bit 23:16, reg_mcdi_reldifthd2.
+thd (<) for (hdif+vdif), default = 9 */
+/* Bit 15: 8, reg_mcdi_reldifthd1.
+thd (<) for (vdif), default = 5 */
+/* Bit  7: 0, reg_mcdi_reldifthd0.
+thd (>=) for (hdif-vdif), default = 48 */
+#define MCDI_REL_DIF_THD_34                        ((0x2f20))
+/* Bit 31:16, reserved. */
+/* Bit 15: 8, reg_mcdi_reldifthd4.
+thd (<) for (hdif), default = 255 */
+/* Bit  7: 0, reg_mcdi_reldifthd3.
+thd (>=) for (vdif-hdif), default = 48 */
+#define MCDI_REL_BADW_GAIN_OFFST_01                ((0x2f21))
+/* Bit 31:24, reg_mcdi_relbadwoffst1.
+offset for badw adj, for flat block, -128~127, default = 0 */
+/* Bit 23:16, reg_mcdi_relbadwgain1.
+gain for badw adj, for flat block, default = 128 */
+/* Bit 15: 8, reg_mcdi_relbadwoffst0.
+offset for badw adj, for vertical block, -128~127, default = 0 */
+/* Bit  7: 0, reg_mcdi_relbadwgain0.
+gain for badw adj, for vertical block, default = 160 */
+#define MCDI_REL_BADW_GAIN_OFFST_23                ((0x2f22))
+/* Bit 31:24, reg_mcdi_relbadwoffst3.
+offset for badw adj, for other block, -128~127, default = 0 */
+/* Bit 23:16, reg_mcdi_relbadwgain3.
+gain for badw adj, for other block, default = 48 */
+/* Bit 15: 8, reg_mcdi_relbadwoffst2.
+offset for badw adj, for horizontal block, -128~127, default = 0 */
+/* Bit  7: 0, reg_mcdi_relbadwgain2.
+gain for badw adj, for horizontal block, default = 48 */
+#define MCDI_REL_BADW_THD_GAIN_OFFST               ((0x2f23))
+/* Bit 31:23, reserved. */
+/* Bit 22:16, reg_mcdi_relbadwoffst.
+offset for badw thd adj, -64~63, default = 0 */
+/* Bit 15: 8, reserved. */
+/* Bit  7: 0, reg_mcdi_relbadwthdgain.
+gain0 for badw thd adj, normalized to 16 as '1', default = 16 */
+#define MCDI_REL_BADW_THD_MIN_MAX                  ((0x2f24))
+/* Bit 31:18, reserved. */
+/* Bit 17: 8, reg_mcdi_relbadwthdmax.
+max for badw thd adj, default = 256 */
+/* Bit  7: 0, reg_mcdi_relbadwthdmin.
+min for badw thd adj, default = 16 */
+#define MCDI_REL_SAD_GAIN_OFFST_01                 ((0x2f25))
+/* Bit 31:24, reg_mcdi_relsadoffst1.
+offset for sad adj, for flat block, -128~127, default = 0 */
+/* Bit 23:20, reserved. */
+/* Bit 19:16, reg_mcdi_relsadgain1.
+gain for sad adj, for flat block, normalized to 8 as '1', default = 8 */
+/* Bit 15: 8, reg_mcdi_relsadoffst0.
+offset for sad adj, for vertical block, -128~127, default = 0 */
+/* Bit  7: 4, reserved. */
+/* Bit  3: 0, reg_mcdi_relsadgain0.
+gain for sad adj, for vertical block, normalized to 8 as '1', default = 6 */
+#define MCDI_REL_SAD_GAIN_OFFST_23                 ((0x2f26))
+/* Bit 31:24, reg_mcdi_relsadoffst3.
+offset for sad adj, for other block, -128~127, default = 0 */
+/* Bit 23:20, reserved. */
+/* Bit 19:16, reg_mcdi_relsadgain3.
+gain for sad adj, for other block, normalized to 8 as '1', default = 8 */
+/* Bit 15: 8, reg_mcdi_relsadoffst2.
+offset for sad adj, for horizontal block, -128~127, default = 0 */
+/* Bit  7: 4, reserved. */
+/* Bit  3: 0, reg_mcdi_relsadgain2.
+gain for sad adj, for horizontal block, normalized to 8 as '1', default = 12 */
+#define MCDI_REL_SAD_THD_GAIN_OFFST                ((0x2f27))
+/* Bit 31:24, reserved. */
+/* Bit 23:16, reg_mcdi_relsadoffst.
+offset for sad thd adj, -128~127, default = 0 */
+/* Bit 15:10, reserved. */
+/* Bit  9: 0, reg_mcdi_relsadthdgain.
+gain for sad thd adj, 21*2/16, normalized to 16 as '1', default = 42 */
+#define MCDI_REL_SAD_THD_MIN_MAX                   ((0x2f28))
+/* Bit 31:27, reserved. */
+/* Bit 26:16, reg_mcdi_relsadthdmax.
+max for sad thd adj, 21*32, default = 672 */
+/* Bit 15: 9, reserved. */
+/* Bit  8: 0, reg_mcdi_relsadthdmin.
+min for sad thd adj, 21*2, default = 42 */
+#define MCDI_REL_DET_GAIN_00                       ((0x2f29))
+/* Bit 31:21, reserved. */
+/* Bit 20:16, reg_mcdi_reldetbsgain0.
+gain0 (gmv locked) for bs, for det. calc. normalized to 16 as '1',
+default = 8 */
+/* Bit 15:14, reserved. */
+/* Bit 13: 8, reg_mcdi_reldetbadwgain0.
+gain0 (gmv locked) for badw, for det. calc.
+normalized to 16 as '1', default = 12 */
+/* Bit  7: 5, reserved. */
+/* Bit  4: 0, reg_mcdi_reldetsadgain0.
+gain0 (gmv locked) for qsad, for det. calc.
+normalized to 16 as '1', default = 8 */
+#define MCDI_REL_DET_GAIN_01                       ((0x2f2a))
+/* Bit 31:14, reserved. */
+/* Bit 12: 8, reg_mcdi_reldetchkedgegain0.
+gain0 (gmv locked) for chk_edge, for det. calc.
+normalized to 16 as '1', default = 2 */
+/* Bit     7, reserved. */
+/* Bit  6: 0, reg_mcdi_reldetnbrdstgain0.
+gain0 (gmv locked) for neighoring dist, for det.
+calc. normalized to 16 as '1', default = 24 */
+#define MCDI_REL_DET_GAIN_10                       ((0x2f2b))
+/* Bit 31:21, reserved. */
+/* Bit 20:16, reg_mcdi_reldetbsgain1.
+gain1 (lmv locked) for bs, for det. calc. normalized
+to 16 as '1', default = 0 */
+/* Bit 15:14, reserved. */
+/* Bit 13: 8, reg_mcdi_reldetbadwgain1.
+gain1 (lmv locked) for badw, for det. calc.
+normalized to 16 as '1', default = 8 */
+/* Bit  7: 5, reserved. */
+/* Bit  4: 0, reg_mcdi_reldetsadgain1.
+gain1 (lmv locked) for qsad, for det. calc.
+normalized to 16 as '1', default = 8 */
+#define MCDI_REL_DET_GAIN_11                       ((0x2f2c))
+/* Bit 31:14, reserved. */
+/* Bit 12: 8, reg_mcdi_reldetchkedgegain1.
+gain1 (lmv locked) for chk_edge, for det. calc.
+normalized to 16 as '1', default = 0 */
+/* Bit     7, reserved. */
+/* Bit  6: 0, reg_mcdi_reldetnbrdstgain1.
+gain1 (lmv locked) for neighoring dist, for det.
+calc. normalized to 16 as '1', default = 24 */
+#define MCDI_REL_DET_GAIN_20                       ((0x2f2d))
+/* Bit 31:21, reserved. */
+/* Bit 20:16, reg_mcdi_reldetbsgain2.
+gain2 (no locked) for bs, for det. calc.normalized to 16 as '1', default = 12 */
+/* Bit 15:14, reserved. */
+/* Bit 13: 8, reg_mcdi_reldetbadwgain2.
+gain2 (no locked) for badw, for det. calc.
+normalized to 16 as '1',default = 32 */
+/* Bit  7: 5, reserved. */
+/* Bit  4: 0, reg_mcdi_reldetsadgain2.
+gain2 (no locked) for qsad, for det. calc.
+normalized to 16 as '1', default = 16 */
+#define MCDI_REL_DET_GAIN_21                       ((0x2f2e))
+/* Bit 31:26, reserved */
+/* Bit 25:16, reg_mcdi_reldetoffst.
+offset for rel calculation, for det. calc. -512~511,  default = 0 */
+/* Bit 15:14, reserved. */
+/* Bit 12: 8, reg_mcdi_reldetchkedgegain2.
+gain2 (no locked) for chk_edge, for det. calc.
+normalized to 16 as '1', default = 10 */
+/* Bit     7, reserved. */
+/* Bit  6: 0, reg_mcdi_reldetnbrdstgain2.
+gain2 (no locked) for neighoring dist, for det. calc.
+normalized to 16 as '1', default = 32 */
+#define MCDI_REL_DET_GMV_DIF_CHK                   ((0x2f2f))
+/* Bit 31:24, reserved. */
+/* Bit 23:16, reg_mcdi_reldetgmvfltthd.
+flat thd (>=) for gmv lock decision, default = 0 */
+/* Bit    15, reserved. */
+/* Bit 14:12, reg_mcdi_reldetgmvdifthd.
+dif thd (>=) for current mv different from gmv for gmv dif check,
+actually used in Lmv lock check, default = 3 */
+/* Bit    11, reserved. */
+/* Bit 10: 8, reg_mcdi_reldetgmvdifmin.
+min mv dif for gmv dif check, default = 1, note: dif between
+reg_mcdi_rel_det_gmv_dif_max and reg_mcdi_rel_det_gmv_dif_min
+should be; 0,1,3,7, not work for others */
+/* Bit  7: 4, reg_mcdi_reldetgmvdifmax.
+max mv dif for gmv dif check, default = 4 */
+/* Bit  3: 1, reserved */
+/* Bit     0, reg_mcdi_reldetgmvdifmvmode.
+mv mode used for gmv dif check, 0: use refmv, 1: use qmv, default = 0 */
+#define MCDI_REL_DET_LMV_DIF_CHK                   ((0x2f30))
+/* Bit 31:24, reserved. */
+/* Bit 23:16, reg_mcdi_reldetlmvfltthd.
+flat thd (>=) for lmv lock decision, default = 12 */
+/* Bit 15:14, reserved. */
+/* Bit 13:12, reg_mcdi_reldetlmvlockchkmode.
+lmv lock check mode, 0:cur Lmv, 1: cur & (last | next),
+2: last & cur & next Lmv, default = 1 */
+/* Bit    11, reserved. */
+/* Bit 10: 8, reg_mcdi_reldetlmvdifmin.
+min mv dif for lmv dif check, default = 1, note: dif between
+reg_mcdi_rel_det_lmv_dif_max and reg_mcdi_rel_det_lmv_dif_min should be;
+0,1,3,7, not work for others */
+/* Bit  7: 4, reg_mcdi_reldetlmvdifmax.
+max mv dif for lmv dif check, default = 4 */
+/* Bit  3: 1, reserved */
+/* Bit     0, reg_mcdi_reldetlmvdifmvmode.
+mv mode used for lmv dif check, 0: use refmv, 1: use qmv, default = 0 */
+#define MCDI_REL_DET_FRQ_CHK                       ((0x2f31))
+/* Bit 31:12, reserved. */
+/* Bit 11: 8, reg_mcdi_reldetfrqgain.
+gain for frequency check, normalized to 4 as '1', default = 10 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_reldetfrqmax.
+max value for frequency check, default = 31 */
+#define MCDI_REL_DET_PD22_CHK                      ((0x2f32))
+/* Bit 31:18, reserved. */
+/* Bit 17: 8, reg_mcdi_reldetpd22chkoffst.
+offset for pd22 check happened, default = 512 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_reldetpd22chkgain.
+gain for pd22 check happened, normalized to 8 as '1', default = 12 */
+#define MCDI_REL_DET_RPT_CHK_ROW                   ((0x2f33))
+/* Bit 31:27, reserved */
+/* Bit 26:16, reg_mcdi_reldetrptchkendrow.
+end row (<) number for repeat check, default = 2047 */
+/* Bit 15:11, reserved */
+/* Bit 10: 0, reg_mcdi_reldetrptchkstartrow.
+start row (>=) number for repeat check, default = 0 */
+#define MCDI_REL_DET_RPT_CHK_GAIN_QMV              ((0x2f34))
+/* Bit 31:30, reserved */
+/* Bit 29:24, reg_mcdi_reldetrptchkqmvmax.
+max thd (<) of abs qmv for repeat check, default = 15,
+note that quarter mv's range is -63~63 */
+/* Bit 23:22, reserved */
+/* Bit 21:16, reg_mcdi_reldetrptchkqmvmin.
+min thd (>=) of abs qmv for repeat check, default = 10,
+note that quarter mv's range is -63~63 */
+/* Bit    15, reserved/ */
+/* Bit 14: 4, reg_mcdi_reldetrptchkoffst.
+offset for repeat check, default = 512 */
+/* Bit  3: 0, reg_mcdi_reldetrptchkgain.
+gain for repeat check, normalized to 8 as '1', default = 4 */
+#define MCDI_REL_DET_RPT_CHK_THD_0                 ((0x2f35))
+/* Bit 31:24, reserved */
+/* Bit 23:16, reg_mcdi_reldetrptchkzerosadthd.
+zero sad thd (<) for repeat check, default = 255 */
+/* Bit 15:14, reserved. */
+/* Bit 13: 8, reg_mcdi_reldetrptchkzerobadwthd.
+zero badw thd (>=) for repeat check, default = 16 */
+/* Bit  7: 4, reserved */
+/* Bit  3: 0, reg_mcdi_reldetrptchkfrqdifthd.
+frequency dif thd (<) for repeat check, 0~10, default = 5 */
+#define MCDI_REL_DET_RPT_CHK_THD_1                 ((0x2f36))
+/* Bit 31:16, reserved */
+/* Bit 15: 8, reg_mcdi_reldetrptchkvdifthd.
+vertical dif thd (<) for repeat check, default = 16 */
+/* Bit  7: 0, reg_mcdi_reldetrptchkhdifthd.
+horizontal dif thd (>=) for repeat check, default = 16 */
+#define MCDI_REL_DET_LPF_DIF_THD                   ((0x2f37))
+/* Bit 31:24, reg_mcdi_reldetlpfdifthd3.
+hdif thd (<) for lpf selection of horizontal block, default = 9 */
+/* Bit 23:16, reg_mcdi_reldetlpfdifthd2.
+vdif-hdif thd (>=) for lpf selection of horizontal block, default = 48 */
+/* Bit 15: 8, reg_mcdi_reldetlpfdifthd1.
+vdif thd (<) for lpf selection of vertical block, default = 9 */
+/* Bit  7: 0, reg_mcdi_reldetlpfdifthd0.
+hdif-vdif thd (>=) for lpf selection of vertical block, default = 48 */
+#define MCDI_REL_DET_LPF_MSK_00_03                 ((0x2f38))
+/* Bit 31:29, reserved */
+/* Bit 28:24, reg_mcdi_reldetlpfmsk03.
+det lpf mask03 for gmv/lmv locked mode, 0~16, default = 1 */
+/* Bit 23:21, reserved */
+/* Bit 20:16, reg_mcdi_reldetlpfmsk02.
+det lpf mask02 for gmv/lmv locked mode, 0~16, default = 1 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_reldetlpfmsk01.
+det lpf mask01 for gmv/lmv locked mode, 0~16, default = 5 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_reldetlpfmsk00.
+det lpf mask00 for gmv/lmv locked mode, 0~16, default = 8 */
+#define MCDI_REL_DET_LPF_MSK_04_12                 ((0x2f39))
+/* Bit 31:29, reserved */
+/* Bit 28:24, reg_mcdi_reldetlpfmsk12.
+det lpf mask12 for vertical blocks, 0~16, default = 0 */
+/* Bit 23:21, reserved */
+/* Bit 20:16, reg_mcdi_reldetlpfmsk11.
+det lpf mask11 for vertical blocks, 0~16, default = 0 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_reldetlpfmsk10.
+det lpf mask10 for vertical blocks, 0~16, default = 16 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_reldetlpfmsk04.
+det lpf mask04 for gmv/lmv locked mode, 0~16, default = 1 */
+#define MCDI_REL_DET_LPF_MSK_13_21                 ((0x2f3a))
+/* Bit 31:29, reserved */
+/* Bit 28:24, reg_mcdi_reldetlpfmsk21.
+det lpf mask21 for horizontal blocks, 0~16, default = 6 */
+/* Bit 23:21, reserved */
+/* Bit 20:16, reg_mcdi_reldetlpfmsk20.
+det lpf mask20 for horizontal blocks, 0~16, default = 8 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_reldetlpfmsk14.
+det lpf mask14 for vertical blocks, 0~16, default = 0 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_reldetlpfmsk13.
+det lpf mask13 for vertical blocks, 0~16, default = 0 */
+#define MCDI_REL_DET_LPF_MSK_22_30                 ((0x2f3b))
+/* Bit 31:29, reserved */
+/* Bit 28:24, reg_mcdi_reldetlpfmsk30.
+det lpf mask30 for other blocks, 0~16, default = 16 */
+/* Bit 23:21, reserved */
+/* Bit 20:16, reg_mcdi_reldetlpfmsk24.
+det lpf mask24 for horizontal blocks, 0~16, default = 1 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_reldetlpfmsk23.
+det lpf mask23 for horizontal blocks, 0~16, default = 0 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_reldetlpfmsk22.
+det lpf mask22 for horizontal blocks, 0~16, default = 1 */
+#define MCDI_REL_DET_LPF_MSK_31_34                 ((0x2f3c))
+/* Bit 31:29, reserved */
+/* Bit 28:24, reg_mcdi_reldetlpfmsk34.
+det lpf mask34 for other blocks, 0~16, default = 0 */
+/* Bit 23:21, reserved */
+/* Bit 20:16, reg_mcdi_reldetlpfmsk33.
+det lpf mask33 for other blocks, 0~16, default = 0 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_reldetlpfmsk32.
+det lpf mask32 for other blocks, 0~16, default = 0 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_reldetlpfmsk31.
+det lpf mask31 for other blocks, 0~16, default = 0 */
+/* Note: there are four group lpf masks from addr 37~3b,
+each group sum equal to 16. */
+#define MCDI_REL_DET_MIN                           ((0x2f3d))
+/* Bit 31: 7, reserved */
+/* Bit  6: 0, reg_mcdi_reldetmin.
+min of detected value, default = 16 */
+#define MCDI_REL_DET_LUT_0_3                       ((0x2f3e))
+/* Bit 31:24, reg_mcdi_reldetmaplut3.               default = 8 */
+/* Bit 23:16, reg_mcdi_reldetmaplut2.               default = 4 */
+/* Bit 15: 8, reg_mcdi_reldetmaplut1.               default = 2 */
+/* Bit  7: 0, reg_mcdi_reldetmaplut0.               default = 0 */
+#define MCDI_REL_DET_LUT_4_7                       ((0x2f3f))
+/* Bit 31:24, reg_mcdi_reldetmaplut7.               default = 64 */
+/* Bit 23:16, reg_mcdi_reldetmaplut6.               default = 48 */
+/* Bit 15: 8, reg_mcdi_reldetmaplut5.               default = 32 */
+/* Bit  7: 0, reg_mcdi_reldetmaplut4.               default = 16 */
+#define MCDI_REL_DET_LUT_8_11                      ((0x2f40))
+/* Bit 31:24, reg_mcdi_reldetmaplut11.              default = 160 */
+/* Bit 23:16, reg_mcdi_reldetmaplut10.              default = 128 */
+/* Bit 15: 8, reg_mcdi_reldetmaplut9.               default = 96 */
+/* Bit  7: 0, reg_mcdi_reldetmaplut8.               default = 80 */
+#define MCDI_REL_DET_LUT_12_15                     ((0x2f41))
+/* Bit 31:24, reg_mcdi_reldetmaplut15.              default = 255 */
+/* Bit 23:16, reg_mcdi_reldetmaplut14.              default = 240 */
+/* Bit 15: 8, reg_mcdi_reldetmaplut13.              default = 224 */
+/* Bit  7: 0, reg_mcdi_reldetmaplut12.              default = 192 */
+#define MCDI_REL_DET_COL_CFD_THD                   ((0x2f42))
+/* Bit 31:24, reg_mcdi_reldetcolcfdfltthd.
+thd for flat smaller than (<) of column cofidence, default = 5 */
+/* Bit 23:16, reg_mcdi_reldetcolcfdthd1.
+thd for rel larger than (>=) in rel calc.
+mode col confidence without gmv locking, default = 160 */
+/* Bit 15: 8, reg_mcdi_reldetcolcfdthd0.
+thd for rel larger than (>=) in rel calc.
+mode col confidence when gmv locked, default = 100 */
+/* Bit  7: 2, reg_mcdi_reldetcolcfdbadwthd.
+thd for badw larger than (>=) in qbadw calc.
+mode of column cofidence, default = 16 */
+/* Bit     1, reserved */
+/* Bit     0, reg_mcdi_reldetcolcfdcalcmode.        calc.
+mode for column cofidence, 0: use rel, 1: use qbadw, default = 0 */
+#define MCDI_REL_DET_COL_CFD_AVG_LUMA              ((0x2f43))
+/* Bit 31:24, reg_mcdi_reldetcolcfdavgmin1.
+avg luma min1 (>=) for column cofidence, valid between 16~235, default = 235 */
+/* Bit 23:16, reg_mcdi_reldetcolcfdavgmax1.
+avg luma max1 (<)  for column cofidence, valid between 16~235, default = 235 */
+/* Bit 15: 8, reg_mcdi_reldetcolcfdavgmin0.
+avg luma min0 (>=) for column cofidence, valid between 16~235, default = 16 */
+/* Bit  7: 0, reg_mcdi_reldetcolcfdavgmax0.
+avg luma max0 (<)  for column cofidence, valid between 16~235, default = 21 */
+#define MCDI_REL_DET_BAD_THD_0                     ((0x2f44))
+/* Bit 31:16, reserved */
+/* Bit 15: 8, reg_mcdi_reldetbadsadthd.
+thd (>=) for bad sad, default = 120 (480/4) */
+/* Bit  7: 6, reserved */
+/* Bit  5: 0, reg_mcdi_reldetbadbadwthd.
+thd (>=) for bad badw, 0~42, default = 12 */
+#define MCDI_REL_DET_BAD_THD_1                     ((0x2f45))
+/* Bit 31:24, reserved */
+/* Bit 23:16, reg_mcdi_reldetbadrelfltthd.
+thd (>=) of flat for bad rel detection, default = 4 */
+/* Bit 15: 8, reg_mcdi_reldetbadrelthd1.
+thd (>=) for bad rel without gmv/lmv locked, default = 160 */
+/* Bit  7: 0, reg_mcdi_reldetbadrelthd0.
+thd (>=) for bad rel with gmv/lmv locked, default = 120 */
+#define MCDI_PD22_CHK_THD                          ((0x2f46))
+/* Bit 31:25, reserved */
+/* Bit 24:16, reg_mcdi_pd22chksaddifthd.
+sad dif thd (>=) for (pd22chksad - qsad) for pd22 check, default = 64 */
+/* Bit 15:14, reserved */
+/* Bit 13: 8, reg_mcdi_pd22chkqmvthd.
+thd (>=) of abs qmv for pd22 check, default = 2 */
+/* Bit  7: 0, reg_mcdi_pd22chkfltthd.
+thd (>=) of flat for pd22 check, default = 4 */
+#define MCDI_PD22_CHK_GAIN_OFFST_0                 ((0x2f47))
+/* Bit 31:24, reg_mcdi_pd22chkedgeoffst0.
+offset0 of pd22chkedge from right film22 phase, -128~127, default = 0 */
+/* Bit 23:21, reserved */
+/* Bit 20:16, reg_mcdi_pd22chkedgegain0.
+gain0 of pd22chkedge from right film22 phase,
+normalized to 16 as '1', default = 16 */
+/* Bit 15:12, reserved */
+/* Bit 11: 8, reg_mcdi_pd22chkbadwoffst0.
+offset0 of pd22chkbadw from right film22 phase, -8~7, default = 0 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_pd22chkbadwgain0.
+gain0 of pd22chkbadw from right film22 phase,
+normalized to 16 as '1', default = 8 */
+#define MCDI_PD22_CHK_GAIN_OFFST_1                 ((0x2f48))
+/* Bit 31:24, reg_mcdi_pd22chkedgeoffst1.
+offset1 of pd22chkedge from right film22 phase, -128~127, default = 0 */
+/* Bit 23:21, reserved */
+/* Bit 20:16, reg_mcdi_pd22chkedgegain1.
+gain1 of pd22chkedge from right film22 phase,
+normalized to 16 as '1', default = 16 */
+/* Bit 15:12, reserved */
+/* Bit 11: 8, reg_mcdi_pd22chkbadwoffst1.
+offset1 of pd22chkbadw from right film22 phase, -8~7, default = 0 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_pd22chkbadwgain1.
+gain1 of pd22chkbadw from right film22 phase,
+normalized to 16 as '1', default = 12 */
+#define MCDI_LMV_LOCK_CNT_THD_GAIN                 ((0x2f49))
+/* Bit 31:20, reserved */
+/* Bit 19:16, reg_mcdi_lmvlockcntmax.
+max lmv lock count number, default = 6 */
+/* Bit 15:12, reg_mcdi_lmvlockcntoffst.
+offset for lmv lock count, -8~7, default =  0 */
+/* Bit 11: 8, reg_mcdi_lmvlockcntgain.
+gain for lmv lock count, normalized 8 as '1', 15 is set to 16, default = 8 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_lmvlockcntthd.
+lmv count thd (>=) before be locked, 1~31, default = 4 */
+#define MCDI_LMV_LOCK_ABS_DIF_THD                  ((0x2f4a))
+/* Bit 31:27, reserved */
+/* Bit 26:24, reg_mcdi_lmvlockdifthd2.
+lmv dif thd for third part, before locked, default = 1 */
+/* Bit    23, reserved */
+/* Bit 22:20, reg_mcdi_lmvlockdifthd1.
+lmv dif thd for second part, before locked, default = 1 */
+/* Bit    19, reserved */
+/* Bit 18:16, reg_mcdi_lmvlockdifthd0.
+lmv dif thd for first part, before locked, default = 1 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_lmvlockabsmax.
+max abs (<) of lmv to be locked, default = 24 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_lmvlockabsmin.
+min abs (>=) of lmv to be locked, default = 1 */
+#define MCDI_LMV_LOCK_ROW                          ((0x2f4b))
+/* Bit 31:27, reserved */
+/* Bit 26:16, reg_mcdi_lmvlockendrow.
+end row (<) for lmv lock, default = 2047 */
+/* Bit 15:11, reserved */
+/* Bit 10: 0, reg_mcdi_lmvlockstartrow.
+start row (>=) for lmv lock, default = 0 */
+#define MCDI_LMV_LOCK_RT_MODE                      ((0x2f4c))
+/* Bit 31:27, reserved */
+/* Bit 26:24, reg_mcdi_lmvlockextmode.
+extend lines for lmv lock check, check how many lines
+for lmv locking, default = 2 */
+/* Bit 23:16, reg_mcdi_lmvlockfltcntrt.
+ratio of flt cnt for lock check, normalized 256 as '1',
+255 is set to 256, default = 32 */
+/* Bit 15: 8, reg_mcdi_lmvlocklmvcntrt1.
+ratio when use non-zero lmv for lock check,
+normalized 256 as '1', 255 is set to 256, default = 48 */
+/* Bit  7: 0, reg_mcdi_lmvlocklmvcntrt0.
+ratio when use max lmv for lock check, normalized 256 as '1',
+255 is set to 256, default = 106 */
+#define MCDI_GMV_LOCK_CNT_THD_GAIN                 ((0x2f4d))
+/* Bit 31:20, reserved */
+/* Bit 19:16, reg_mcdi_gmvlockcntmax.
+max gmv lock count number, default = 6 */
+/* Bit 15:12, reg_mcdi_gmvlockcntoffst.
+offset for gmv lock count, -8~7, default =  0 */
+/* Bit 11: 8, reg_mcdi_gmvlockcntgain.
+gain for gmv lock count, normalized 8 as '1', 15 is set to 16, default = 8 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_gmvlockcntthd.
+gmv count thd (>=) before be locked, 1~31, default = 4 */
+#define MCDI_GMV_LOCK_ABS_DIF_THD                  ((0x2f4e))
+/* Bit 31:27, reserved */
+/* Bit 26:24, reg_mcdi_gmvlockdifthd2.
+gmv dif thd for third part, before locked, default = 3 */
+/* Bit    23, reserved */
+/* Bit 22:20, reg_mcdi_gmvlockdifthd1.
+gmv dif thd for second part, before locked, default = 2 */
+/* Bit    19, reserved */
+/* Bit 18:16, reg_mcdi_gmvlockdifthd0.
+gmv dif thd for first part, before locked, default = 1 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_gmvlockabsmax.
+max abs of gmv to be locked, default = 15 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_gmvlockabsmin.
+min abs of gmv to be locked, default = 1 */
+#define MCDI_HIGH_VERT_FRQ_DIF_THD                 ((0x2f4f))
+/* Bit 31: 0, reg_mcdi_highvertfrqfldavgdifthd.
+high_vert_frq field average luma dif thd (>=), 3*Blk_Width*Blk_Height,
+set by software, default = 103680 */
+#define MCDI_HIGH_VERT_FRQ_DIF_DIF_THD             ((0x2f50))
+/* Bit 31: 0, reg_mcdi_highvertfrqfldavgdifdifthd.
+high_vert_frq field average luma dif's dif thd (<), 3*Blk_Width*Blk_Height,
+set by software, default = 103680 */
+#define MCDI_HIGH_VERT_FRQ_RT_GAIN                 ((0x2f51))
+/* Bit 31:20, reserved */
+/* Bit 19:16, reg_mcdi_highvertfrqcntthd.
+high_vert_frq count thd (>=) before locked, 1~31, default = 4 */
+/* Bit 15: 8, reg_mcdi_highvertfrqbadsadrt.
+ratio for high_vert_frq bad sad count, normalized 256 as '1',
+255 is set to 256, default = 24 */
+/* Bit  7: 0, reg_mcdi_highvertfrqbadbadwrt.
+ratio for high_vert_frq badw count, normalized 256 as '1',
+255 is set to 256, default = 130 */
+#define MCDI_MOTION_PARADOX_THD                    ((0x2f52))
+/* Bit 31:29, reserved */
+/* Bit 28:24, reg_mcdi_motionparadoxcntthd.
+motion paradox count thd (>=) before locked, 1~31, default = 4 */
+/* Bit 23:22, reserved */
+/* Bit 21:16, reg_mcdi_motionparadoxgmvthd.
+abs gmv thd (<) of motion paradox, 0~32, note that 32
+means invalid gmv, be careful, default = 32 */
+/* Bit 15: 0, reserved */
+#define MCDI_MOTION_PARADOX_RT                     ((0x2f53))
+/* Bit 31:24, reserved */
+/* Bit 23:16, reg_mcdi_motionparadoxbadsadrt.
+ratio for field bad sad count of motion paradox,
+normalized 256 as '1', 255 is set to 256, default = 24 */
+/* Bit 15: 8, reg_mcdi_motionparadoxbadrelrt.
+ratio for field bad reliabilty count of motion paradox,
+normalized 256 as '1', 255 is set to 256, default = 120 */
+/* Bit  7: 0, reg_mcdi_motionparadoxmtnrt.
+ratio for field motion count of motion paradox,
+normalized 256 as '1', 255 is set to 256, default = 218 */
+#define MCDI_MOTION_REF_THD                        ((0x2f54))
+/* Bit 31:24, reserved */
+/* Bit 23:20, reg_mcdi_motionrefoffst.
+motion ref additive offset, default = 15 */
+/* Bit 19:16, reg_mcdi_motionrefgain.
+motion ref gain, normalized 8 as '1', default = 8 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_motionrefrptmvthd.
+abs thd (>=) of rpt mv (0~31, 32 means invalid) for motion ref, default = 1 */
+/* Bit  7: 2, reg_mcdi_motionrefqmvthd.
+min thd (>=) of abs qmv for motion ref,
+note that quarter mv's range is -63~63, default = 2 */
+/* Bit  1: 0, reg_mcdi_motionreflpfmode.
+Mv and (8 x repeat flg) 's lpf mode of motion refinement,
+0: no lpf, 1: [1 2 1], 2: [1 2 2 2 1], default = 1 */
+#define MCDI_REL_COL_REF_RT                        ((0x2f55))
+/* Bit 31: 8, reserved */
+/* Bit  7: 0, reg_mcdi_relcolrefrt.
+ratio for column cofidence level against column number,
+for refinement, default = 135 */
+#define MCDI_PD22_CHK_THD_RT                       ((0x2f56))
+/* Bit 31:27, reserved */
+/* Bit 26:16, reg_mcdi_pd22chkfltcntrt.
+ratio for flat count of field pulldown 22 check, normalized 2048 as '1',
+2047 is set to 2048, default = 1 */
+/* Bit 15: 8, reg_mcdi_pd22chkcntrt.  ratio of pulldown 22 check count,
+normalized 256 as '1', 255 is set to 256, default = 100 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_pd22chkcntthd.
+thd (>=) for pd22 count before locked, 1~31, default = 4 */
+#define MCDI_CHAR_DET_DIF_THD                      ((0x2f57))
+/* Bit 31:24, reserved */
+/* Bit 23:16, reg_mcdi_chardetminmaxdifthd.
+thd (>=) for dif between min and max value, default = 64 */
+/* Bit 15: 8, reg_mcdi_chardetmaxdifthd.
+thd (<) for dif between max value, default = 17 */
+/* Bit  7: 0, reg_mcdi_chardetmindifthd.
+thd (<) for dif between min value, default = 17 */
+#define MCDI_CHAR_DET_CNT_THD                      ((0x2f58))
+/* Bit 31:21, reserved */
+/* Bit 20:16, reg_mcdi_chardettotcntthd.
+thd (>=) for total count, 0~21, default = 18 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_chardetmaxcntthd.
+thd (>=) for max count, 0~21, default = 1 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_chardetmincntthd.
+thd (>=) for min count, 0~21, default = 1 */
+#define MCDI_FIELD_MV                              ((0x2f60))
+/* Bit 31:24, reg_mcdi_pd22chkcnt */
+/* Bit 23:16, reg_mcdi_fieldgmvcnt */
+/* Bit    15, reg_mcdi_pd22chkflg */
+/* Bit    14, reg_mcdi_fieldgmvlock */
+/* Bit 13: 8, reg_mcdi_fieldrptmv.	           last field rpt mv */
+/* Bit  7: 6, reserved */
+/* Bit  5: 0, reg_mcdi_fieldgmv.                    last field gmv */
+#define MCDI_FIELD_HVF_PRDX_CNT                    ((0x2f61))
+/* Bit 31:24, reg_mcdi_motionparadoxcnt. */
+/* Bit 23:17, reserved */
+/* Bit    16, reg_mcdi_motionparadoxflg. */
+/* Bit 15: 8, reg_mcdi_highvertfrqcnt. */
+/* Bit  7: 4, reserved */
+/* Bit  3: 2, reg_mcdi_highvertfrqphase. */
+/* Bit     1, reserved */
+/* Bit     0, reg_mcdi_highvertfrqflg. */
+#define MCDI_FIELD_LUMA_AVG_SUM_0                  ((0x2f62))
+/* Bit 31: 0, reg_mcdi_fld_luma_avg_sum0. */
+#define MCDI_FIELD_LUMA_AVG_SUM_1                  ((0x2f63))
+/* Bit 31: 0, reg_mcdi_fld_luma_avg_sum1. */
+#define MCDI_YCBCR_BLEND_CRTL                      ((0x2f64))
+/* Bit 31:16, reserved */
+/* Bit 15: 8, reg_mcdi_ycbcrblendgain.
+ycbcr blending gain for cbcr in ycbcr. default = 0 */
+/* Bit  7: 2, reserved. */
+/* Bit  1: 0, reg_mcdi_ycbcrblendmode.
+0:y+cmb(cb,cr), 1:med(r,g,b), 2:max(r,g,b), default = 2 */
+#define MCDI_MCVECWR_CANVAS_SIZE                   ((0x2f65))
+#define MCDI_MCVECRD_CANVAS_SIZE                   ((0x2f66))
+#define MCDI_MCINFOWR_CANVAS_SIZE                  ((0x2f67))
+#define MCDI_MCINFORD_CANVAS_SIZE                  ((0x2f68))
+#define MCDI_MCVECWR_X                             ((0x2f92))
+#define MCDI_MCVECWR_Y                             ((0x2f93))
+#define MCDI_MCVECWR_CTRL                          ((0x2f94))
+#define MCDI_MCVECRD_X                             ((0x2f95))
+#define MCDI_MCVECRD_Y                             ((0x2f96))
+#define MCDI_MCVECRD_CTRL                          ((0x2f97))
+#define MCDI_MCINFOWR_X                            ((0x2f98))
+#define MCDI_MCINFOWR_Y                            ((0x2f99))
+#define MCDI_MCINFOWR_CTRL                         ((0x2f9a))
+#define MCDI_MCINFORD_X                            ((0x2f9b))
+#define MCDI_MCINFORD_Y                            ((0x2f9c))
+#define MCDI_MCINFORD_CTRL                         ((0x2f9d))
+/* === MC registers ============================================ */
+#define MCDI_MC_CRTL                               ((0x2f70))
+/* Bit 31: 9, reserved */
+/* Bit     8, reg_mcdi_mcpreflg.
+flag to use previous field for MC, 0:forward field,
+1: previous field, default = 1 */
+/* Bit     7, reg_mcdi_mcrelrefbycolcfden.
+enable rel refinement by column cofidence in mc blending, default = 1 */
+/* Bit  6: 5, reg_mcdi_mclpfen.
+enable mc pixles/rel lpf, 0:disable, 1: lpf rel,
+2: lpf mc pxls, 3: lpf both rel and mc pxls, default = 0 */
+/* Bit  4: 2, reg_mcdi_mcdebugmode.
+enable mc debug mode, 0:disable, 1: split left/right,
+2: split top/bottom, 3: debug mv, 4: debug rel, default = 0 */
+/* Bit  1: 0, reg_mcdi_mcen.
+mcdi enable mode, 0:disable, 1: blend with ma, 2: full mc, default = 1 */
+#define MCDI_MC_LPF_MSK_0                          ((0x2f71))
+/* Bit 31:21, reserved */
+/* Bit 20:16, reg_mcdi_mclpfmsk02.
+mc lpf coef. 2 for pixel 0 of current block,normalized 16 as '1', default = 0 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_mclpfmsk01.
+mc lpf coef. 1 for pixel 0 of current block,normalized 16 as '1', default = 9 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_mclpfmsk00.
+mc lpf coef. 0 for pixel 0 of current block,normalized 16 as '1', default = 7 */
+#define MCDI_MC_LPF_MSK_1                          ((0x2f72))
+/* Bit 31:21, reserved */
+/* Bit 20:16, reg_mcdi_mclpfmsk12.
+mc lpf coef. 2 for pixel 1 of current block,
+0~16, normalized 16 as '1', default = 0 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_mclpfmsk11.
+mc lpf coef. 1 for pixel 1 of current block, 0~16,
+normalized 16 as '1', default = 11 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_mclpfmsk10.
+mc lpf coef. 0 for pixel 1 of current block, 0~16,
+normalized 16 as '1', default = 5 */
+#define MCDI_MC_LPF_MSK_2                          ((0x2f73))
+/* Bit 31:21, reserved */
+/* Bit 20:16, reg_mcdi_mclpfmsk22.
+mc lpf coef. 2 for pixel 2 of current block, 0~16,
+normalized 16 as '1', default = 1 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_mclpfmsk21.
+mc lpf coef. 1 for pixel 2 of current block, 0~16,
+normalized 16 as '1', default = 14 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_mclpfmsk20.
+mc lpf coef. 0 for pixel 2 of current block, 0~16,
+normalized 16 as '1', default = 1 */
+#define MCDI_MC_LPF_MSK_3                          ((0x2f74))
+/* Bit 31:21, reserved */
+/* Bit 20:16, reg_mcdi_mclpfmsk32.
+mc lpf coef. 2 for pixel 3 of current block, 0~16,
+normalized 16 as '1', default = 5 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_mclpfmsk31.
+mc lpf coef. 1 for pixel 3 of current block, 0~16,
+normalized 16 as '1', default = 11 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_mclpfmsk30.
+mc lpf coef. 0 for pixel 3 of current block, 0~16,
+normalized 16 as '1', default = 0 */
+#define MCDI_MC_LPF_MSK_4                          ((0x2f75))
+/* Bit 31:21, reserved */
+/* Bit 20:16, reg_mcdi_mclpfmsk42.
+mc lpf coef. 2 for pixel 4 of current block, 0~16,
+normalized 16 as '1', default = 7 */
+/* Bit 15:13, reserved */
+/* Bit 12: 8, reg_mcdi_mclpfmsk41.
+mc lpf coef. 1 for pixel 4 of current block, 0~16,
+normalized 16 as '1', default = 9 */
+/* Bit  7: 5, reserved */
+/* Bit  4: 0, reg_mcdi_mclpfmsk40.
+mc lpf coef. 0 for pixel 4 of current block, 0~16,
+normalized 16 as '1', default = 0 */
+#define MCDI_MC_REL_GAIN_OFFST_0                   ((0x2f76))
+/* Bit 31:26, reserved */
+/* Bit    25, reg_mcdi_mcmotionparadoxflg.
+flag of motion paradox, initial with 0 and read from software, default = 0 */
+/* Bit    24, reg_mcdi_mchighvertfrqflg.
+flag of high vert frq, initial with 0 and read from software, default = 0 */
+/* Bit 23:16, reg_mcdi_mcmotionparadoxoffst.
+offset (rel + offset) for rel (MC blending coef.) refinement if motion paradox
+detected before MC blending before MC blending, default = 128 */
+/* Bit 15:12, reserved */
+/* Bit 11: 8, reg_mcdi_mcmotionparadoxgain.
+gain for rel (MC blending coef.) refinement if motion paradox detected before MC
+blending, normalized 8 as '1', set 15 to 16, default = 8 */
+/* Bit  7: 4, reg_mcdi_mchighvertfrqoffst.          minus offset
+(alpha - offset) for motion (MA blending coef.) refinement if high vertical
+frequency detected before MA blending, default = 15 */
+/* Bit  3: 0, reg_mcdi_mchighvertfrqgain.
+gain for motion (MA blending coef.) refinement if high vertical frequency
+detected before MA blending, normalized 8 as '1', set 15 to 16, default = 8 */
+#define MCDI_MC_REL_GAIN_OFFST_1                   ((0x2f77))
+/* Bit 31:24, reg_mcdi_mcoutofboundrayoffst.
+offset (rel + offset) for rel (MC blending coef.) refinement if MC pointed out
+of boundray before MC blending before MC blending, default = 255 */
+/* Bit 23:20, reserved */
+/* Bit 19:16, reg_mcdi_mcoutofboundraygain.
+gain for rel (MC blending coef.) refinement if MC pointed out of boundray before
+MC blending, normalized 8 as '1', set 15 to 16, default = 8 */
+/* Bit 15: 8, reg_mcdi_mcrelrefbycolcfdoffst.
+offset (rel + offset) for rel (MC blending coef.) refinement if motion paradox
+detected before MC blending before MC blending, default = 255 */
+/* Bit  7: 4, reserved. */
+/* Bit  3: 0, reg_mcdi_mcrelrefbycolcfdgain.
+gain for rel (MC blending coef.) refinement if column cofidence failed before MC
+blending, normalized 8 as '1', set 15 to 16, default = 8 */
+#define MCDI_MC_COL_CFD_0                          ((0x2f78))
+/* Bit 31: 0, mcdi_mc_col_cfd_0.
+column cofidence value 0 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_1                          ((0x2f79))
+/* Bit 31: 0, mcdi_mc_col_cfd_1.
+column cofidence value 1 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_2                          ((0x2f7a))
+/* Bit 31: 0, mcdi_mc_col_cfd_2.
+column cofidence value 2 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_3                          ((0x2f7b))
+/* Bit 31: 0, mcdi_mc_col_cfd_3.
+column cofidence value 3 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_4                          ((0x2f7c))
+/* Bit 31: 0, mcdi_mc_col_cfd_4.
+column cofidence value 4 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_5                          ((0x2f7d))
+/* Bit 31: 0, mcdi_mc_col_cfd_5.
+column cofidence value 5 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_6                          ((0x2f7e))
+/* Bit 31: 0, mcdi_mc_col_cfd_6.
+column cofidence value 6 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_7                          ((0x2f7f))
+/* Bit 31: 0, mcdi_mc_col_cfd_7.
+column cofidence value 7 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_8                          ((0x2f80))
+/* Bit 31: 0, mcdi_mc_col_cfd_8.
+column cofidence value 8 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_9                          ((0x2f81))
+/* Bit 31: 0, mcdi_mc_col_cfd_9.
+column cofidence value 9 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_10                         ((0x2f82))
+/* Bit 31: 0, mcdi_mc_col_cfd_10.
+column cofidence value 10 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_11                         ((0x2f83))
+/* Bit 31: 0, mcdi_mc_col_cfd_11.
+column cofidence value 11 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_12                         ((0x2f84))
+/* Bit 31: 0, mcdi_mc_col_cfd_12.
+column cofidence value 12 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_13                         ((0x2f85))
+/* Bit 31: 0, mcdi_mc_col_cfd_13.
+column cofidence value 13 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_14                         ((0x2f86))
+/* Bit 31: 0, mcdi_mc_col_cfd_14.
+column cofidence value 14 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_15                         ((0x2f87))
+/* Bit 31: 0, mcdi_mc_col_cfd_15.
+column cofidence value 15 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_16                         ((0x2f88))
+/* Bit 31: 0, mcdi_mc_col_cfd_16.
+column cofidence value 16 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_17                         ((0x2f89))
+/* Bit 31: 0, mcdi_mc_col_cfd_17.
+column cofidence value 17 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_18                         ((0x2f8a))
+/* Bit 31: 0, mcdi_mc_col_cfd_18.
+column cofidence value 18 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_19                         ((0x2f8b))
+/* Bit 31: 0, mcdi_mc_col_cfd_19.
+column cofidence value 19 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_20                         ((0x2f8c))
+/* Bit 31: 0, mcdi_mc_col_cfd_20.
+column cofidence value 20 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_21                         ((0x2f8d))
+/* Bit 31: 0, mcdi_mc_col_cfd_21.
+column cofidence value 21 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_22                         ((0x2f8e))
+/* Bit 31: 0, mcdi_mc_col_cfd_22.
+column cofidence value 22 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_23                         ((0x2f8f))
+/* Bit 31: 0, mcdi_mc_col_cfd_23.
+column cofidence value 23 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_24                         ((0x2f90))
+/* Bit 31: 0, mcdi_mc_col_cfd_24.
+column cofidence value 24 read from software. initial = 0 */
+#define MCDI_MC_COL_CFD_25                         ((0x2f91))
+/* Bit 31: 0, mcdi_mc_col_cfd_25.
+column cofidence value 25 read from software. initial = 0 */
+/* ======= PRE RO Registers ==================================== */
+#define MCDI_RO_FLD_LUMA_AVG_SUM                   ((0x2fa0))
+/* Bit 31: 0, ro_mcdi_fldlumaavgsum.
+block's luma avg sum of current filed (block based). initial = 0 */
+#define MCDI_RO_GMV_VLD_CNT                        ((0x2fa1))
+/* Bit 31: 0, ro_mcdi_gmvvldcnt.
+valid gmv's count of pre one filed (block based). initial = 0 */
+#define MCDI_RO_RPT_FLG_CNT                        ((0x2fa2))
+/* Bit 31: 0, ro_mcdi_rptflgcnt.
+repeat mv's count of pre one filed (block based). initial = 0 */
+#define MCDI_RO_FLD_BAD_SAD_CNT                    ((0x2fa3))
+/* Bit 31: 0, ro_mcdi_fldbadsadcnt.
+bad sad count of whole pre one field (block based). initial = 0 */
+#define MCDI_RO_FLD_BAD_BADW_CNT                   ((0x2fa4))
+/* Bit 31: 0, ro_mcdi_fldbadbadwcnt.
+bad badw count of whole pre one field (block based). initial = 0 */
+#define MCDI_RO_FLD_BAD_REL_CNT                    ((0x2fa5))
+/* Bit 31: 0, ro_mcdi_fldbadrelcnt.
+bad rel count of whole pre one field (block based). initial = 0 */
+#define MCDI_RO_FLD_MTN_CNT                        ((0x2fa6))
+/* Bit 31: 0, ro_mcdi_fldmtncnt.
+motion count of whole pre one field (pixel based). initial = 0 */
+#define MCDI_RO_FLD_VLD_CNT                        ((0x2fa7))
+/* Bit 31: 0, ro_mcdi_fldvldcnt.
+valid motion count of whole pre one field (pixel based). initial = 0 */
+#define MCDI_RO_FLD_PD_22_PRE_CNT                  ((0x2fa8))
+/* Bit 31: 0, ro_mcdi_fldpd22precnt.
+prevoius pd22 check count of whole pre one field (block based). initial = 0 */
+#define MCDI_RO_FLD_PD_22_FOR_CNT                  ((0x2fa9))
+/* Bit 31: 0, ro_mcdi_fldpd22forcnt.
+forward pd22 check count of whole pre one field (block based). initial = 0 */
+#define MCDI_RO_FLD_PD_22_FLT_CNT                  ((0x2faa))
+/* Bit 31: 0, ro_mcdi_fldpd22fltcnt.
+flat count (for pd22 check) of whole pre one field (block based). initial = 0 */
+#define MCDI_RO_HIGH_VERT_FRQ_FLG                  ((0x2fab))
+/* Bit 31:16, reserved. */
+/* Bit 15: 8, ro_mcdi_highvertfrqcnt.
+high vertical frequency count till prevoius one field. initial = 0 */
+/* Bit  7: 3, reserved. */
+/* Bit  2: 1, ro_mcdi_highvertfrqphase.
+high vertical frequency phase of prevoius one field. initial = 2 */
+/* Bit     0, ro_mcdi_highvertfrqflg.
+high vertical frequency flag of prevoius one field. initial = 0 */
+#define MCDI_RO_GMV_LOCK_FLG                       ((0x2fac))
+/* Bit 31:16, reserved. */
+/* Bit 15: 8, ro_mcdi_gmvlckcnt.
+global mv lock count till prevoius one field. initial = 0 */
+/* Bit  7: 2, ro_mcdi_gmv.
+global mv of prevoius one field. -31~31, initial = 32 (invalid value) */
+/* Bit     1, ro_mcdi_zerogmvlckflg.
+zero global mv lock flag of prevoius one field. initial = 0 */
+/* Bit     0, ro_mcdi_gmvlckflg.
+global mv lock flag of prevoius one field. initial = 0 */
+#define MCDI_RO_RPT_MV                             ((0x2fad))
+/* Bit 5: 0, ro_mcdi_rptmv.
+repeate mv of prevoius one field. -31~31, initial = 32 (invalid value) */
+#define MCDI_RO_MOTION_PARADOX_FLG                 ((0x2fae))
+/* Bit 31:16, reserved. */
+/* Bit 15: 8, ro_mcdi_motionparadoxcnt.
+motion paradox count till prevoius one field. initial = 0 */
+/* Bit  7: 1, reserved. */
+/* Bit     0, ro_mcdi_motionparadoxflg.
+motion paradox flag of prevoius one field. initial = 0 */
+#define MCDI_RO_PD_22_FLG                          ((0x2faf))
+/* Bit 31:16, reserved. */
+/* Bit 15: 8, ro_mcdi_pd22cnt.
+pull down 22 count till prevoius one field. initial = 0 */
+/* Bit  7: 1, reserved. */
+/* Bit     0, ro_mcdi_pd22flg.
+pull down 22 flag of prevoius one field. initial = 0 */
+#define MCDI_RO_COL_CFD_0                          ((0x2fb0))
+/* Bit 31: 0, ro_mcdi_col_cfd_0.
+column cofidence value 0. initial = 0 */
+#define MCDI_RO_COL_CFD_1                          ((0x2fb1))
+/* Bit 31: 0, ro_mcdi_col_cfd_1.
+column cofidence value 1. initial = 0 */
+#define MCDI_RO_COL_CFD_2                          ((0x2fb2))
+/* Bit 31: 0, ro_mcdi_col_cfd_2.
+column cofidence value 2. initial = 0 */
+#define MCDI_RO_COL_CFD_3                          ((0x2fb3))
+/* Bit 31: 0, ro_mcdi_col_cfd_3.
+column cofidence value 3. initial = 0 */
+#define MCDI_RO_COL_CFD_4                          ((0x2fb4))
+/* Bit 31: 0, ro_mcdi_col_cfd_4.
+column cofidence value 4. initial = 0 */
+#define MCDI_RO_COL_CFD_5                          ((0x2fb5))
+/* Bit 31: 0, ro_mcdi_col_cfd_5.
+column cofidence value 5. initial = 0 */
+#define MCDI_RO_COL_CFD_6                          ((0x2fb6))
+/* Bit 31: 0, ro_mcdi_col_cfd_6.      column cofidence value 6. initial = 0 */
+#define MCDI_RO_COL_CFD_7                          ((0x2fb7))
+/* Bit 31: 0, ro_mcdi_col_cfd_7.      column cofidence value 7. initial = 0 */
+#define MCDI_RO_COL_CFD_8                          ((0x2fb8))
+/* Bit 31: 0, ro_mcdi_col_cfd_8.      column cofidence value 8. initial = 0 */
+#define MCDI_RO_COL_CFD_9                          ((0x2fb9))
+/* Bit 31: 0, ro_mcdi_col_cfd_9.      column cofidence value 9. initial = 0 */
+#define MCDI_RO_COL_CFD_10                         ((0x2fba))
+/* Bit 31: 0, ro_mcdi_col_cfd_10.     column cofidence value 10. initial = 0 */
+#define MCDI_RO_COL_CFD_11                         ((0x2fbb))
+/* Bit 31: 0, ro_mcdi_col_cfd_11.     column cofidence value 11. initial = 0 */
+#define MCDI_RO_COL_CFD_12                         ((0x2fbc))
+/* Bit 31: 0, ro_mcdi_col_cfd_12.     column cofidence value 12. initial = 0 */
+#define MCDI_RO_COL_CFD_13                         ((0x2fbd))
+/* Bit 31: 0, ro_mcdi_col_cfd_13.     column cofidence value 13. initial = 0 */
+#define MCDI_RO_COL_CFD_14                         ((0x2fbe))
+/* Bit 31: 0, ro_mcdi_col_cfd_14.     column cofidence value 14. initial = 0 */
+#define MCDI_RO_COL_CFD_15                         ((0x2fbf))
+/* Bit 31: 0, ro_mcdi_col_cfd_15.     column cofidence value 15. initial = 0 */
+#define MCDI_RO_COL_CFD_16                         ((0x2fc0))
+/* Bit 31: 0, ro_mcdi_col_cfd_16.     column cofidence value 16. initial = 0 */
+#define MCDI_RO_COL_CFD_17                         ((0x2fc1))
+/* Bit 31: 0, ro_mcdi_col_cfd_17.     column cofidence value 17. initial = 0 */
+#define MCDI_RO_COL_CFD_18                         ((0x2fc2))
+/* Bit 31: 0, ro_mcdi_col_cfd_18.     column cofidence value 18. initial = 0 */
+#define MCDI_RO_COL_CFD_19                         ((0x2fc3))
+/* Bit 31: 0, ro_mcdi_col_cfd_19.     column cofidence value 19. initial = 0 */
+#define MCDI_RO_COL_CFD_20                         ((0x2fc4))
+/* Bit 31: 0, ro_mcdi_col_cfd_20.     column cofidence value 20. initial = 0 */
+#define MCDI_RO_COL_CFD_21                         ((0x2fc5))
+/* Bit 31: 0, ro_mcdi_col_cfd_21.     column cofidence value 21. initial = 0 */
+#define MCDI_RO_COL_CFD_22                         ((0x2fc6))
+/* Bit 31: 0, ro_mcdi_col_cfd_22.     column cofidence value 22. initial = 0 */
+#define MCDI_RO_COL_CFD_23                         ((0x2fc7))
+/* Bit 31: 0, ro_mcdi_col_cfd_23.     column cofidence value 23. initial = 0 */
+#define MCDI_RO_COL_CFD_24                         ((0x2fc8))
+/* Bit 31: 0, ro_mcdi_col_cfd_24.     column cofidence value 24. initial = 0 */
+#define MCDI_RO_COL_CFD_25                         ((0x2fc9))
+/* Bit 31: 0, ro_mcdi_col_cfd_25.     column cofidence value 25. initial = 0 */
+
+
 #define DIPD_COMB_CTRL0					0x2fd0
+/* Bit 31: 24, cmb_v_dif_min */
+/* Bit 23: 16, cmb_v_dif_max */
+/* Bit 15:  8, cmb_crg_mi */
+/* Bit  7:  0, cmb_crg_max */
 #define DIPD_COMB_CTRL1					0x2fd1
+/* Bit 31: 31, pd_check_en */
+/* Bit 29: 24, cmb_wv_min3 */
+/* Bit 21: 16, cmb_wv_min2 */
+/* Bit 13:  8, cmb_wv_min1 */
+/* Bit  5:  0, cmb_wv_min0 */
 #define DIPD_COMB_CTRL2					0x2fd2
+/* Bit 31: 28, cmb_wnd_cnt1 */
+/* Bit 25: 20, ccnt_cmmin1 */
+/* Bit 19: 16, ccnt_mtmin */
+/* Bit 13:  8, ccnt_cmmin */
+/* Bit  5:  0, cmb_wv_min4 */
 #define DIPD_COMB_CTRL3					0x2fd3
+/* Bit 31: 31, cmb32spcl */
+/* Bit 17: 12, cmb_wnd_mthd */
+/* Bit 11:  4, cmb_abs_nocmb */
+/* Bit  3:  0, cnt_minlen */
 #define DIPD_COMB_CTRL4					0x2fd4
+/* Bit 30: 30, flm_stamtn_en */
+/* Bit 29: 28, in_horflt */
+/* Bit 27: 20, alpha */
+/* Bit 19: 16, thtran_ctmtd */
+/* Bit 15:  8, htran_mnth1 */
+/* Bit  7:  0, htran_mnth0 */
 #define DIPD_COMB_CTRL5					0x2fd5
+/* Bit 31: 24, fld_mindif */
+/* Bit 23: 16, frm_mindif */
+/* Bit 13:  8, flm_smp_mtn_cnt */
+/* Bit  7:  0, flm_smp_mtn_thd */
 #define DIPD_RO_COMB_0					0x2fd6
 #define DIPD_RO_COMB_1					0x2fd7
 #define DIPD_RO_COMB_2					0x2fd8
@@ -960,7 +3714,7 @@ unsigned int RDMA_RD_BITS(unsigned int adr, unsigned int start,
 #define DIPD_RO_COMB_19					0x2fe9
 #define DIPD_RO_COMB_20					0x2fea
 /* nr3 */
-#define NR3_MODE						0x2ff0
+#define NR3_MODE					0x2ff0
 		/* d010bfc0 */
 #define NR3_COOP_PARA					0x2ff1
 #define NR3_CNOOP_GAIN					0x2ff2
diff --git a/drivers/amlogic/deinterlace/tffbff_check.c b/drivers/amlogic/deinterlace/tffbff_check.c
new file mode 100644
index 0000000..7ee96df
--- /dev/null
+++ b/drivers/amlogic/deinterlace/tffbff_check.c
@@ -0,0 +1,210 @@
+#include <linux/module.h>
+#include <linux/types.h>
+#include "deinterlace.h"
+#include "register.h"
+
+/* define the lenght of history */
+#define TBFF_DLEN 20
+
+/* parameters */
+/* valid data: only pixel_num > size*rat >> 8 */
+/* u8: [0,255] */
+static int tbff_pixel_minnum = 16;
+
+/* x3 / row > rat */
+/* => x3 > (row * rat >> 5) */
+/* u10: [0 ~ 1023] => [0, 16] */
+static int tbff_x3_minrow = 64;
+
+/* m1/p1/m2/p2 changing 0/1/0/1... as 2-2 mode */
+/* (max)/ min > (rat): define it max, else min */
+/* u8: [0,31] */
+static int tbff_mp_lgrat[4] = {16, 16, 16, 16};
+
+/* tbff check length */
+/* [0, 31] */
+static int tbff_chk_len[4] = {4, 4, 4, 4};
+
+static int calc_tbff_pixel_minnum = 16;
+static int calc_tbff_x3_minrow = 64;
+static int calc_tbff_mp_lgrat[4] = {16, 16, 16, 16};
+
+static int nTmp0;
+static bool tbff_pr, tffbff_en = true;
+static int mode_count;
+
+void tbff_init(void)
+{
+	int i = 0;
+	mode_count = 0;
+	calc_tbff_pixel_minnum = tbff_pixel_minnum;
+	calc_tbff_x3_minrow = tbff_x3_minrow;
+	for (i = 0; i < 4; i++)
+		calc_tbff_mp_lgrat[i] = tbff_mp_lgrat[i];
+}
+static int tbff_get_rate(int t0, int t1)
+{
+	int nmax = t1;
+	int nmin = t0;
+	int nrst = 0;
+
+	if (t0 > t1) {
+		nmax = t0;
+		nmin = t1;
+	}
+
+	nrst = (8 * nmax) + (nmin >> 1);
+	nrst /= (nmin+1);
+	if (nrst > 31)
+		nrst = 31;
+
+	if (nmax == t1) /* current is small */
+		nrst = 0;
+
+	return nrst;
+}
+
+static int tbff_get_minrate(int *pLen)
+{
+	int iT0 = 0;
+	int aTLn[4] = {0, 0, 0, 0};
+	int nrst = 255;
+
+	int nP0 = pLen[TBFF_DLEN - 1];
+	int nP1 = pLen[TBFF_DLEN - 2];
+
+	if (nP0 < nP1) {
+		for (iT0 = 0; iT0 < 4; (iT0 += 2)) {
+			aTLn[iT0] = 31 - pLen[TBFF_DLEN - iT0 - 1];
+			aTLn[iT0 + 1] = pLen[TBFF_DLEN - iT0 - 2];
+		}
+	} else {
+		for (iT0 = 0; iT0 < 4; (iT0 += 2)) {
+			aTLn[iT0] = pLen[TBFF_DLEN - iT0 - 1];
+			aTLn[iT0 + 1] = 31 - pLen[TBFF_DLEN - iT0 - 2];
+		}
+	}
+
+	for (iT0 = 0; iT0 < 4; iT0++) {
+		if (aTLn[iT0] < nrst)
+			nrst = aTLn[iT0];
+	}
+
+	return nrst;
+}
+
+/* update param according to detection count */
+static void calc_tbff_param(int mode_cnt, int step_max)
+{
+	int delt_num, delt_row, delt_lgrat, i;
+
+	delt_num = tbff_pixel_minnum - 4;
+	delt_row = tbff_x3_minrow;
+	delt_lgrat = tbff_mp_lgrat[0] - 6;
+
+	calc_tbff_pixel_minnum =
+		tbff_pixel_minnum - (delt_num * mode_cnt)/step_max;
+	calc_tbff_x3_minrow = tbff_x3_minrow - (delt_row * mode_cnt)/step_max;
+	calc_tbff_mp_lgrat[0] =
+		tbff_mp_lgrat[0] - (delt_lgrat * mode_cnt)/step_max;
+
+	for (i = 1; i < 4; i++)
+		calc_tbff_mp_lgrat[i] = calc_tbff_mp_lgrat[0];
+}
+/* TFF / BFF error check */
+/* polar3[0]: num of pixels */
+/* polar3[1]: smooth motion vector */
+/* polar3[2]: m1 */
+/* polar3[3]: p1 */
+/* polar3[4]: m2 */
+/* polar3[5]: p2 */
+/* polar3[6]: x3 */
+
+int tff_bff_check(int nROW, int nCOL)
+{
+	int iT0 = 0, iT1 = 0, nTmp1 = 0;
+	int nTmp2 = 0, tbfalse = 0, nSIZE = nROW * nCOL;
+    /* int nMin0 = 0; */
+	unsigned int uTp0 = 0;
+
+	int polar3[7];
+     /* top/bot field first error */
+	static int pPolar3[7]; /* previous polar3 */
+	static int sDat[4][TBFF_DLEN]; /* history infor */
+	static unsigned int stc_pp3[4];
+	for (iT0 = 0; iT0 < 7; iT0++)
+		polar3[iT0] = Rd_reg_bits(NR2_RO_POLAR3_NUMOFPIX+iT0, 0, 24);
+
+	if (tbff_pr)
+		pr_info("polar3=%8d %8d %8d %8d %8d %8d %8d.\n",
+				polar3[0], polar3[1], polar3[2], polar3[3],
+				polar3[4], polar3[5], polar3[6]);
+	/* history */
+	for (iT0 = 0; iT0 < 4; iT0++) {
+		for (iT1 = 0; iT1 < (TBFF_DLEN - 1); iT1++)
+			sDat[iT0][iT1] = sDat[iT0][iT1 + 1];
+
+		stc_pp3[iT0] = (stc_pp3[iT0] << 1);
+		sDat[iT0][TBFF_DLEN - 1] = 0;
+	}
+
+	/* only valid pixel is enough */
+	nTmp0 = ((nSIZE * calc_tbff_pixel_minnum + 128) >> 8);
+	if (polar3[0] > nTmp0) {
+		/* only x3 pixel is enough */
+		nTmp1 = ((nROW * calc_tbff_x3_minrow + 16) >> 5);
+		if (polar3[6] > nTmp1) {
+			/* nMin0 = 255; */
+			for (iT1 = 0; iT1 < 4; iT1++) {
+				nTmp2 =
+			tbff_get_rate(polar3[iT1 + 2], pPolar3[iT1 + 2]);
+				sDat[iT1][TBFF_DLEN - 1] = nTmp2;
+			}
+		}
+	}
+
+	for (iT1 = 0; iT1 < 4; iT1++) {
+		nTmp2 = tbff_get_minrate(sDat[iT1]);
+		if (nTmp2 >= calc_tbff_mp_lgrat[iT1])
+			stc_pp3[iT1] |= 0x1;
+	}
+
+	for (iT1 = 0; iT1 < 4; iT1++) {
+		uTp0 = stc_pp3[iT1];
+		nTmp0 = 0;
+		for (iT0 = 0; iT0 < 31; iT0++) {
+			if (uTp0 & 0x1)
+				nTmp0++;
+			else
+				break;
+			uTp0 = (uTp0 >> 1);
+		}
+
+		if (nTmp0 >= tbff_chk_len[iT1])
+			tbfalse += 1;
+	}
+
+	/* m1/p1/m2/p2 all 2-2 mode */
+	/* return (tbfalse==4); */
+	nTmp0 = (tbfalse == 4);
+
+	if (nTmp0 == 1)
+		nTmp0 += (polar3[2] < pPolar3[2]);
+	if (nTmp0 != 0)
+		mode_count = mode_count > 32 ? 32 : (mode_count+1);
+	else
+		mode_count = mode_count > 0 ? (mode_count-1) : 0;
+	calc_tbff_param(mode_count, 32);
+	for (iT0 = 0; iT0 < 7; iT0++)
+		pPolar3[iT0] = polar3[iT0];
+	if (tbff_pr)
+		pr_info("num %d, x3 %d, lgrat %d, result is %d.\n",
+			calc_tbff_pixel_minnum, calc_tbff_x3_minrow,
+			calc_tbff_mp_lgrat[0], nTmp0);
+
+	return tffbff_en?nTmp0:0;
+}
+module_param_named(tffbff_en, tffbff_en, bool, 0664);
+module_param_named(tbff_pixel_minnum, tbff_pixel_minnum, int, 0664);
+module_param_named(tbff_x3_minrow, tbff_x3_minrow, int, 0664);
+module_param_named(tbff_pr, tbff_pr, bool, 0664);
diff --git a/drivers/amlogic/deinterlace/vof_soft_top.c b/drivers/amlogic/deinterlace/vof_soft_top.c
new file mode 100644
index 0000000..6a1b65c
--- /dev/null
+++ b/drivers/amlogic/deinterlace/vof_soft_top.c
@@ -0,0 +1,640 @@
+/* Designer: Xin.Hu@amlogic.com */
+/* Date: 15/11/25 */
+#include <linux/kernel.h>
+#include <linux/module.h>
+
+#include "film_vof_soft.h"
+
+int cmb32_blw_wnd = 180; /*192 */
+module_param(cmb32_blw_wnd, int, 0644);
+MODULE_PARM_DESC(cmb32_blw_wnd, "cmb32_blw_wnd");
+
+int cmb32_wnd_ext = 4;
+module_param(cmb32_wnd_ext, int, 0644);
+MODULE_PARM_DESC(cmb32_wnd_ext, "cmb32_wnd_ext");
+
+int cmb32_wnd_tol = 4;
+module_param(cmb32_wnd_tol, int, 0644);
+MODULE_PARM_DESC(cmb32_wnd_tol, "cmb32_wnd_tol");
+
+int cmb32_frm_nocmb = 40;
+module_param(cmb32_frm_nocmb, int, 0644);
+MODULE_PARM_DESC(cmb32_frm_nocmb, "cmb32_frm_nocmb");
+
+int cmb32_min02_sft = 7;
+module_param(cmb32_min02_sft, int, 0644);
+MODULE_PARM_DESC(cmb32_min02_sft, "cmb32_min02_sft");
+
+int cmb32_cmb_tol = 10;
+module_param(cmb32_cmb_tol, int, 0644);
+MODULE_PARM_DESC(cmb32_cmb_tol, "cmb32_cmb_tol");
+
+int cmb32_avg_dff = 48; /* if avg dif32 > dff>>4 */
+module_param(cmb32_avg_dff, int, 0644);
+MODULE_PARM_DESC(cmb32_avg_dff, "cmb32_avg_dff");
+
+int cmb32_smfrm_num = 4;
+module_param(cmb32_smfrm_num, int, 0644);
+MODULE_PARM_DESC(cmb32_smfrm_num, "cmb32_smfrm_num");
+
+int cmb32_nocmb_num = 20;
+module_param(cmb32_nocmb_num, int, 0644);
+MODULE_PARM_DESC(cmb32_nocmb_num, "cmb32_nocmb_num");
+
+int cmb22_gcmb_rnum = 8;
+module_param(cmb22_gcmb_rnum, int, 0644);
+MODULE_PARM_DESC(cmb22_gcmb_rnum, "cmb22_gcmb_rnum");
+
+int flmxx_cal_lcmb = 1;
+module_param(flmxx_cal_lcmb, int, 0644);
+MODULE_PARM_DESC(flmxx_cal_lcmb, "flmxx_cal_lcmb");
+
+/* 15: 8-7 */
+/* 12: 3-2-3-2-2 */
+/* 10: 6-4 */
+/* 10: 5-5 */
+/* 10: 2-2-2-4 */
+/* 10: 2-3-3-2 */
+/* 10: 3-2-3-2 */
+/* row * flmxx_no_cmb >> 6 */
+static unsigned int flmxx_no_cmb[7] = {8, 32, 8, 8, 8, 32, 32};
+static unsigned int flmxx_nn_cmb = 7;
+module_param_array(flmxx_no_cmb, uint, &flmxx_nn_cmb, 0664);
+
+int VOFSftTop(UINT8 *rFlmPstGCm, UINT8 *rFlmSltPre, UINT8 *rFlmPstMod,
+		UShort *rPstCYWnd0, UShort *rPstCYWnd1,
+		UShort *rPstCYWnd2, UShort *rPstCYWnd3, int nMod,
+		UINT32 *rROCmbInf, struct sFlmDatSt *pRDat,
+		struct sFlmSftPar *pPar, int nROW, int nCOL)
+{
+	/* HSCMB[hist10][9(32bit)] */
+	static UINT32 HSCMB[HISCMBNUM][ROWCMBLEN];
+	/* 6-history,10-5Wnd(bgn/end) */
+	static int CWND[HISDETNUM][2 * VOFWNDNUM];
+	static UINT8 BGN;
+	static UINT8 frmNoCmb; /* counter from No combing */
+	static UINT8 CmbFlds;  /* counter of combing field */
+	static UINT8 NumSmFd;  /* counter for same field */
+
+	int mDly = pPar->mPstDlyPre;
+
+	/* UINT8 *PREWV = pRDat.pFlg32; or pRDat.pFlg22 */
+	/* static int TCNm[HISCMBNUM]; history: the number of combing-rows */
+	int *TCNm = pRDat->TCNm;
+	static int NWND[HISDETNUM];/* 6-history,the number of combing windows */
+	static int WGlb[HISDETNUM];	/* Global combing */
+	static unsigned int pFlgXx;
+	static UINT8 pCmbXx[PDXX_PT_NUM];
+
+	UINT8 *pFlg32 = pRDat->pFlg32;	/* [HISDETNUM]; //history information */
+	UINT8 *pMod32 = pRDat->pMod32;	/* [HISDETNUM]; */
+	UINT8 *pFlg22 = pRDat->pFlg22;
+	UINT8 *pMod22 = pRDat->pMod22;
+	UINT8 *mNum32 = pRDat->mNum32;
+	UINT32 *DIF02 = pRDat->rROFrmDif02; /* windows */
+
+	int VOFWnd[2 * VOFWNDNUM]; /* VOF windows 5*(bgn/end) */
+	int nCSum = 0;		/* Combine sum */
+	int nWCmb = 0; /* Total Window combing */
+	int nBCmb = 0; /* combing line of below */
+
+	UINT32 nCb32 = 0;
+
+	UINT32 nRCmbAd[ROWCMBLEN];
+	int nDif02Min = ((nROW * nCOL) >> cmb32_min02_sft);
+	int nT0 = 0;
+	int nT1 = 0;
+	int nT2 = 0;
+	int nT3 = 0;
+
+	pFlgXx = (((pFlgXx >> 1) << 2) |
+			(pRDat->pFlgXx[HISDETNUM - 2] << 1) |
+			(pRDat->pFlgXx[HISDETNUM - 1]));
+
+	/* Initialization */
+	if (BGN == 0) {
+		for (nT0 = 0; nT0 < HISCMBNUM; nT0++) {
+			/* (288/32) */
+			for (nT1 = 0; nT1 < ROWCMBLEN; nT1++) {
+				/* 32-bit (all 1) */
+				HSCMB[nT0][nT1] = 0xffffffff;
+			}
+			TCNm[nT0] = 0;
+		}
+
+		for (nT0 = 0; nT0 < HISDETNUM; nT0++) {
+			NWND[nT0] = 15;
+			WGlb[nT0] = 0;
+			for (nT1 = 0; nT1 < 2 * VOFWNDNUM; nT1++)
+				CWND[nT0][nT1] = 0;
+		}
+
+		BGN = 1;
+	}
+
+	for (nT0 = 1; nT0 < HISCMBNUM; nT0++) {
+		for (nT1 = 0; nT1 < ROWCMBLEN; nT1++)
+			HSCMB[nT0 - 1][nT1] = HSCMB[nT0][nT1];
+		TCNm[nT0 - 1] = TCNm[nT0];
+	}
+
+	/* static int CWND[6][10]; */
+    /* 6-history, 10-5Wnd(bgn/end) */
+	for (nT0 = 0; nT0 < HISDETNUM - 1; nT0++) {
+		for (nT1 = 0; nT1 < 2 * VOFWNDNUM; nT1++)
+			CWND[nT0][nT1] = CWND[nT0 + 1][nT1];
+	}
+
+	for (nT1 = 0; nT1 < 2 * VOFWNDNUM; nT1++) {
+		CWND[HISDETNUM - 1][nT1] = 0;/* f(t-0) vs f(t-1) */
+		VOFWnd[nT1] = 0; /* initialization */
+	}
+
+	/* nS0 = 0; */
+	nCSum = 0;
+	for (nT0 = 0; nT0 < ROWCMBLEN; nT0++) {
+		nCb32 = rROCmbInf[nT0];
+		/* Inf[0]-[31:0], First-[31], Lst-[0] */
+		HSCMB[HISCMBNUM - 1][nT0] = nCb32;
+
+		for (nT1 = 0; nT1 < 32; nT1++) {
+			nCSum += (nCb32 & 0x1);
+			nCb32 = nCb32 >> 1;
+		}
+	}
+
+	if (nCSum > nROW)
+		nCSum = nROW;
+	TCNm[HISCMBNUM - 1] = nCSum; /* the number of combing row */
+
+	for (nT0 = 0; nT0 < HISDETNUM-1; nT0++) {
+		NWND[nT0] = NWND[nT0+1];
+		WGlb[nT0] = WGlb[nT0+1];
+	}
+
+	prt_flg = ((pr_pd >> 5) & 0x1);
+	if (prt_flg)
+		sprintf(debug_str, "#CMB-Dbg\nnCSum=%03d\n", nCSum);
+
+	nT1 = 0;
+	if (pMod32[HISDETNUM - 1] == 3) {
+		if (pFlg32[HISDETNUM - 1] & 0x1)
+			nT1 = 1;
+		else
+			nT1 = 2;
+
+		/* TODO: Check here */
+		WGlb[HISDETNUM-1] = 0;
+
+		for (nT0 = 0; nT0 < ROWCMBLEN; nT0++)
+			nRCmbAd[nT0] = HSCMB[HISCMBNUM - nT1][nT0];
+
+		for (nT1 = nT1 + 1; nT1 <= 5; nT1++) {
+			if (pFlg32[HISDETNUM - nT1] & 0x1) {
+				for (nT0 = 0; nT0 < ROWCMBLEN; nT0++) {
+					nRCmbAd[nT0] =
+						(nRCmbAd[nT0] &
+						HSCMB[HISCMBNUM - nT1][nT0]);
+				}
+			}
+		}
+
+		if (prt_flg)
+			for (nT0 = 0; nT0 < ROWCMBLEN; nT0++)
+				sprintf(debug_str + strlen(debug_str),
+					"nCmd32([%d])=[%08x]\n",
+					nT0, nRCmbAd[nT0]);
+
+		/* return: the number of windows */
+		nT1 = VOFDetSub1(VOFWnd, &nCSum, 3, nRCmbAd, nROW, pPar);
+		nWCmb = 0;
+		nBCmb = 0;
+		for (nT0 = 0; nT0 < nT1; nT0++) {
+			if (VOFWnd[2 * nT0] > (cmb32_blw_wnd * nROW >> 8)) {
+				CWND[HISDETNUM - 1][2 * nT0] =
+					VOFWnd[2 * nT0] - cmb32_wnd_ext;
+				CWND[HISDETNUM - 1][2 * nT0 + 1] =
+					VOFWnd[2 * nT0 + 1] + cmb32_wnd_ext;
+
+				nBCmb = VOFWnd[2*nT0+1]-VOFWnd[2*nT0]+1;
+
+				/* patch for MIT32Mix ending vof */
+				if (CWND[4][2*nT0] < CWND[5][2*nT0])
+					nT2 = CWND[5][2*nT0] - CWND[4][2*nT0];
+				else
+					nT2 = CWND[4][2*nT0] - CWND[5][2*nT0];
+
+				if (CWND[4][2*nT0+1] < CWND[5][2*nT0+1])
+					nT3 = CWND[5][2*nT0+1]
+						- CWND[4][2*nT0+1];
+				else
+					nT3 = CWND[4][2*nT0+1]
+						- CWND[5][2*nT0+1];
+
+				if ((nT2 <= cmb32_wnd_tol) &&
+					(nT3 <= cmb32_wnd_tol)) {
+					if (CWND[4][2*nT0] < CWND[5][2*nT0])
+						CWND[5][2*nT0] = CWND[4][2*nT0];
+
+					if (CWND[4][2*nT0+1]
+						> CWND[5][2*nT0+1])
+						CWND[5][2*nT0+1]
+							= CWND[4][2*nT0+1];
+				}
+				/* patch for MIT32Mix ending vof */
+			}
+			nWCmb += VOFWnd[2*nT0+1]-VOFWnd[2*nT0]+1;
+
+			if (prt_flg)
+				sprintf(debug_str + strlen(debug_str),
+				"Wnd32[%d]=[%3d~%3d]\n", nT0,
+				VOFWnd[2 * nT0], VOFWnd[2 * nT0 + 1]);
+		}
+
+		if (prt_flg)
+			sprintf(debug_str + strlen(debug_str),
+			"frmNoCm=%02d CmbFld=%02d\n",
+			frmNoCmb, CmbFlds);
+
+		/* VOF using last ones */
+		if (nBCmb == 0) {
+			if ((frmNoCmb > cmb32_frm_nocmb) ||
+				(DIF02[0] < nDif02Min))
+				CmbFlds = 0;
+
+			if (frmNoCmb < 255)
+				frmNoCmb = frmNoCmb+1;
+		} else {
+			/* noCombing => combing => noCombing */
+			if (frmNoCmb >= cmb32_cmb_tol)
+				CmbFlds = 0;
+
+			frmNoCmb = 0;
+
+			if (CmbFlds < 255)
+				CmbFlds = CmbFlds+1;
+		}
+
+		/* parameter setting */
+		if ((nBCmb == 0) && (frmNoCmb < cmb32_frm_nocmb) &&
+			(CmbFlds > (cmb32_cmb_tol >> 1)) &&
+			(DIF02[0] > nDif02Min))
+			for (nT0 = 0; nT0 < 2 * VOFWNDNUM; nT0++)
+				CWND[HISDETNUM-1][nT0] = CWND[HISDETNUM-2][nT0];
+		/* VOF using last ones */
+
+		/* patch for cadence-32 */
+		if ((NumSmFd > cmb32_smfrm_num) &&
+			(mNum32[HISDETNUM-1] > cmb32_nocmb_num)) {
+			for (nT0 = 0; nT0 < 2*VOFWNDNUM; nT0++)
+				CWND[HISDETNUM-1][nT0] = 0;
+
+		if (prt_flg)
+				sprintf(debug_str + strlen(debug_str),
+				"NumSmFd=%03d\n", NumSmFd);
+		}
+		/* patch for cadence-32 */
+
+		if (prt_flg)
+			sprintf(debug_str + strlen(debug_str),
+			"nCSum32=%03d, nWndCmb=%03d\n",
+			nCSum, nWCmb);
+		/*
+		if ( nCSum > (nROW>>1) ) {
+			WGlb[HISDETNUM-1] = 1;
+		}
+		*/
+
+		/* here for vertical moving VOF */
+		/* HQV: Mix32- piano+vertical VOF */
+		/* here can be set as parameters */
+		if (pFlg32[HISDETNUM-1] == 5) {
+			/* patch for cadence-32 */
+			if (DIF02[0] < nDif02Min) {
+				if (NumSmFd < 255)
+					NumSmFd = NumSmFd+1;
+			} else
+				NumSmFd = 0;
+			/* patch for cadence-32 */
+
+			/* 256/16 = 16 */
+			/* 64/16  = 4 for 8-bit */
+			/* vertical vof copyright */
+			if (nWCmb < 10)
+				nWCmb = 10;
+
+			nT1 = (nWCmb * nCOL * cmb32_avg_dff + 8) >> 4;
+
+			if ((DIF02[0] >= nT1) && (nWCmb > nBCmb+10))
+				mNum32[HISDETNUM-1] = 0;
+
+			if (prt_flg)
+				sprintf(debug_str + strlen(debug_str),
+				"AvgDif=%d (%d > (%d + 10)\n",
+				DIF02[0]/nCOL/nWCmb, nWCmb, nBCmb);
+		} /* here for vertical moving VOF */
+	} else if ((pMod22[HISDETNUM-1] == 2) &&
+		(pFlg22[HISDETNUM-1] & 0x1)) {
+		nT2 = ((nROW * cmb22_gcmb_rnum + 8) >> 4);
+		if (nCSum > nT2)
+			WGlb[HISDETNUM-1] = 1; /*global combing*/
+
+		if (prt_flg)
+			sprintf(debug_str + strlen(debug_str),
+				"WGlb22=%d\n", WGlb[HISDETNUM-1]);
+
+		for (nT0 = 0; nT0 < ROWCMBLEN; nT0++)
+			nRCmbAd[nT0] = HSCMB[HISCMBNUM-1][nT0];
+
+		for (nT1 = 3; nT1 <= 5; nT1 += 2)
+			for (nT0 = 0; nT0 < ROWCMBLEN; nT0++)
+				nRCmbAd[nT0] = (nRCmbAd[nT0]
+					& HSCMB[HISCMBNUM-nT1][nT0]);
+
+		if (prt_flg)
+			for (nT0 = 0; nT0 < ROWCMBLEN; nT0++)
+				sprintf(debug_str + strlen(debug_str),
+					"nCmd22([%d])=[%08x]\n",
+					nT0, nRCmbAd[nT0]);
+
+		/* return: the number of windows */
+		nT1 = VOFDetSub1(VOFWnd, &nCSum, 2, nRCmbAd, nROW, pPar);
+		for (nT0 = 0; nT0 < nT1; nT0++) {
+			CWND[HISDETNUM-1][2*nT0]   = VOFWnd[2*nT0];
+			CWND[HISDETNUM-1][2*nT0+1] = VOFWnd[2*nT0+1];
+
+			if (prt_flg)
+				sprintf(debug_str + strlen(debug_str),
+					"Wnd22[%d]=[%3d~%3d]\n",
+					nT0, VOFWnd[2*nT0], VOFWnd[2*nT0+1]);
+		}
+	}
+
+	if (prt_flg)
+		pr_info("%s", debug_str);
+
+	if ((pRDat->pLvlXx[HISDETNUM - 1] > flmxx_cal_lcmb) &&
+		(pRDat->pModXx[HISDETNUM - 1] != 6)) {
+		if ((pFlgXx & 0x1) || (DIF02[0] < nDif02Min))
+			nT1 = 1;
+		else
+			nT1 = 2;
+
+		if (prt_flg)
+			sprintf(debug_str, "ModXx=%d, LvlXx=%d, FlgXx=%08x\n",
+			pRDat->pModXx[HISDETNUM - 1],
+			pRDat->pLvlXx[HISDETNUM - 1],
+			pFlgXx);
+
+		for (nT0 = 0; nT0 < ROWCMBLEN; nT0++)
+			nRCmbAd[nT0] = HSCMB[HISCMBNUM - nT1][nT0];
+
+		for (nT1 = nT1 + 1; nT1 <= 10; nT1++) {
+			if ((pFlgXx >> (nT1 - 1)) & 0x1) {
+				for (nT0 = 0; nT0 < ROWCMBLEN; nT0++) {
+					nRCmbAd[nT0] =
+						(nRCmbAd[nT0] &
+						HSCMB[HISCMBNUM - nT1][nT0]);
+				}
+			}
+		}
+
+		if (prt_flg)
+			for (nT0 = 0; nT0 < ROWCMBLEN; nT0++)
+				sprintf(debug_str + strlen(debug_str),
+				"nCmdXx([%d])=[%08x]\n",
+				nT0, nRCmbAd[nT0]);
+
+		nT0 = 4 + pRDat->pModXx[HISDETNUM - 1];
+		/* return: the number of windows */
+		nT1 = VOFDetSub1(VOFWnd, &nCSum, nT0, nRCmbAd, nROW, pPar);
+
+		nWCmb = 0;
+		for (nT0 = 0; nT0 < nT1; nT0++) {
+			CWND[HISDETNUM-1][2*nT0]   = VOFWnd[2*nT0];
+			CWND[HISDETNUM-1][2*nT0+1] = VOFWnd[2*nT0+1];
+
+			if (prt_flg)
+				sprintf(debug_str + strlen(debug_str),
+				"WndXx[%d]=[%3d~%3d]\n",
+				nT0, VOFWnd[2*nT0], VOFWnd[2*nT0+1]);
+
+				nWCmb += VOFWnd[2*nT0+1]-VOFWnd[2*nT0]+1;
+		}
+
+		nT1 = pRDat->pModXx[HISDETNUM - 1];
+		for (nT0 = 0; nT0 < HISDETNUM; nT0++) {
+			if ((nT0 == nT1) &&
+			(nWCmb < ((flmxx_no_cmb[nT1] * nROW) >> 6)))
+				pCmbXx[nT0] = pCmbXx[nT0] + 1;
+			else
+				pCmbXx[nT0] = 0;
+		}
+
+		if (prt_flg)
+			sprintf(debug_str + strlen(debug_str),
+			"nCSum=%3d, nWCmb=%3d, pCmbXx=%d\n",
+			nCSum, nWCmb, pCmbXx[nT1]);
+
+		nT1 = pRDat->pLvlXx[HISDETNUM - 1] + pCmbXx[nT1];
+
+		if (nT1 > 255)
+			nT1 = 255;
+		pRDat->pLvlXx[HISDETNUM - 1] = nT1;
+
+		if (prt_flg)
+			pr_info("%s", debug_str);
+	}
+
+	prt_flg = ((pr_pd >> 1) & 0x1);
+	if (prt_flg)
+		sprintf(debug_str, "#Pre-VOF:\n");
+
+	/* film-mode: pMod22[5-mDly] or pMod32[5-mDly] */
+	if ((*rFlmPstMod == 1) || (*rFlmPstMod == 2)) {
+		/* weaver with pre-field */
+		if (*rFlmSltPre == 1) {
+			/* Interpolation method:0-mtn,1-with-buffer,2-ei,3-di */
+			rPstCYWnd0[0] = CWND[HISDETNUM - 1 - mDly][0];/* bgn */
+			rPstCYWnd0[1] = CWND[HISDETNUM - 1 - mDly][1];/* end */
+			rPstCYWnd0[2] = 3;/* 0-mtn,1-with-buffer,2-ei,3-di */
+
+			rPstCYWnd1[0] = CWND[HISDETNUM - 1 - mDly][2];/* bgn */
+			rPstCYWnd1[1] = CWND[HISDETNUM - 1 - mDly][3];/* end */
+			rPstCYWnd1[2] = 3;/* 0-mtn,1-with-buffer,2-ei,3-di */
+
+			rPstCYWnd2[0] = CWND[HISDETNUM - 1 - mDly][4];/* bgn */
+			rPstCYWnd2[1] = CWND[HISDETNUM - 1 - mDly][5];/* end */
+			rPstCYWnd2[2] = 3;/* 0-mtn,1-with-buffer,2-ei,3-di */
+
+			rPstCYWnd3[0] = CWND[HISDETNUM - 1 - mDly][6];/* bgn */
+			rPstCYWnd3[1] = CWND[HISDETNUM - 1 - mDly][7];/* end */
+			rPstCYWnd3[2] = 3;/* 0-mtn,1-with-buffer,2-ei,3-di */
+
+			/* pFMReg->rFlmPstGCm = WGlb[5-mDly]; */
+			*rFlmPstGCm = WGlb[HISDETNUM - 1 - mDly];
+
+			if (prt_flg) {
+				sprintf(debug_str + strlen(debug_str),
+					"rFlmPstGCm-5=%d\n", *rFlmPstGCm);
+				sprintf(debug_str + strlen(debug_str),
+					"pFlg32=%d, pFlg22=%d\n",
+					pFlg32[HISDETNUM - 1 - mDly],
+					pFlg22[HISDETNUM - 1 - mDly]);
+			}
+		} else {
+			/* weaver with nxt-field */
+			/* Interpolation method: 0-EI,1-MTN,2-MA,3-Weaver */
+			rPstCYWnd0[0] = CWND[HISDETNUM - mDly][0];/* bgn */
+			rPstCYWnd0[1] = CWND[HISDETNUM - mDly][1];/* end */
+			rPstCYWnd0[2] = 3;/* 0-mtn,1-with-buffer,2-ei,3-di */
+			rPstCYWnd1[0] = CWND[HISDETNUM - mDly][2];/* bgn */
+			rPstCYWnd1[1] = CWND[HISDETNUM - mDly][3];/* end */
+			rPstCYWnd1[2] = 3;/* 0-mtn,1-with-buffer,2-ei,3-di */
+			rPstCYWnd2[0] = CWND[HISDETNUM - mDly][4];/* bgn */
+			rPstCYWnd2[1] = CWND[HISDETNUM - mDly][5];/* end */
+			rPstCYWnd2[2] = 3;/* 0-mtn,1-with-buffer,2-ei,3-di */
+			rPstCYWnd3[0] = CWND[HISDETNUM - mDly][6];/* bgn */
+			rPstCYWnd3[1] = CWND[HISDETNUM - mDly][7];/* end */
+			rPstCYWnd3[2] = 3;/* 0-mtn,1-with-buffer,2-ei,3-di */
+			*rFlmPstGCm = WGlb[HISDETNUM - mDly];
+			if (prt_flg) {
+				sprintf(debug_str + strlen(debug_str),
+					"rFlmPstGCm-6=%d\n", *rFlmPstGCm);
+				sprintf(debug_str + strlen(debug_str),
+					"pFlg32=%d, pFlg22=%d\n",
+					pFlg32[HISDETNUM - 1 - mDly],
+					pFlg22[HISDETNUM - 1 - mDly]);
+			}
+		}
+	} else {
+		rPstCYWnd0[0] = 0;	/* bgn */
+		rPstCYWnd0[1] = 0;	/* end */
+		rPstCYWnd0[2] = 3;	/* 0-mtn,1-with-buffer,2-ei,3-di */
+		rPstCYWnd1[0] = 0;	/* bgn */
+		rPstCYWnd1[1] = 0;	/* end */
+		rPstCYWnd1[2] = 3;	/* 0-mtn,1-with-buffer,2-ei,3-di */
+		rPstCYWnd2[0] = 0;	/* bgn */
+		rPstCYWnd2[1] = 0;	/* end */
+		rPstCYWnd2[2] = 3;	/* 0-mtn,1-with-buffer,2-ei,3-di */
+		rPstCYWnd3[0] = 0;	/* bgn */
+		rPstCYWnd3[1] = 0;	/* end */
+		rPstCYWnd3[2] = 3;	/* 0-mtn,1-with-buffer,2-ei,3-di */
+		*rFlmPstGCm = 1;
+
+		if (prt_flg)
+			sprintf(debug_str + strlen(debug_str),
+			"rFlmPstGCm-1=%d\n", *rFlmPstGCm);
+	}
+
+	if (prt_flg) {
+		sprintf(debug_str + strlen(debug_str),
+		"rPstCYWnd=(%d, %d), (%d, %d), (%d, %d), (%d, %d)\n\n",
+			rPstCYWnd0[0], rPstCYWnd0[1],
+			rPstCYWnd1[0], rPstCYWnd1[1],
+			rPstCYWnd2[0], rPstCYWnd2[1],
+			rPstCYWnd3[0], rPstCYWnd3[1]);
+
+		pr_info("%s", debug_str);
+	}
+
+	return nWCmb;
+}
+
+/* int *PREWV:5*2 */
+/* nCNum: total rows of combing */
+int VOFDetSub1(int *VOFWnd, int *nCNum, int nMod, UINT32 *nRCmb, int nROW,
+	       struct sFlmSftPar *pPar)
+{
+	int rCmbRwMinCt0 = pPar->rCmbRwMinCt0;	/* 8; //for film 3-2 */
+	int rCmbRwMinCt1 = pPar->rCmbRwMinCt1;	/* =7; //for film 2-2 */
+	/* int rCmbRwMaxStp=1; //fill in the hole */
+	int rCmbRwMinCt = rCmbRwMinCt1;
+	int nCSUM = 0;	/* Combing sum (nCSUM>rCmbRwMinCt0) */
+	int nMIN = 0;
+	int nT0 = 0;
+	int nT1 = 0;
+	int nT2 = 0;
+	int nCNM = 0;
+	int nBgn = 0;
+	int nEnd = 0;
+	int fEND = 0;
+	int pIDx[VOFWNDNUM + 1][2];	/* Maximum-5windows */
+	int nIDx = 0;
+
+	if (nMod == 3)
+		rCmbRwMinCt = rCmbRwMinCt0;
+
+	for (nT0 = 0; (nT0 < nROW) && (nIDx <= VOFWNDNUM); nT0++) {
+		fEND = 0;
+		nT1 = nROW - 1 - nT0;
+
+		/* if(nRCmb[nT0]==1) */
+		if (Get1RCmb(nRCmb, nT1)) {
+			nCSUM += 1;	/* Total */
+			if (nT0 == 0)
+				nBgn = nT0;
+			else if (nT0 == nROW - 1) {
+				if (Get1RCmb(nRCmb, 1)) {
+					/* at least (2-Row combing) */
+					nEnd = nT0;
+					fEND = 1;
+				}
+			} else if (!Get1RCmb(nRCmb, nT1 + 1)) {
+				/* (nRCmb[nT0-1]==0) */
+				nBgn = nT0;
+			}
+		} else {
+			/* nRCmb[nT0]==0 */
+			if (nT0 != 0 && Get1RCmb(nRCmb, nT1 + 1)) {
+				nEnd = nT0;	/* nT0-1 */
+				fEND = 1;
+			}
+		}
+
+		if (fEND == 0)
+			continue;
+
+		nCNM = nEnd - nBgn + 1;
+		if (nCNM > rCmbRwMinCt || nEnd == nROW - 1) {
+			if (nIDx == VOFWNDNUM) {
+				nMIN = nCNM;
+				nT2 = VOFWNDNUM;
+				for (nT1 = 0; nT1 < VOFWNDNUM; nT1++)
+					if ((pIDx[nT1][1] -
+					pIDx[nT1][0] + 1) < nMIN) {
+						nMIN = pIDx[nT1][1]
+						- pIDx[nT1][0] + 1;
+						nT2 = nT1;
+					}
+				if (nT2 != VOFWNDNUM) {
+					pIDx[nT2][0] = nBgn;
+					pIDx[nT2][1] = nEnd;
+				}
+			} else {
+				pIDx[nIDx][0] = nBgn;
+				pIDx[nIDx][1] = nEnd;
+				nIDx += 1;
+			}
+		}
+	}
+	*nCNum = nCSUM;
+	for (nT0 = 0; nT0 < nIDx; nT0++) {
+		VOFWnd[2 * nT0] = pIDx[nT0][0];/* nBgn */
+		VOFWnd[2 * nT0 + 1] = pIDx[nT0][1];/* nEnd */
+	}
+	return nIDx;
+}
+
+
+/* Get 1-Row combing information, 1bit */
+/* iHSCMB[9]; 9x32=288 */
+UINT8 Get1RCmb(UINT32 *iHSCMB, UINT32 iRow)
+{
+	UINT8 nR1 = 0;
+	UINT8 nBt = 0;
+	nR1 = ((iRow >> 5) & 0xf);/* iRow/32; 0--8 */
+	nBt = (iRow & 0x1f);/* iRow%32 */
+	return (iHSCMB[nR1] >> nBt) & 0x1;
+}
+
-- 
1.9.1

